{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-22T00:55:00.278244+00:00",
  "repo": "lamps-wg/draft-composite-sigs",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOL5eEDM6LI9I2",
      "title": "Carl Wallace's comments on composite signatures v13",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/1",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "opencrypto"
      ],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/147\r\n\r\nBelow are some comments, suggestions, and questions based on a brief review of draft-ounsworth-pq-composite-sigs-13.\r\n\r\nGeneral\r\n\r\nThe draft defines a set of 13 algorithms. Is LAMPS the right forum to vet algorithms? Generally, LAMPS deals with specs that describe how to use a given algorithm relative to PKIX and S/MIME artifacts, not algorithm specifications.\r\nIs the \"Internet PKI\" really the target? Is this kind of designation appropriate for what would appear to be a general-purpose algorithm specification?\r\nThe draft needs a thorough review to sharpen the fact that it now defines a set of 13 algorithms, not a framework for using composite key and signature combinations. Statements like \"should be regarded as a single key\" muddy the water. Even the term \"composite key\" is unhelpful. It's likely that most instances of the word \"composite\" could be written \"Composite ML-DSA.\" Given that this spec defines a means of generating and using keys and signatures, there's no need for all the \"drop-in replacement\" verbiage.\r\nOffhand, I think all of the relevant structures could use templates. Assuming this is correct, it may be worth including a section that notes ASN.1 decoders/encoders are not required.\r\nAll references to \"explicit composites\" should be reviewed and either deleted or amended.\r\nAbstract\r\n\r\nIs a \"X.509, PKIX, and CMS\" target appropriate for an algorithm specification? Is there some reason any of these 13 algorithms could not be used in a different context?\r\ns/Signaturem/Signature\r\nSections 2.3.1 - 2.3.3\r\n\r\nThese sections should include references to the relevant sections of each possible component algorithm. There is a list of algorithms in Section 5 (with a broken link for ML-DSA) but, given this is an algorithm specification, including more detail in the key generation, signature generation and signature verification sections would be appropriate and helpful.\r\ns/sketched/defined\r\nThere are two references to \"recursive composite public keys.\" These should be removed given they are not supported by definition.\r\nSection 2.3.1\r\n\r\ns/The KeyGen() -> (pk, sk) of a composite signature algorithm will perform the KeyGen() of the respective component signature algorithms / KeyGen() will perform the KeyGen() of the respective component signature algorithms\r\nIt's probably worth including pseudocode as done for Sign() and Verify()\r\nRewrite the last sentence to be Composite ML-DSA specific: The component keys MUST be uniquely generated for use in a Composite ML-DSA key.\r\nSection 2.3.2\r\n\r\nThe second and third steps could use some work. In step 2, S1 and S2 are raw signatures from a component algorithm. In step 3, they are BIT STRINGs containing the raw signatures. Additionally, it is unlikely the \"algorithm specifications\" address encoding as a BIT STRING. Suggest rewriting bullet 3 as below:\r\n\r\nEncode each component signature S1 and S2 as BIT STRINGs B1 and B2 then as a SEQUENCE\r\n\r\nsignature ::= Sequence { B1, B2 }\r\n\r\ns/A composite signature MUST produce/Sign() MUST produce\r\n\r\nSection 2.4\r\n\r\nDrop the word concatenation. No OIDs are being concatenated. There are other references to OID concatenation throughout the document that should be reviewed as well.\r\nSection 2.6\r\n\r\nDepending on the answer to the first question in General above, the following sentence may need to be removed or amended: \"If other combinations are needed, a separate specification should be submitted to the IETF LAMPS working group.\"\r\nThe statement that this \"also does not preclude future specification from extending these structures\" is false. The definitions are fixed at length 2. That someone could define a new specification with other lengths need not be commented on here. Suggest removing this sentence.\r\nSection 3\r\n\r\nReplace \"multiple algorithms\" with \"algorithm pairs\" or similar. Same comment applies throughout the draft.\r\nFWIW, I did not test compile the ASN.1 or work with the examples yet.\r\nGiven ECPoint is an alias for OCTET STRING do we need to ability to define types for each component, or can the object class be simplified to assert all component keys are simply OCTET STRINGs?\r\nSection 3.2\r\n\r\nThe reference to Table 3 is not altogether apt. The table lists signature algorithms. There should probably be a similar table for use in reconstituting SubjectPublicKeyInfo values (i.e., including curve name for parameters).\r\nSection 3.4\r\n\r\nWhy is this section necessary? The public key format defined by this specification is CompositeSignaturePublicKey. If someone wants to encode this in an OCTET STRING or BIT STRING that's their business.\r\nI would delete the entire section, but if the section remains, I would definitely delete the last sentence. The definitions provided call for DER encoding. Immediately following that with allowance for BER in the \u201cinterests of simplicity and avoiding compatibility issues\u201d is odd in that it provides for neither. If you want to support BER and DER, cite BER encoding. But why do that? Amongst other things, that would break ability to templatize the artifacts.\r\nSection 5\r\n\r\nRemove \"for explicit combinations\" from the first sentence.\r\nRemove the second paragraph given the list is exhaustive for this specification.\r\nRemove the third paragraph since only 13 algorithms are defined. There is no flexibility provided for in this specification to define other combinations.\r\nSecurity Considerations\r\n\r\nThis section should incorporate security considerations from component algorithms by reference.\r\nThe section still reflects the earlier versions before the scope was limited to focus on 13 algorithms. It could use some pruning. Maybe move some of the stripping discussion to the signature generation section.\r\nAll considerations are listed under the same heading. These should be broken up into new subsections (or the heading removed).\r\nSection B.2\r\n\r\nThis section (and subsections) should probably be deleted. At a minimum, they aren't really \"Implementation considerations\" for the 13 algorithms that are the subject of the draft.",
      "createdAt": "2024-06-04T21:14:50Z",
      "updatedAt": "2024-07-08T16:54:59Z",
      "closedAt": "2024-07-08T16:54:59Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th -  Lets all look at Carl's comments and discussion on June 19th.  ",
          "createdAt": "2024-06-05T14:41:05Z",
          "updatedAt": "2024-06-05T14:41:05Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOL5eEDM6LI9xE",
      "title": "Address Kris comments about Section B.1 on FIPS #145",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/2",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/145\r\n\r\nAddress Kris's comments:\r\n\r\nZjQcmQRYFpfptBannerEnd\r\nIn the section \"B.1 FIPS certification\", the draft says:\r\n\r\n\"algorithm to be [...] considered FIPS-approved even when one of the component algorithms is not\"\r\nand then\r\n\"overall composite should be considered full strength and thus FIPS-approved\"\r\nI think, the \"full strength\" may be misleading. Also the term is not clearly defined. Hence, it could be understood as \"full strength of classical+PQ\" and that is opposite to what NIST FAQ [1] says. I.e. let say MLDSA is FIPS-approved in a future, and we create composite with MLDSA-44 + some on-ramp signature that claims level 5. Does it mean the strength of that construct should be considered FIPS-approved with security strength of equal to level 2 or 5?\r\n\r\nAs this draft is now about creating composite signatures with MLDSA, so do we need B.1? The discussion about FIPS-approved dual signature schemes sounds like a great discussion to have, but in a different place (and ideally on CMUF forum).\r\n\r\nMy suggestion would be to remove B.1 to avoid spreading potentially misleading information about important topic.\r\n\r\nAdditional nit:\r\n\r\nThe abstract says \"Composite algorithms are provided which combine ML-DSA with RSA, ECDSA, Ed25519, and Ed448.\". Shouldn't it say MLDSA only?\r\n--\r\nKris Kwiatkowski\r\nCryptography Dev\r\n\r\n\r\n--- Group discussed this and decide to change the following:\r\n\r\nchange:\r\noverall composite should be considered full strength and thus FIPS-approved\"\r\nto\r\noverall composite should be considered at least as strong and thus FIPS-approved\"\r\n\r\nuntil FIPS deprecates RSA or EC...",
      "createdAt": "2024-06-04T21:16:55Z",
      "updatedAt": "2024-06-06T16:07:03Z",
      "closedAt": "2024-06-06T16:07:03Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The comment was addressed and the issue has been resolved is -01 version",
          "createdAt": "2024-06-06T16:07:03Z",
          "updatedAt": "2024-06-06T16:07:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOL5eEDM6LI-F0",
      "title": "Unreferenced section \"Parallel PKIs\"",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/3",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/143\r\n\r\nThe section [\"Parallel PKIs\"](https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/blob/final13copies/draft-ounsworth-pq-composite-sigs.md#parallel-pkis) in \"Implementation Considerations\" introduces a term that is not used throughout the document and therefore should be removed.\r\n\r\nTeam decided to remove the section on Parallel PKI's",
      "createdAt": "2024-06-04T21:17:56Z",
      "updatedAt": "2024-06-06T16:06:02Z",
      "closedAt": "2024-06-06T16:06:01Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue was resolve in version -01",
          "createdAt": "2024-06-06T16:06:01Z",
          "updatedAt": "2024-06-06T16:06:01Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOL5eEDM6LI-ad",
      "title": "Add a \"SignedInfo Conventions\" section",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/4",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:   https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/136\r\n\r\nMake-like-picture from\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-lamps-cms-sphincs-plus-03#name-signed-data-conventions\r\n\r\nWe also need to add SMIME-CAPS to the ASN.1. See the draft-cms-sphincs-plus\r\n\r\nDoing this saves writing a separate draft of using this draft in CMS... Use link from Mike above SPHINCS template.",
      "createdAt": "2024-06-04T21:19:04Z",
      "updatedAt": "2024-06-19T20:39:11Z",
      "closedAt": "2024-06-19T20:39:11Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Action:  John to take a look at this (from what Mike did in Composite KEM), with the idea that maybe lamps will want us to put it in a separate document.   To present this section next meeting (June 19th).",
          "createdAt": "2024-06-05T14:40:05Z",
          "updatedAt": "2024-06-05T14:40:05Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue resolved in Pull request #13 ",
          "createdAt": "2024-06-19T20:39:11Z",
          "updatedAt": "2024-06-19T20:39:11Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOL5eEDM6LI_C2",
      "title": "Resolve OID registration - Entrust assignment or IANA assignment",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/5",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/126\r\n\r\nRuss suggested Entrust could just assign the OIDs for composite sigs since we maintain an OID repository. Discuss this with the authors group and add to the next version -13?\r\n\r\nFrom Russ: \": If you are going to use the Entrust OID arc for the module assignment, why not assign it now.\"\r\n\r\nFor example, the module assignment could be:\r\nComposite-Signatures-2023\r\n{ joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)\r\nalgorithm(80) composite(8) id-composite-signatures-2023 (1) }\r\n\r\nToday we have:\r\nComposite-Signatures-2023\r\n{ joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)\r\nalgorithm(80) id-composite-signatures-2023 (TBDMOD) }\r\n\r\nAnd in Composite KEM we are using (for comparison):\r\n\r\nComposite-KEM-2023\r\n{iso(1) identified-organization(3) dod(6) internet(1)\r\nsecurity(5) mechanisms(5) pkix(7) id-mod(0)\r\nid-mod-composite-kems(TBDMOD) }\r\n\r\n\r\nMike and I discussed, we think having IANA assignment would make it more official and not look like it is only for Entrust.   The group decided that IANA assignment is the way to go, this will align with Composite KEM as well\r\n\r\n",
      "createdAt": "2024-06-04T21:21:15Z",
      "updatedAt": "2024-10-17T19:20:34Z",
      "closedAt": "2024-10-17T19:20:34Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided we would request official OIDs from IANA and that is what is currently in the draft.",
          "createdAt": "2024-10-17T19:20:34Z",
          "updatedAt": "2024-10-17T19:20:34Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOL5eEDM6LI_pD",
      "title": "Should we consider compacting the CompositeSignaturePrivateKey Format like we did with the public key format?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/6",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/121\r\n\r\nWe simplified the composite signature public key format from:\r\n\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo\r\nto\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2) OF BIT STRING\r\n\r\nWe haven't changed the CompositePrivateKeyFormat:\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OneAsymmetricKey\r\n\r\nOneAsymmetric Key from RFC 5958 is this:\r\n\r\nOneAsymmetricKey ::= SEQUENCE {\r\nversion Version,\r\nprivateKeyAlgorithm PrivateKeyAlgorithmIdentifier,\r\nprivateKey PrivateKey,\r\nattributes [0] Attributes OPTIONAL,\r\n...,\r\n[[2: publicKey [1] PublicKey OPTIONAL ]],\r\n...\r\n}\r\n\r\nPrivateKey ::= OCTET STRING\r\n-- Content varies based on type of key. The\r\n-- algorithm identifier dictates the format of\r\n-- the key.\r\n\r\nOneAsymmetricKey can carry the public key and has the algorithmIdentifier and version fields which are really redundant information. I think we could simply do this:\r\n\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF PrivateKey\r\n\r\nwhich is effectively:\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OCTET STRING\r\n\r\nIt would allow sending composite private keys in PKCS12, or in raw encrypted blobs, to be smaller.\r\n\r\n\r\nAs of May 8th, 2024 - We are leaning in making this compact change - after getting the v14 update published on the lamp-wg github.\r\n\r\nIt also has the benefit of making key consistency better defined as a static mapping of the algorithm details needs to be used to reonstruct the private key.",
      "createdAt": "2024-06-04T21:23:19Z",
      "updatedAt": "2024-10-18T17:18:33Z",
      "closedAt": "2024-10-18T17:18:33Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th - We will keep this one here, revisit after the final standards are released.",
          "createdAt": "2024-06-05T14:32:52Z",
          "updatedAt": "2024-06-05T14:32:52Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "From Piotr:\r\n\r\nHi All\r\n\r\nI strongly support this change and point out that it is consistent with the current wording of Section 5.3, which indicates that CompositeSignaturePrivateKey is a component of the OneAsymmetricKey structure, not the OneAsymmetricKey structure itself. See:\r\n\r\n> When a CompositeSignaturePrivateKey is conveyed inside a\r\n\r\n> OneAsymmetricKey structure (version 1 of which is also known as\r\n\r\n> PrivateKeyInfo) [RFC5958], the privateKeyAlgorithm field SHALL be set\r\n\r\n> to the corresponding composite algorithm identifier defined according\r\n\r\n> to Section 7, the privateKey field SHALL contain the\r\n\r\n> CompositeSignaturePrivateKey, and the publicKey field MUST NOT be\r\n\r\n> present.\r\n\r\nAlso discussed this related issue for libOQS:   https://github.com/open-quantum-safe/oqs-provider/issues/466",
          "createdAt": "2024-08-14T14:18:00Z",
          "updatedAt": "2024-08-14T14:18:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "August 14th, 2024:   The authors group has agreed to do this work:  ",
          "createdAt": "2024-08-14T14:19:42Z",
          "updatedAt": "2024-08-14T14:19:42Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Dan sent an e-mail about this:\r\n\r\nFrom: Daniel Van Geest <daniel.vangeest@cryptonext-security.com>\r\nSent: Wednesday, September 25, 2024 1:12 PM\r\nTo: Mike Ounsworth <Mike.Ounsworth@entrust.com>; Klau\u00dfner, Jan <Jan.Klaussner@bdr.de>; draft-ietf-lamps-pq-composite-sigs.authors@ietf.org <draft-ietf-lamps-pq-composite-sigs.authors@ietf.org>\r\nSubject: [EXTERNAL] Re: Composite signatures and EDDSA encodings\r\n \r\n\r\nSomewhat related, do you have plans to rework the CompositeSignaturePrivateKey encoding? (I think so, though I don't have time to read the whole issue right now: [https://github.com/lamps-wg/draft-composite-sigs/issues/6](https://urldefense.com/v3/__https://github.com/lamps-wg/draft-composite-sigs/issues/6__;!!FJ-Y8qCqXTj2!ecsMNqCGlAEX2ne7BdcIzmqmpLC4fM-vzdk_KgLPoG1gkqSAPPM0fygE9OVcg9lxd3oRSOYgppADe-yC1hyamvRfmeqc78sEkZoG8pI$))\r\nIf you're leaving it as a SEQUENCE of OneAsymmetricKey, then there's a bug in the OQS composite signatures implementation which I'll have to report (they don't do the double wrapping of the private key as specified in RFC 8410), but if it's changing then there's no need to report it as the implementation will likely change as the format changes.\r\nDaniel Van Geest",
          "createdAt": "2024-09-25T17:17:41Z",
          "updatedAt": "2024-09-25T17:17:41Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I replied to Dan with this:\r\n\r\nHi Dan,\r\n\r\nYes, on August 14th our group agreed to make this change...    It will align better with what we did for public keys and remove redundant information.   It hasn't been updated in the document, but we are diligently working through the outstanding issues, trying to get them all resolved before the October 21st cutoff date.\r\n\r\nCheers,\r\n\r\nJohn Gray",
          "createdAt": "2024-09-25T17:18:25Z",
          "updatedAt": "2024-09-25T17:18:25Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dan vG further voted to keep it as SEQUENCE OF OneAsymmetricKey:\r\n\r\n> Regarding the composite private key being a SEQUENCE of OneAsymmetricKey, from an implementation perspective that's actually really convenient because there will already be PKCS#8 or RFC 5958 APIs for the component private keys, so you only need to stick those in a SEQUENCE.  Making it a SEQUENCE of PrivateKey complicates the implementation somewhat because, if you mean the same PrivateKey in the OneAsymmetricKey, there's often not an API to get that directly so you may have to dissect the OneAsymmetricKey ASN.1 to get at it.  But of course it's a trade-off to reduce the complexity in the composite private key format, and probably a good trade-off.  I'm actually in the middle of making such a dissecting change myself, so I'll see how bad it is!\r\n",
          "createdAt": "2024-09-25T20:53:48Z",
          "updatedAt": "2024-09-25T20:53:48Z"
        },
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "That comment wasn't a vote in either direction, it was just a point for consideration :)  It would be really nice to get rid of the redundancy of the OneAsymmetricKeys, and that's the way I would lean.  I just think the text has to be extra clear about what the PrivateKey OCTET STRING contains, i.e. the structure of the public key is in PUBLIC-KEY.&PrivateKey from the public key identifier of the component keys.\r\n\r\n> Dan vG further voted to keep it as SEQUENCE OF OneAsymmetricKey:\r\n> \r\n> > Regarding the composite private key being a SEQUENCE of OneAsymmetricKey, from an implementation perspective that's actually really convenient because there will already be PKCS#8 or RFC 5958 APIs for the component private keys, so you only need to stick those in a SEQUENCE.  Making it a SEQUENCE of PrivateKey complicates the implementation somewhat because, if you mean the same PrivateKey in the OneAsymmetricKey, there's often not an API to get that directly so you may have to dissect the OneAsymmetricKey ASN.1 to get at it.  But of course it's a trade-off to reduce the complexity in the composite private key format, and probably a good trade-off.  I'm actually in the middle of making such a dissecting change myself, so I'll see how bad it is!\r\n\r\n",
          "createdAt": "2024-09-25T22:02:57Z",
          "updatedAt": "2024-09-25T22:02:57Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group is agreeing to change it to:\r\n\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OCTET STRING",
          "createdAt": "2024-10-16T15:05:37Z",
          "updatedAt": "2024-10-16T15:05:37Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in Pull #68 ",
          "createdAt": "2024-10-18T17:18:33Z",
          "updatedAt": "2024-10-18T17:18:33Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOL5eEDM6LJAQa",
      "title": "Add a new section: explicitely list SPKI AlgIds",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/7",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/116\r\n\r\nWe should add a section listing explicitly the DER-encoded AlgorithmIdentifiers for the components of each composite public key and signature algorithm. This is important to resolve ambiguity on, for example, whether the RSA should have a NULL param, and the ECC curve params.\r\n\r\nExample, for id-MLDSA44-ECDSA-P256-SHA256 the ML-DSA SPKI would have an AlgorithmIdentifier of:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ml-dsa\r\n    }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  }\r\nAnd the ECDSA-P256-SHA256 would have a SPKI would have an AlgorithmIdentifier of:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ecPublicKey,\r\n       secp256r1  \r\n  }\r\nwhich is:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) keyType(2) 1 },\r\n       iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3) prime(1) 7}\r\nAnd the signature algorithm for id-MLDSA44-ECDSA-P256-SHA256, the first component signature algorithm would have an AlgorithmIdentifier of\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ml-dsa\r\n    }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  }\r\nand the second component signature algorithm would have an AlgorithmIdentifier of\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n          ecdsa-with-SHA256\r\n  }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n           {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2\r\n       }\r\n  }\r\nWith that done, we should replace the message prefix values in Sectien 2.4 with the SHA256 hash of the signature AlgorithmIdentifiers. This has two nice properties that are better than using the ASCII encoding of the OID name: 1) they are all the same length (ie the length of SHA256), and 2) if the inner OIDs change, for example with a new Kyber version, then the message prefix changes, which prevents cryptographic compatibility issues; or otherwise stated: provides signature domain-separation based on the component OIDs.\r\n\r\n--- SHA256 of the DER encoding of the following ASN.1 value\r\n--- Security Consideration note: the choice of SHA256 here is not security-relevant since it is only to generate fixed string values.\r\n\r\nSEQUENCE {\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  },\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n           {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2\r\n       }\r\n  }\r\n}",
      "createdAt": "2024-06-04T21:24:28Z",
      "updatedAt": "2024-10-17T19:41:11Z",
      "closedAt": "2024-10-17T19:41:11Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th - Group would like to make the draft more clear in this regard, but not explode the draft.  Suggestion of a table or template section for RSA to make things more clear.    Action:  Jan to take a look at this for the next meeting (June 19th, 2024).",
          "createdAt": "2024-06-05T14:37:29Z",
          "updatedAt": "2024-06-05T14:37:29Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @johngray-dev,  @ounsworth ,\r\nI tried to write these things together (https://github.com/lamps-wg/draft-composite-sigs/blob/7-add-a-new-section-explicitely-list-spki-algids/draft-ietf-lamps-pq-composite-sigs.md) and have a question: \r\n\r\nThe algorithm for compiling the component OIDs to the hash value is easy but nevertheless an algorithm with the possibility for errors.\r\nIf we want domain separation that way we definitely need to include the EC parameter OID in the algorithm, else NIST and brainpool curves would have the same hash. Additionally we should have a rational why we do not include the PreHash OID here. Or include this also.\r\n\r\nThis said, this whole thing only makes sense during the development phase, because we dont know the MLDSA OIDs yet. But once they are fixed, also our combination matrix is fixed with new and official CompSig OIDs. So just Hashing the CompSig OID would do the same job and is much easier to describe in the signature algorithm.\r\nI am afraid reviewers would reject the compilation algorithm for the same reason.\r\n\r\nSo the question is, do we want to go the whole way of flexibility and define the compilation algorithm (that I would gladly do and maybe reuse for the kofn algorithm) or do we go the shortcut.\r\n\r\nWhat do you think? Do I miss something here?",
          "createdAt": "2024-06-28T15:48:25Z",
          "updatedAt": "2024-06-28T15:48:25Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening issue because the SPKI part of the issue has not been completed yet. ",
          "createdAt": "2024-09-11T14:36:38Z",
          "updatedAt": "2024-09-11T14:36:38Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOL5eEDM6LZ3vD",
      "title": "ML-DSA public keys should be unwrapped BIT STRINGS with no ASN.1 typing",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/9",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See on-list discussion: https://mailarchive.ietf.org/arch/msg/spasm/oH68LMpwXtpvltK2PnQSCUO9s0k/\r\n\r\nI see that draft-ietf-lamps-dilithium-certificates-03 does this:\r\n\r\n~~~\r\n  pk-MLDSA PUBLIC-KEY ::= {\r\n    IDENTIFIER id-MLDSA\r\n    -- KEY no ASN.1 wrapping --\r\n    PARAMS ARE absent\r\n    CERT-KEY-USAGE { nonRepudiation, digitalSignature,\r\n                    keyCertSign, cRLSign }\r\n    --- PRIVATE-KEY no ASN.1 wrapping --\r\n  }\r\n~~~\r\n",
      "createdAt": "2024-06-06T17:32:33Z",
      "updatedAt": "2024-09-25T18:56:43Z",
      "closedAt": "2024-09-25T18:56:42Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Carl suggested:\r\n\r\n~~~\r\nOr this (also not yet test compiled) definition:\r\n\r\n     id-raw-key ::= SOME OBJECT IDENTIFIER\r\n   pk-CompositeSignature {OBJECT IDENTIFIER:id,\r\n     FirstPublicKeyType,SecondPublicKeyType }\r\n       PUBLIC-KEY ::= {\r\n         IDENTIFIER id\r\n         KEY SEQUENCE {\r\n           firstPublicKey BIT STRING (CONTAINING FirstPublicKeyType  | ENCODED BY id-raw-key),\r\n           secondPublicKey BIT STRING (CONTAINING SecondPublicKeyType | ENCODED BY id-raw-key)\r\n         }\r\n         PARAMS ARE absent\r\n         CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign}\r\n       }\r\n\r\n~~~",
          "createdAt": "2024-06-06T18:31:18Z",
          "updatedAt": "2024-06-06T18:31:18Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Russ suggested:\r\n\r\n~~~\r\npk-MLDSA87-ECDSA-P384-SHA512 PUBLIC-KEY ::= {\r\n  IDENTIFIER id-MLDSA87-ECDSA-P384-SHA512\r\n  KEY SEQUENCE {key1 BIT STRING, key2 ECPoint}\r\n  PARAMS ARE absent\r\n  CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign} )\r\n~~~\r\n\r\nwith some text to explain that BIT STRING is unwrapped / raw.",
          "createdAt": "2024-06-06T21:12:51Z",
          "updatedAt": "2024-06-06T21:12:51Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #11 ?",
          "createdAt": "2024-07-03T15:00:14Z",
          "updatedAt": "2024-07-03T15:00:14Z"
        },
        {
          "author": "carl-wallace",
          "authorAssociation": "NONE",
          "body": "The suggestion attributed to me on June 6th is obsolete. There was a later suggestion that eliminates the embedded SEQUENCE, which causes bloat in code generated using these ASN.1 definitions. See: https://mailarchive.ietf.org/arch/msg/spasm/b7rvHiKnA80oZ-VqQY7LIoFdsu8/. \r\n\r\nNote, the reason for the suggestion of id-raw-key was your use of CONTAINING in the definition. You can't use CONTAINING with data not describing using ASN.1, so this isn't a case where you can use prose as with Russ' suggestions (there is no CONTAINING clause in SubjectPublicKeyInfo).",
          "createdAt": "2024-08-05T10:13:11Z",
          "updatedAt": "2024-08-05T10:13:11Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOL5eEDM6LZ38A",
      "title": "ASN.1 module still contains FN-DSA definitions",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/10",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Remove them.",
      "createdAt": "2024-06-06T17:32:57Z",
      "updatedAt": "2024-06-18T15:13:04Z",
      "closedAt": "2024-06-18T15:13:03Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed the \"Falon\" definition (which was a typo and why I missed it in the first place).   See:  https://github.com/lamps-wg/draft-composite-sigs/commit/d3e2c8e1296bf6d9d634ab7d0e9c7629e243aac0\r\n\r\n\r\n",
          "createdAt": "2024-06-18T15:13:03Z",
          "updatedAt": "2024-06-18T15:13:03Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOL5eEDM6LZ42X",
      "title": "Should the pk-CompositeSignature ASN.1 constructor be unrolled for each type?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/11",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We defined the pk-CompositeSignature information object class so that the rest of the ASN.1 module could be more compact, but it might be limiting optimization since this draft is now ML-DSA only. Perhaps we should remove this and and just directly define the PUBLIC-KEY structure for each public key type?\r\n\r\nSee, for example, the definition from draft-ietf-lamps-dilithium-certificates-03\r\n\r\n~~~\r\n  pk-MLDSA PUBLIC-KEY ::= {\r\n    IDENTIFIER id-MLDSA\r\n    -- KEY no ASN.1 wrapping --\r\n    PARAMS ARE absent\r\n    CERT-KEY-USAGE { nonRepudiation, digitalSignature,\r\n                    keyCertSign, cRLSign }\r\n    --- PRIVATE-KEY no ASN.1 wrapping --\r\n  }\r\n~~~",
      "createdAt": "2024-06-06T17:35:24Z",
      "updatedAt": "2024-10-17T19:19:31Z",
      "closedAt": "2024-10-17T19:19:30Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided to look at this in more detail post IETF 120.",
          "createdAt": "2024-07-03T14:48:21Z",
          "updatedAt": "2024-07-03T14:48:21Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The optimization that I would like us to take advantage of is to more closely match the public key encoding from \r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-lamps-dilithium-certificates-03#name-asn1-module\r\n\r\nWe should check the DER encoding of the Dilithium public key within a composite public key against the sample in the dilithium-certs draft. The question is whether the composite is adding an extra OCTET STRING tag which is not strictly necessary.",
          "createdAt": "2024-07-03T14:51:10Z",
          "updatedAt": "2024-07-03T14:51:10Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This was done based on Carl Wallace's comments and subsequent updates to the ASN.1 module.   ",
          "createdAt": "2024-10-17T19:19:30Z",
          "updatedAt": "2024-10-17T19:19:30Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOL5eEDM6M6Mps",
      "title": "SHA256withECDSA vs ECDSAwithSHA256",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/14",
      "state": "CLOSED",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "I'm curious why in the \"Composite Signature Algorithms\" table, SHA256withECDSA for example is used instead of ECDSAwithSHA256? Isn't the latter more commonly used terminology?",
      "createdAt": "2024-06-20T10:13:31Z",
      "updatedAt": "2024-07-08T17:08:16Z",
      "closedAt": "2024-07-08T17:08:16Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "In July 3rd, Jan said he would update the table.  ",
          "createdAt": "2024-07-03T14:41:47Z",
          "updatedAt": "2024-07-03T14:41:47Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "updated the naming in the table in PR#16",
          "createdAt": "2024-07-05T21:03:17Z",
          "updatedAt": "2024-07-05T21:03:17Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Confirmed that Jan resolved this in #16 ",
          "createdAt": "2024-07-08T17:08:16Z",
          "updatedAt": "2024-07-08T17:08:16Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOL5eEDM6N66ds",
      "title": "PSS parameter spec tables should include the SALT length",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/15",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The suggested PSS parameter tables for id-MLDSA44-RSA2048-PSS-SHA256 and id-MLDSA65-RSA3072-PSS-SHA512 don't give any indication of the salt length to use.   \r\n\r\nIn my implementation we used 64-bytes for both, but RFC's 4055 and 8017 suggest the typical salt length as one that matches the hashing length.  This would indicate a \"typical\" salt length of 32 for id-MLDSA44-RSA2048-PSS-SHA256 and 64 id-MLDSA65-RSA3072-PSS-SHA512\r\n\r\nRFC 8017 section 9.1 says this:\r\n\r\nTypical salt lengths in octets are hLen (the length of the output\r\n       of the hash function Hash) and 0.  In both cases, the security of\r\n       RSASSA-PSS can be closely related to the hardness of inverting\r\n       RSAVP1. \r\n\r\nFrom Tim Holobeek:\r\n\r\nHello,\r\n\r\nOur engineering team has been looking at composite signatures, and found a potential ambiguity.  The draft uses OIDs for everything, with no parameters (good), but this begs the question of what the right parameters are for rsa-pss, in particular the salt length, which isn\u2019t included in the parameters table.\r\n\r\nThere\u2019s also the question of what the right answer is, which honestly I haven\u2019t had time to review.  They\u2019re saying that RFC 4055 suggests matching the length of the hash in its security considerations section, which sounds reasonable, but Openssl seems to be hard-coded to always use 64 bytes of salt.  Which sounds right to me for SHA512 but not necessarily SHA256.",
      "createdAt": "2024-06-28T19:17:03Z",
      "updatedAt": "2024-07-03T20:45:54Z",
      "closedAt": "2024-07-03T20:45:53Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments.   We added PSS salt parameters.   We used 256 bits for id-MLDSA44-RSA2048-PSS-SHA256 and 512 bits for  id-MLDSA65-RSA3072-PSS-SHA512\r\n\r\nhttps://github.com/lamps-wg/draft-composite-sigs/commit/5753715bfe3cf35b5f797b14d8584041459a3266",
          "createdAt": "2024-07-03T20:45:53Z",
          "updatedAt": "2024-07-03T20:45:53Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOL5eEDM6OtEHB",
      "title": "Synchronize sections and writing style of composite sigs and kems",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/17",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-07T19:05:13Z",
      "updatedAt": "2024-10-21T20:31:31Z",
      "closedAt": "2024-10-21T20:31:31Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved as part of Pull #72 ",
          "createdAt": "2024-10-21T20:31:31Z",
          "updatedAt": "2024-10-21T20:31:31Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOL5eEDM6O0h2y",
      "title": "Should the DomSep be Hash( DER(OID) ) instead of DER(OID)",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/19",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The rationale for making it a hash is so that the domain separator Hex string is the same length, even if the OIDs end up being different lengths; for example if IANA decides to assign from multiple arcs, or if in the future (Falcon, new PQ sigs), we get OIDs from different arcs.\r\n\r\nOn the other hand, maybe it is ok for the domain separators to be different lengths, as long as they are pre-determined and not completely variable length (ie length is controllable by an attacker).",
      "createdAt": "2024-07-08T17:05:06Z",
      "updatedAt": "2024-09-11T14:34:04Z",
      "closedAt": "2024-09-11T14:34:04Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Authors group agreed we will keep it as a DER (OID) instead of a HASH (DER(OID)).",
          "createdAt": "2024-09-11T14:34:04Z",
          "updatedAt": "2024-09-11T14:34:04Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOL5eEDM6O80RT",
      "title": "Read Carl's email",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/20",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ounsworth"
      ],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/spasm/b7rvHiKnA80oZ-VqQY7LIoFdsu8/. The point below is the that using a template like this with an embedded ASN.1 definition causes compilers (or at least the compiler I use) to emit far more code than if the structure were factored out of the template definition. I\u2019ve not spent any time with composite-kem yet, but it looks like some of the comments I had relative to the composite-signatures draft would apply here too.",
      "createdAt": "2024-07-09T13:56:32Z",
      "updatedAt": "2024-10-17T19:18:26Z",
      "closedAt": "2024-10-17T19:18:26Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This work was done in composite signatures, now the composite KEM draft needs to also be updated.",
          "createdAt": "2024-09-25T18:57:53Z",
          "updatedAt": "2024-09-25T18:57:53Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This work was completed in signatures.  ",
          "createdAt": "2024-10-17T19:18:26Z",
          "updatedAt": "2024-10-17T19:18:26Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOL5eEDM6O87nU",
      "title": "Feedback from Piotr",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/21",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/69ApI6-0EjcaQrel70vAV1Avyho/",
      "createdAt": "2024-07-09T14:09:54Z",
      "updatedAt": "2024-10-18T17:30:08Z",
      "closedAt": "2024-10-18T17:30:08Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We will mention this as part of the Change log.   We believe the comments have been addressed in the most recent changes to the draft.  ",
          "createdAt": "2024-10-18T17:30:08Z",
          "updatedAt": "2024-10-18T17:30:08Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOL5eEDM6PReke",
      "title": "Match \"Algorithm selection criteria\" to actual selections",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/22",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "Currently, the Security Consideration section \"Public Key Algorithm Selection Criteria\" says:\r\n\r\n> A single RSA combination is provided at a key size of 3072 bits, matched with NIST PQC Level 3 algorithms.\r\n\r\nBut that's not true because we actually have 4 RSA combinations at both Level 2 and Level 3.\r\n\r\n~~~\r\nid-MLDSA44-RSA2048-PSS-SHA256\r\nid-MLDSA44-RSA2048-PKCS15-SHA256\r\nid-MLDSA65-RSA3072-PSS-SHA512\r\nid-MLDSA65-RSA3072-PKCS15-SHA512\r\n~~~",
      "createdAt": "2024-07-11T17:44:09Z",
      "updatedAt": "2024-09-25T19:18:25Z",
      "closedAt": "2024-09-25T19:18:25Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOL5eEDM6PUw0z",
      "title": "An End User would like a composite with an RSA-4096 component algorithm",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/23",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "An end user wants us to add a 4096 bit composite combination:\r\n\r\nMy reading of the specs matches like this:\r\nhttps://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf\r\n\r\n112 bits of security   RSA 2048   \r\n128 bits of security   RSA 3072   ML-DSA-44\r\n192 bits of security   RSA 7680   ML-DSA-65\r\n256 bits of security RSA-15360  ML-DSA-87\r\n\r\nSo we can either switch the RSA-3072 ones to 4096 or add new composite combinations with RSA-4096\r\n",
      "createdAt": "2024-07-12T03:38:38Z",
      "updatedAt": "2024-09-25T19:24:38Z",
      "closedAt": "2024-09-25T19:24:38Z",
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@johngray-dev : duplicate of #24 ?",
          "createdAt": "2024-07-19T08:04:47Z",
          "updatedAt": "2024-07-19T08:04:47Z"
        },
        {
          "author": "opencrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Shall this be handled with the IANA registry for the combinations?",
          "createdAt": "2024-07-21T14:42:12Z",
          "updatedAt": "2024-07-21T14:42:12Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing issue as it was resolved in Pull #51 ",
          "createdAt": "2024-09-25T19:24:38Z",
          "updatedAt": "2024-09-25T19:24:38Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOL5eEDM6PbIxz",
      "title": "Make RSA 4096 combos",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/24",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "We have been asked to add RSA-4096 combos for existing infrastructures where deployed software or policy requires 4096 bit keys.\r\n\r\nSuggestion is that since RSA 4096 is not much above 128 bit security (certainly not as much as AES-192 or SHA-384), we should pair it with the same cipher suites as the RSA-3072 combo. Or maybe even replace the 3072 combo?",
      "createdAt": "2024-07-12T20:01:36Z",
      "updatedAt": "2024-09-25T19:23:37Z",
      "closedAt": "2024-09-25T19:23:37Z",
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@ounsworth I would rather add combinations, and yes, the same as with RSA 3072.\r\n1. RSA 4096 is expensive when I think of our smart card products\r\n2. RSA 3072 is expected to be secure enough *at least* till 2030 by BSI\r\n3. not even RSA 1024 is cracked till now (80 bits security) so I expect it to last 10 more years... without CRQC of course",
          "createdAt": "2024-07-15T07:49:30Z",
          "updatedAt": "2024-07-15T07:49:30Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "**Should we drop the key size from the OID at all?**\r\n\r\nYes: Piotr, Scott\r\nNo: Tim, Sophie, Mike",
          "createdAt": "2024-07-29T14:39:02Z",
          "updatedAt": "2024-07-29T14:39:02Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided to add two new RSA 4096 combinations... one for PKCS 1.5, and PSS...  ",
          "createdAt": "2024-07-31T14:18:00Z",
          "updatedAt": "2024-07-31T14:18:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to add these combinations:  \r\n\r\nMLDSA65-RSA4096-PKCS15-SHA512\r\nMLDSA65-RSA4096-PSS-SHA512\r\n\r\nWe decided to keep the RSA keysize in the OID definiton",
          "createdAt": "2024-09-25T15:14:16Z",
          "updatedAt": "2024-09-25T15:14:16Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "closes #23 ",
          "createdAt": "2024-09-25T15:18:58Z",
          "updatedAt": "2024-09-25T15:18:58Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Didn't mean to close",
          "createdAt": "2024-09-25T15:20:00Z",
          "updatedAt": "2024-09-25T15:20:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "4096 combinations added in pull #51  - Closing this ticket",
          "createdAt": "2024-09-25T19:23:37Z",
          "updatedAt": "2024-09-25T19:23:37Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOL5eEDM6PxLUB",
      "title": "Add back text to not reuse component keys",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/25",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For the security proofs, it is imperative that the RSA / ECC keys be generated fresh for the composite and not re-used from existing deployments. I swear we had text to this effect. Certainly this deserves its own Security Consideration section.",
      "createdAt": "2024-07-16T20:58:03Z",
      "updatedAt": "2024-10-21T00:53:30Z",
      "closedAt": "2024-10-21T00:53:30Z",
      "comments": [
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "In draft-ietf-lamps-pq-composite-sigs-02, you have the following text:\r\n\r\nSection 4.1:\r\n   Compliant parties MUST NOT use or import component keys that are used\r\n   in other contexts, combinations, or by themselves (i.e., not only in\r\n   X.509 certificates).\r\n\r\nSection 5.2:\r\n   Component keys of a CompositeSignaturePublicKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\r\n\r\nSection 5.3:\r\n   Component keys of a CompositeSignaturePrivateKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\r\n\r\nI agree this should be more prominent, and in the Security Considerations section, with reference to the proofs.\r\n\r\nDo you have a reference to the security proofs which make this imperative, which you could link here (for my own curiousity)?  Is this just related to Weak Non-Separability where if you reuse the component signature keys then you open yourself up to downgrade/stripping attacks, and if you don't reuse them then you cut off those attacks?  Or is the reuse forbidden for a more fundamental security reason, even if you use WNS artifacts in your composite scheme?",
          "createdAt": "2024-07-17T10:12:25Z",
          "updatedAt": "2024-07-17T10:12:25Z"
        },
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "Ah I see that I am reading my emails out of order and this PR came from here: https://mailarchive.ietf.org/arch/msg/spasm/Ab7_g1Q3mVMCZH_GXiDLb-7dxVw/\r\n\r\nHowever, that thread is about composite KEM so I wonder if the same security concerns about simultaneous creation/combined usage also apply to composite signatures?",
          "createdAt": "2024-07-17T10:33:10Z",
          "updatedAt": "2024-07-17T10:33:10Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We didn't have text that was removed.  It was added in those 3 places to emphasize that keys are not to be used in other contexts.  This came as a result of conversations on the mailing list, but there were no formal proofs..  It is easy to conceive that allowing the same keys to be used outside a composite key independently would allow the generation of a composite signature indistinguishable from one generated by a composite key itself.  I suppose it shouldn't be hard to write a paragraph about that in the security considerations section.\r\n\r\n",
          "createdAt": "2024-07-17T13:59:56Z",
          "updatedAt": "2024-07-17T13:59:56Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We added a very detailed section on Key re-use in the security considerations section.   I will add a reference to this section in the 3 sections about that mention key re-use.   \r\n\r\n   \"For more details on the security considerations around key reuse, see section {sec-cons-key-reuse}\"",
          "createdAt": "2024-10-21T00:43:58Z",
          "updatedAt": "2024-10-21T00:43:58Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Added references to the security considerations key reuse section in pull #72 ",
          "createdAt": "2024-10-21T00:53:30Z",
          "updatedAt": "2024-10-21T00:53:30Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOL5eEDM6QccME",
      "title": "NIST is suggesting that both PQ L3 + L5 should be paired with P-384",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/26",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "https://datatracker.ietf.org/meeting/120/materials/slides-120-openpgp-pqc-with-nist-and-brainpool-curves-00.pdf",
      "createdAt": "2024-07-22T17:19:47Z",
      "updatedAt": "2024-10-02T15:29:31Z",
      "closedAt": "2024-10-02T15:29:31Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The ML-DSA + ECC pairings to use are this:\r\n\r\n```\r\nML-DSA-44+NIST-P-256 \r\nML-DSA-65+NIST-P-384 \r\nML-DSA-65+brainpoolP256r1 \r\nML-DSA-87+NIST-P-384 \r\nML-DSA-87+brainpoolP384r1\r\n```",
          "createdAt": "2024-09-17T16:00:29Z",
          "updatedAt": "2024-09-17T16:00:29Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Removing ML-DSA-44+brainpoolP256r1 leaves OID gap\u2026 close it?",
          "createdAt": "2024-09-25T11:49:14Z",
          "updatedAt": "2024-09-25T11:49:31Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The OID Gap doesn't matter, they are still prototype OIDs at this point.",
          "createdAt": "2024-09-25T15:16:48Z",
          "updatedAt": "2024-09-25T15:16:48Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We will define two new RSA 4096 combinations as well",
          "createdAt": "2024-09-25T15:17:11Z",
          "updatedAt": "2024-09-25T15:17:11Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@johngray-dev , do we still need edwards curves?",
          "createdAt": "2024-09-26T07:24:34Z",
          "updatedAt": "2024-09-26T07:24:34Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOL5eEDM6Q3fwk",
      "title": "We should be clear about which non-separability level we acheive",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/27",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a reference to draft-ietf-pquip-hybrid-signature-spectrums, and be clear (possibly with a full security consideration section) about which level this is achieving.",
      "createdAt": "2024-07-25T16:17:18Z",
      "updatedAt": "2024-10-21T01:30:17Z",
      "closedAt": "2024-10-21T01:30:17Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Potential text:\r\n\r\n>Inclusion of a composite signature algorithm OID inside a signed message achieved \u201cWeak Non-Separability\u201d, but that when you consider that within PKI, the verifier has the verification public key within a certificate, and that re-use of public keys between composite and non-composite certificates is forbidden, then all together this achieves \u201cStrong Non-Separability\u201d. We are in discussions with Dr. Hale about whether \u201cSimultaneous Verification\u201d can be achieved in this draft; the complexity is that most SV techniques require merging the two algorithms in such a way that you can\u2019t use, for example ECDSA from your existing codebase and ML-DSA from OpenQuantumSafe, but instead you have to write new code for the merged composite algorithm. This would also invalidate any existing FIPS / CC certifications of the existing traditional algorithm code, and being able to leverage existing certified code in the transition is a primary goal of composite.",
          "createdAt": "2024-07-25T16:24:57Z",
          "updatedAt": "2024-07-25T16:29:29Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Extensive text in the Security considerations section was added regarding non separability.  This issue is resolved.",
          "createdAt": "2024-10-21T01:30:17Z",
          "updatedAt": "2024-10-21T01:30:17Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOL5eEDM6S31IC",
      "title": "Update draft to support Official ML-DSA standard",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/28",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new FIPS 204 standard for ML-DSA was released.   We need to update the draft pointing to this draft:\r\nhttps://csrc.nist.gov/pubs/fips/204/ipd\r\n",
      "createdAt": "2024-08-13T19:53:01Z",
      "updatedAt": "2024-10-17T19:17:52Z",
      "closedAt": "2024-10-17T19:17:52Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Added in Pull #59 ",
          "createdAt": "2024-10-17T19:17:52Z",
          "updatedAt": "2024-10-17T19:17:52Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOL5eEDM6S_K_3",
      "title": "List security strength of each composite",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/29",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the LAMPS mail list:\r\n\r\nHi Piotr,\r\n\r\n> \u201cIn addition, it might be appropriate to add a column, for example, in Table 6 (or even better, in a new table in Section 11.1) indicating the \"overall\" Security strength, which would take into account the weakest element.\u201d\r\n\r\nWhile I agree that this will be useful to a reader, I think that coming up with a single \u201coverall security strength\u201d for a composite will be difficult. For example, are you considering before or after your adversary has a CRQC? Perhaps the best we could do is to have two columns for \u201cClassical security\u201d and \u201cPQ Security\u201d and list different numbers in each column. Is this worth doing? \r\n",
      "createdAt": "2024-08-14T14:34:54Z",
      "updatedAt": "2024-10-17T19:17:07Z",
      "closedAt": "2024-10-17T19:17:07Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "It is hard to quantify the overall strength at any given point it time, because it changes based on cryptanalysis.  Therefore, we don't think this table would add value.  We have added a strong security considerations section that talks about the strength of the algorithms in terms of their underlying notions.  ",
          "createdAt": "2024-10-17T19:17:07Z",
          "updatedAt": "2024-10-17T19:17:07Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOL5eEDM6S_uSS",
      "title": "Simplify HW implementation",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/30",
      "state": "CLOSED",
      "author": "mojtaba-bisheh",
      "authorAssociation": "NONE",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "Currently, the IETF defines \u201cid-MLDSA87-ECDSA-P384-SHA512,\u201d which restricts the input message to SHA-512 for the hybrid signature of MLDSA and NISTP384. However, including the SHA-384 option would reduce hardware complexities and align with both ECC and PQC standards.\r\n\r\nThe inclusion of \u201cid-MLDSA87-ECDSA-P384-SHA384\u201d would be compatible with existing standards and provide greater flexibility for implementations. FIPS 186-5 permits the use of both SHA-384 and SHA-512 for ECDSA P384. Additionally, FIPS 204 does not limit pre-hashed mode to SHA-512, stating: \"Algorithm 4 shows the DER encodings of the OIDs for SHA-256, SHA-512, and SHAKE128. However, it may be used with other hash functions or XOFs.\"\r\n\r\nFor example, one of the use cases of SHA384 in hardware implementation is [Caliptra](https://github.com/chipsalliance/caliptra-rtl), that exclusively uses SHA-384 for ECDSA P384. \r\n\r\nThe inclusion of \u201cid-MLDSA87-ECDSA-P384-SHA384\u201d would align with existing standards, provide more flexibility for implementations, and help enhance compatibility and facilitate broader deployment of PQC.",
      "createdAt": "2024-08-14T15:27:10Z",
      "updatedAt": "2024-10-21T19:43:28Z",
      "closedAt": "2024-10-21T19:43:28Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current version of the composite signature generation algorithm starts with\r\n\r\n```\r\n1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(Message)\r\n\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := Sign( K1, A1, M' )\r\n         S2 := Sign( K2, A2, M' )\r\n```\r\n\r\nSo there is a common pre-hash that applies to both halves of the composite. Therefore the pre-hash needs to match the security level of the strongest of the components. ML-DSA-87 is a NIST Level 5 algorithm, [which NIST defines as](https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria)):\r\n\r\n> comparable to a key search on a block cipher with a 256-bit key (e.g. AES 256)\r\n\r\nwhich requires SHA-512. Switching to SHA-384 would reduce this combination to a Level 4.",
          "createdAt": "2024-08-28T14:19:19Z",
          "updatedAt": "2024-08-28T14:19:59Z"
        },
        {
          "author": "mojtaba-bisheh",
          "authorAssociation": "NONE",
          "body": ">>Switching to SHA-384 would reduce this combination to a Level 4.\r\n\r\nI understand your point, however, SHA-384 can meet the requirements of applications that use id-MLDSA87-ECDSA-P384-SHA***.",
          "createdAt": "2024-08-28T16:53:13Z",
          "updatedAt": "2024-08-28T16:53:29Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We now have pure and pre-hash modes:\r\n\r\nSolution is to use only pure ML-DSA in Composites and do either a PreHash or not when generating M'.\r\n\r\npure M' := Domain || IntegerToBytes(|ctx|, 1) || ctx || Message\r\npreHash M' := Domain || IntegerToBytes(|ctx|, 1) || ctx || HashOID || HASH(Message)\r\n\r\nBoth ECC and ML-DSA get the same M'. The ECC algorithm will do another Hash again.\r\n\r\nSo we will change the Traditional hash algorithm to better match the traditional algorithm.  For example:\r\n\r\nEC 256 (NIST curves) matches with SHA256 (Same as today, so these won't change)\r\n\r\nPure Composite-ML-DSA Signature public key types:\r\n\r\n| Composite Signature AlgorithmID | OID | First AlgorithmID | Second AlgorithmID |\r\n| ----------- | ----------- | ----------- |  ----------- |\r\n| id-MLDSA44-RSA2048-PSS      | &lt;CompSig&gt;.21 | id-ML-DSA-44  | id-RSASA-PSS with id-sha256 |\r\n| id-MLDSA44-RSA2048-PKCS15    | &lt;CompSig&gt;.22 | id-ML-DSA-44  | sha256WithRSAEncryption |\r\n| id-MLDSA44-Ed25519                  | &lt;CompSig&gt;.23 | id-ML-DSA-44  | id-Ed25519 |\r\n| id-MLDSA44-ECDSA-P256        | &lt;CompSig&gt;.24 | id-ML-DSA-44  | ecdsa-with-SHA256 with secp256r1 |\r\n| id-MLDSA65-RSA3072-PSS          | &lt;CompSig&gt;.26 | id-ML-DSA-65 | id-RSASA-PSS with id-sha256 |\r\n| id-MLDSA65-RSA3072-PKCS15       | &lt;CompSig&gt;.27  | id-ML-DSA-65 | sha256WithRSAEncryption |\r\n| id-MLDSA65-RSA4096-PSS         | &lt;CompSig&gt;.34 | id-ML-DSA-65 | id-RSASA-PSS with id-sha384 |\r\n| id-MLDSA65-RSA4096-PKCS15        | &lt;CompSig&gt;.35  | id-ML-DSA-65 | sha384WithRSAEncryption |\r\n| id-MLDSA65-ECDSA-P384           | &lt;CompSig&gt;.28  | id-ML-DSA-65 | ecdsa-with-SHA384 with secp384r1 |\r\n| id-MLDSA65-ECDSA-brainpoolP256r1 | &lt;CompSig&gt;.29  | id-ML-DSA-65 | ecdsa-with-SHA256 with brainpoolP256r1 |\r\n| id-MLDSA65-Ed25519                      | &lt;CompSig&gt;.30  | id-ML-DSA-65 | id-Ed25519 |\r\n| id-MLDSA87-ECDSA-P384            | &lt;CompSig&gt;.31  | id-ML-DSA-87 | ecdsa-with-SHA384 with secp384r1 |\r\n| id-MLDSA87-ECDSA-brainpoolP384r1 | &lt;CompSig&gt;.32 | id-ML-DSA-87 | ecdsa-with-SHA384 with brainpoolP384r1 |\r\n| id-MLDSA87-Ed448                        | &lt;CompSig&gt;.33 | id-ML-DSA-87 | id-Ed448 |\r\n{: #tab-sig-algs title=\"Pure ML-DSA Composite Signature Algorithms\"}\r\n\r\nThe names of the Hash ones will remain the same, but the underlying hasher to use with RSA or EC is the same, the pre-hash is what is different, hence the extra table column:\r\n\r\nHashComposite-ML-DSA Signature public key types:\r\n\r\n| Composite Signature AlgorithmID | OID | First AlgorithmID | Second AlgorithmID | Pre-Hash |\r\n| ----------- | ----------- | ----------- |  ----------- | ----------- |\r\n| id-HashMLDSA44-RSA2048-PSS-SHA256      | &lt;CompSig&gt;.40 | id-ML-DSA-44  | id-RSASA-PSS with id-sha256 | id-sha256 |\r\n| id-HashMLDSA44-RSA2048-PKCS15-SHA256    | &lt;CompSig&gt;.41 | id-ML-DSA-44  | sha256WithRSAEncryption | id-sha256 |\r\n| id-HashMLDSA44-Ed25519-SHA512             | &lt;CompSig&gt;.42 | id-ML-DSA-44  | id-Ed25519 | id-sha512 |\r\n| id-HashMLDSA44-ECDSA-P256-SHA256         | &lt;CompSig&gt;.43 | id-ML-DSA-44  | ecdsa-with-SHA256 with secp256r1 | id-sha256 |\r\n| id-HashMLDSA65-RSA3072-PSS-SHA512           | &lt;CompSig&gt;.44 | id-ML-DSA-65 | id-RSASA-PSS with id-sha256 | id-sha512 |\r\n| id-HashMLDSA65-RSA3072-PKCS15-SHA512        | &lt;CompSig&gt;.45  | id-ML-DSA-65 | sha256WithRSAEncryption | id-sha512 |\r\n| id-HashMLDSA65-RSA4096-PSS-SHA512           | &lt;CompSig&gt;.46 | id-ML-DSA-65 | id-RSASA-PSS with id-sha384 | id-sha512 |\r\n| id-HashMLDSA65-RSA4096-PKCS15-SHA512        | &lt;CompSig&gt;.47  | id-ML-DSA-65 | sha384WithRSAEncryption | id-sha512 |\r\n| id-HashMLDSA65-ECDSA-P384-SHA512            | &lt;CompSig&gt;.48  | id-ML-DSA-65 | ecdsa-with-SHA384 with secp384r1 | id-sha512 |\r\n| id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 | &lt;CompSig&gt;.49  | id-ML-DSA-65 | ecdsa-with-SHA256 with brainpoolP256r1 | id-sha512 |\r\n| id-HashMLDSA65-Ed25519-SHA512              | &lt;CompSig&gt;.50  | id-ML-DSA-65 | id-Ed25519 | id-sha512 |\r\n| id-HashMLDSA87-ECDSA-P384-SHA512            | &lt;CompSig&gt;.51  | id-ML-DSA-87 | ecdsa-with-SHA384 with secp384r1 | id-sha512|\r\n| id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 | &lt;CompSig&gt;.52 | id-ML-DSA-87 | ecdsa-with-SHA384 with brainpoolP384r1 | id-sha512 |\r\n| id-HashMLDSA87-Ed448-SHA512              | &lt;CompSig&gt;.53 | id-ML-DSA-87 | id-Ed448 | id-sha512 |\r\n{: #tab-hash-sig-algs title=\"Hash ML-DSA Composite Signature Algorithms\"}\r\n\r\nSo this should resolve the issue.   Thanks for the comment!\r\n\r\n",
          "createdAt": "2024-10-21T03:11:32Z",
          "updatedAt": "2024-10-21T03:11:59Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed in #72 ",
          "createdAt": "2024-10-21T13:08:26Z",
          "updatedAt": "2024-10-21T13:08:26Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOL5eEDM6TA-t0",
      "title": "List overall strength estimates for each composite",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/31",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See: https://mailarchive.ietf.org/arch/msg/spasm/s0wPyhHpaxKsSKMwLBypagm4iL0/",
      "createdAt": "2024-08-14T18:10:26Z",
      "updatedAt": "2024-08-29T19:34:32Z",
      "closedAt": "2024-08-29T19:34:32Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #29 ",
          "createdAt": "2024-08-29T19:34:32Z",
          "updatedAt": "2024-08-29T19:34:32Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOL5eEDM6TQ4ks",
      "title": "Digicert feedback",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/32",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ounsworth"
      ],
      "labels": [],
      "body": "\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/ReWx7kichMke-HuTHjCih3iZpD0/\r\n\r\nDigiCert's CA engineering team has some comments on the open issues related\r\nto the composite-sigs draft. We're going to put them in one email just\r\nbecause we have comments on quite a few of them.\r\n\r\nISSUE #1\r\n(Github issue:  https://github.com/lamps-wg/draft-composite-sigs/issues/9)\r\n\r\nASN.1 wrapping confuses people. This came up in the hash-based signatures\r\nupdates last call. Nobody knows what ASN.1 is, or what the consequences\r\nof omiting it are (to be clear, there are really none).\r\n\r\nWe agree that this is largely a question of people being unfamiliar with\r\nASN.1, and that explanatory text is sufficient. All that is needed is a\r\nclear explanation of example what the BIT STRING is, and explaining that\r\nit's simply the bits of the key itself seems pretty straightforward.\r\n\r\nOne can then say something similar to: \r\n\r\n\"In some situations and protocols, the key might be wrapped in ASN.1 or \r\nmay have some other additional decoration or encoding. If so, such wrapping \r\nMUST be removed prior to encoding the key itself as a BIT STRING.\"\r\n\r\nHopefully that makes things crystal clear.\r\n\r\nISSUE #2\r\n(Github Issue: https://github.com/lamps-wg/draft-composite-sigs/issues/19)\r\n\r\nWe don't think it's worth the extra complexity and expense of an additional\r\nhash operation just to achieve a fixed size output. The variation in size\r\nis already pretty small.\r\n\r\nISSUE #3\r\n(Github issue: https://github.com/lamps-wg/draft-composite-sigs/issues/6)\r\n\r\nAgain, we don't believe the additional complexity is worth it for a pretty\r\ntrivial improvement in the private key size. But it's not a strong opinion,\r\nwe could go either way.\r\n\r\nOpen Issues affect both Composite Signatures and Composite KEM:\r\nISSUE #4\r\n\r\nChair hat off, I and the CA team are concerned about the slow progress of \r\nthe composite signature work. In particular, tying it to the Composite KEM\r\ndraft and waiting for the CFRG work on KEM Combiners seems like an\r\nabsolutely horrible idea to us. We would like to see Composite Signatures\r\nprogress ASAP.\r\n\r\nISSUE #5\r\n(Github issues:\r\nhttps://github.com/lamps-wg/draft-composite-kem/issues/37\r\nhttps://github.com/lamps-wg/draft-composite-sigs/issues/24\r\nhttps://github.com/lamps-wg/draft-composite-sigs/issues/23)\r\n\r\nThis is a fun one, and we've spent quite a bit of time discussing it\r\ninternally.\r\n\r\nIn particular, we're still debating the question about exactly how many\r\nbackwards compatibility options are really necessary. For example, given\r\nthat you already need to add lattice, is it really necessary to allow\r\nPKCS15 to continue to exist? For RSA, there's the reasonable argument that\r\nthat might be all you have in your validated hardware/software, but if you\r\nhave RSA as a primitive, can't you do PSS instead of PKCS15? Remember, you\r\nalready have to make changes on both the signing and verify side anyway.\r\n\r\nWe're trending in the direction of thinking that the primary decision is\r\nthe security level and post-quantum algorithm, and the classical side is\r\njust determined by what \"makes sense\" for that security level and algorithm.\r\n\r\nSo what you really want is something like \"id-SL1-MLKEM-RSA\" where the\r\ndocument specifies exactly what \"RSA\" means in the context of a SL1 MLKEM512\r\ncomposite, e.g. RSA4096-PSS-SHA512. This basically means striving for\r\nat most one combination for each triple of (security level, PQC flavor, classical \r\nflavor) and eliminating unnecessary complexity and diversity of options in what \r\nis essentially a redundancy/backup mechanism.\r\n\r\nThe basic idea is to more aggressively standardize the backwards \r\ncompatibility options to only what's actually necessary, instead of\r\ntrying to be backwards compatible with the universe of current behavior,\r\nwhich both unnecessarily complicates things, and preserves some practices\r\n(e.g. PKCS15) longer than is perhaps prudent.\r\n\r\n-Tim\r\n",
      "createdAt": "2024-08-16T17:29:47Z",
      "updatedAt": "2024-10-17T23:54:07Z",
      "closedAt": "2024-10-17T23:54:07Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOL5eEDM6T5Pjf",
      "title": "Burt's feedback: context string in domain separator?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/33",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/vzomXUHvJOouzIcC82WkMF4DP-g/\r\n\r\n> Should the domain separator also include an optional context string, similar to the domain separator NIST has defined for the recently published FIPS 204/205 [1]?  The context string would provide a way to \u201cseparate uses of the protocol between different protocols \u2026 and between different uses within the same protocol\u201d (Sec. 8.3 of [2]).  \r\n\r\n> Similarly, if an underlying signature algorithm supports a context string, what value should be given to the context string when the algorithm is used with the composite construction?  If the composite construction is updated to include an optional context string in the domain separator, should the context strings for the underlying algorithm and for the overall construction be the same?  Or should the context string for the underlying algorithm instead somehow indicate the \u201cuse\u201d of the underlying algorithm is \u201cfor signing a composite signature hash value\u201d?\r\n\r\n[2] S. Josefsson, I. Liusvaara.  Edwards-Curve Digital Signature Algorithm (EdDSA).  RFC 8032, January 2017",
      "createdAt": "2024-08-22T16:29:29Z",
      "updatedAt": "2024-10-17T19:13:15Z",
      "closedAt": "2024-10-17T19:13:15Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good suggestion. I support having the composite .Sign() accept a context string, and passing it through to underlying component primitives that support a context string (ie ML-DSA).",
          "createdAt": "2024-08-22T16:31:55Z",
          "updatedAt": "2024-08-22T16:31:55Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #42\r\n",
          "createdAt": "2024-09-26T12:03:17Z",
          "updatedAt": "2024-09-26T12:03:28Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We supported added the context String... Closed #42 already, \r\nthis was part of pull #59 ",
          "createdAt": "2024-10-17T19:13:15Z",
          "updatedAt": "2024-10-17T19:13:15Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOL5eEDM6T5RGI",
      "title": "Burt's feedback: should we define pre-hashed modes for composite?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/34",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/vzomXUHvJOouzIcC82WkMF4DP-g/\r\n\r\n> Should the domain separator include an initial byte that identifies the type of domain separator, again similar to NIST\u2019s definition?  For instance, the value 1 could indicate that the message is pre-hashed as currently proposed in draft-ietf-lamps-pq-composite-sigs.  A different value could support another option:  the message is not pre-hashed, but instead is prepended with a domain separator, and then passed to the two signature algorithms.  That option would avoid the need for an additional hashing operation to be specified.  (The domain separator could still include an OID for the combination of the two signature algorithms in order to separate different combinations of algorithms.)\r\n\r\n> If an underlying signature algorithm supports pure and pre-hash modes, which mode should be used with the composite signature construction?  Presumably pure mode when the composite construction includes pre-hashing, because the message will already have been hashed by the time it reaches the underlying signature algorithm, but this should be stated explicitly.\r\n\r\n> In addition to pre-hashing as currently proposed, should there be an option for including a randomizer and/or the signers\u2019 public keys in the input to the pre-hash operation, in addition to the message?  As Joe Harvey observed in comments to NIST earlier this year [3], without such an option, pre-hashing introduces a dependency on collision resistance, whereas the security of the underlying signature algorithm may be based on other security assumptions (e.g., target collision resistance, second preimage resistance).   Moreover, a collision, if found, could potentially be used against multiple users, whereas the underlying signature algorithm may have been designed to provide security in the multi-user model.  (This is not an argument for reducing the size of the hash function output by using randomization, but rather for considering that the use of pre-hashing may change the security assumptions compared to the underlying algorithm, and providing the protocol designer a way to revert to the original assumptions.)\r\n",
      "createdAt": "2024-08-22T16:32:57Z",
      "updatedAt": "2024-10-17T19:12:14Z",
      "closedAt": "2024-10-17T19:12:14Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair point, currently the composite draft presents a pure-sign mode, and uses ML-DSA in its pure-sign mode. But with NIST deciding to support both pure and pre-hash modes of ML-DSA, we should probably do that same for composite-ML-DSA.\r\n\r\nThis represents a fairly large amount of design work since all the points raised by Burt, plus probably more, are in-scope.",
          "createdAt": "2024-08-22T16:37:51Z",
          "updatedAt": "2024-08-22T16:37:51Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the point about prefix byte does not apply: since we are already hashing in the OID, and we would presumably define different OIDs for pure and pre-hashed modes, I think that anything you would want to capture in the prefix byte is already captured in the OID.",
          "createdAt": "2024-08-22T16:40:25Z",
          "updatedAt": "2024-08-22T16:40:25Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As to the title question:\r\n\r\n> should we define pre-hashed modes for composite?\r\n\r\nMy vote is No.",
          "createdAt": "2024-09-27T14:09:50Z",
          "updatedAt": "2024-09-27T14:09:50Z"
        },
        {
          "author": "PiotrPopis",
          "authorAssociation": "NONE",
          "body": "Initially I was in favor of defining pre-hash in [composite-sign] but now I also agree with Mike that we should not define pre-hash mode in composite sign. This would only increase the number of possibilities, which is not in line with the idea of \u200b\u200binteroperability and increases the implementation effort.\r\n\r\nThe current version of [composite-sign] uses the term \"pre-hash\" in several places, which is confusing in the context of FIPS 204. I therefore suggest that in [composite-sign] the wording \"internal-layer hash\" be used instead of \"pre-hash\". @ounsworth: if there is agreement to change the wording, I will prepare a specific proposal.\r\n\r\nRegardless of the decision to change or keep the \"pre-hash\" language, I suggest adding the following text at the end of Section 3.1:\r\n(precisely: very similar wording, taking into account the location of ctx, i.e. consistent with the entire content of the new Section 3.1)\r\n(...)\r\nIt should be noted that in the case of ML-DSA the calculated Hash over the original message is an \"internal-layer Hash\" and is different from the HASHML-DSA version specified in FIPS 204. This means that according to this specification the signature over the concatenated: selected signature scheme and calculated Hash over the original message is implemented in the case of the PQ algorithm using the PURE version of ML-DSA.\r\n\r\n",
          "createdAt": "2024-09-30T12:30:09Z",
          "updatedAt": "2024-09-30T12:30:09Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Mike and I and the Composite authors group are having further discussions.   I think we are going to land on making use of both pure and pre-hash versions of composite, using a construction that is essentially aligned with what NIST has done.  Instead of using 0 or 1, we use the DER Encoding of the Composite Signature OID and call it \"Domain\"\r\n \r\nCompositeML-DSA:\r\n \r\nM' := Domain || IntegerToBytes(|ctx|, 1) || ctx || Message\r\nwhere \u201cDomain\u201d are the DER(OID) values from our table.\r\n \r\n \r\nHashCompositeML-DSA:\r\n \r\nM' := Domain || IntegerToBytes(|ctx|, 1) || ctx || HashOID || PH\r\nwhere \u201cDomain\u201d are the DER(OID) values from our table.\r\nwhere H is not specified in our table, but instead can be SHA-256, SHA-512, SHAKE128 or others in the future.\r\n \r\nFIPS 204 suggests the specified HASH algorithm should be carried in the OID.  Of course we could choose to use an Algorithm parameter for efficiency here or we get major OID explosion.  I think we will just end up choose 1 appropriate HASH for the pre-hash version (similar to what is in the -02 version of the draft).\r\n",
          "createdAt": "2024-10-02T04:46:20Z",
          "updatedAt": "2024-10-02T04:46:20Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We added pre-hash and pure modes.   Merged in pull #59 ",
          "createdAt": "2024-10-17T19:12:14Z",
          "updatedAt": "2024-10-17T19:12:14Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOL5eEDM6Ujg1T",
      "title": "Should we have a nonempty ML-DSA context string?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/35",
      "state": "CLOSED",
      "author": "sfluhrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ML-DSA has a 'context string' as an input; the idea is to allow the capability to bind a signature to a specific context.\r\n\r\nShould we specify that, when we implement ML-DSA within a composite signature, that we have a nonempty context?\r\n\r\nIf the verifier will never accept a signature signed by a specific ML-DSA key except as part of a composite signature, we don't gain anything.  However, it might be a helpful 'belt-and-suspenders' if some application would happen to reuse the ML-DSA public key.\r\n\r\nIf we do have a nonempty context string, what should it be:\r\n- Should it be the OID for the composite (so that the signature can be used only as a part of that specific combination)\r\n- Should it be the hash of the composite public key (so that we're safe even if some fool changes the other components)\r\n\r\nThoughts?",
      "createdAt": "2024-08-28T14:51:26Z",
      "updatedAt": "2024-10-17T19:11:38Z",
      "closedAt": "2024-10-17T19:11:37Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion between John, Felipe, and myself. \r\nDecision is to change one sentence is the draft:\r\n\r\nOLD:\r\n```\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := Sign( K1, A1, M' )\r\n         S2 := Sign( K2, A2, M' )\r\n```\r\n\r\nNEW:\r\n```\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx=\"\" )\r\n         S2 := TradSign( K2, A2, M' )\r\n\r\nSince Composite ML-DSA incorporates the domain separator into a pre-hash, which serves theh same purpose as the ML-DSA context string, the ML-DSA context string is left empty.\r\n```",
          "createdAt": "2024-08-29T20:23:31Z",
          "updatedAt": "2024-08-29T20:23:31Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> If we do have a nonempty context string, what should it be:\r\n> \r\n>     * Should it be the OID for the composite (so that the signature can be used only as a part of that specific combination)\r\n> \r\n>     * Should it be the hash of the composite public key (so that we're safe even if some fool changes the other components)\r\n\r\nI am in favor of using the context parameter to enhance the security of the protocol. This means we should fix the signature algorithm (as Scott suggests above), thus also preventing signature stripping attacks that leave the signature of a component algorithms that has the context parameter. I am also in favor of using the context parameter to signal whether a CMS signature was generated with or without SignedAttributes. Currently, the ambiguity with respect to the presence of the SignedAttributes leads to a trivial signature forgery (https://eprint.iacr.org/2023/1801.pdf \u2013 sorry if it seems that I am promoting my work here; that is not the case; I wrote this only to have a reference for something that is probably known to some but everyone). This will improve the security of CMS in course of the PQC transition.\r\n\r\nClearly this measure should not only be restricted to composite signatures, but should be specified for all CMS signatures.\r\n\r\nI also suggest to use approach with for EdDSA in the new composites, and possibly even to add new versions of standalone EdDSA which make use of this feature.",
          "createdAt": "2024-09-19T09:57:08Z",
          "updatedAt": "2024-09-19T09:57:08Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> Since Composite ML-DSA incorporates the domain separator into a pre-hash, which serves theh same purpose as the ML-DSA context string, the ML-DSA context string is left empty.\r\n\r\nI don't agree to that: The way the domain separator is specified, it doesn't prevent signature stripping attacks, but it transforms a signature stripping attack for the message M to one for the message M'. This clearly implies an existential signature forgery, a fundamental weakening of the protocol. If using the context parameter (additionally or as a replacement for the current combiner) we achieve a profound\u207a means of preventing signature stripping attacks at least for those signature schemes that do offer a context parameter \u2013 namely EdDSA and all the new PQC schemes.\r\n\r\n\u207a profound in the sense of not introducing existential signature forgeries",
          "createdAt": "2024-09-19T10:03:51Z",
          "updatedAt": "2024-09-19T10:03:51Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "We discussed this in https://github.com/lamps-wg/draft-composite-sigs/issues/42#issuecomment-2374284632\r\nWe will pass the context down to ML-DSA.",
          "createdAt": "2024-09-26T12:08:54Z",
          "updatedAt": "2024-09-26T12:08:54Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #42\r\n",
          "createdAt": "2024-09-26T12:09:21Z",
          "updatedAt": "2024-09-26T12:10:03Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We ended up adding both Pure and Hash versions with the context string, so this will also resolve #45\r\n\r\nresolves #45 ",
          "createdAt": "2024-10-16T13:04:24Z",
          "updatedAt": "2024-10-16T13:04:24Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to use the context String, and this was Merged in Pull #59 ",
          "createdAt": "2024-10-17T19:11:37Z",
          "updatedAt": "2024-10-17T19:11:37Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOL5eEDM6UvNow",
      "title": "Update to final FIPS 204",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/36",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-29T19:35:12Z",
      "updatedAt": "2024-09-08T19:30:44Z",
      "closedAt": "2024-09-08T19:30:44Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOL5eEDM6Uvw1y",
      "title": "Version Composite OIDs for use with standard ML-DSA version",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/37",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update the Composite Signature OIDS to the following:\r\n\r\n2.16.840.1.114027.80.8.1.21   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-RSA2048-PSS-SHA256    060B6086480186FA6B50080115\r\n2.16.840.1.114027.80.8.1.22   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-RSA2048-PKCS15-SHA256 060B6086480186FA6B50080116\r\n2.16.840.1.114027.80.8.1.23   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-Ed25519-SHA512        060B6086480186FA6B50080117 \r\n2.16.840.1.114027.80.8.1.24   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-ECDSA-P256-SHA256     060B6086480186FA6B50080118\r\n2.16.840.1.114027.80.8.1.25   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-ECDSA-brainpoolP256r1-SHA256 060B6086480186FA6B50080119\r\n2.16.840.1.114027.80.8.1.26   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-RSA3072-PSS-SHA512 060B6086480186FA6B5008011A\r\n2.16.840.1.114027.80.8.1.27   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-RSA3072-PKCS15-SHA512 060B6086480186FA6B5008011B\r\n2.16.840.1.114027.80.8.1.28   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-ECDSA-P256-SHA512 060B6086480186FA6B5008011C\r\n2.16.840.1.114027.80.8.1.29   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-ECDSA-brainpoolP256r1-SHA512 060B6086480186FA6B5008011D\r\n2.16.840.1.114027.80.8.1.30  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-Ed25519-SHA512 060B6086480186FA6B5008011E\r\n2.16.840.1.114027.80.8.1.31  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-ECDSA-P384-SHA512 060B6086480186FA6B5008011F\r\n2.16.840.1.114027.80.8.1.32  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-ECDSA-brainpoolP384r1-SHA512 060B6086480186FA6B50080120\r\n2.16.840.1.114027.80.8.1.33  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-Ed448-SHA512 060B6086480186FA6B50080121",
      "createdAt": "2024-08-29T20:48:06Z",
      "updatedAt": "2024-09-24T21:45:59Z",
      "closedAt": "2024-09-24T21:45:59Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOL5eEDM6U2FII",
      "title": "Clarifying Composite Signature Specifications for Consistent Implementation",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/39",
      "state": "CLOSED",
      "author": "mojtaba-bisheh",
      "authorAssociation": "NONE",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "I am seeking clarification on the input message for the composite signature specification to ensure consistent understanding and implementation. Given that ML-DSA operates in two modes\u2014pure and pre-hash\u2014and there are various prefixes/OIDs for the pre-hashed mode, this clarification is crucial. \r\nThere is also one more hashing operation within the ECC boundary that should not be mistaken for what the composite signature needs in `M' := Domain || HASH(Message)` step.\r\n\r\nThere are two options here:\r\n\r\nOne option is to move hybrid domain concatenation into HASH operation (similar to ML-DSA scheme),i.e., `M' := HASH(Domain || Message)`. In this case, there is one other HASH operation for both ECC and pre-hash ML-DSA:\r\nfor ECC: `HASH(M') = HASH(HASH(Hybrid_Domain || Message))`\r\nfor pure ML-DSA: = `HASH(tr || M') = H(tr || 0x00 || ctx_len || ctx || HASH(Hybrid_Domain || Message))`\r\nfor pre-hash ML-DSA: = `HASH(tr || M') = H(tr || 0x01 || ctx_len || ctx || OID || HASH(HASH(Hybrid_Domain || Message))`\r\nThis back-to-back hashing operation for ECC and pre-hash MLDSA makes no sense, so you can remove the hash operation and just append message with an OID that reduces the complexity of the computation too.\r\n\r\nSecond option is keeping the current condition as:\r\nfor ECC: `HASH(M') = HASH(Hybrid_Domain || HASH(Message))`\r\nfor pure ML-DSA: = `HASH(tr || M') = H(tr || 0x00 || ctx_len || ctx || Hybrid_Domain || HASH(Message))`\r\nfor pre-hash ML-DSA: = `HASH(tr || M') = H(tr || 0x01 || ctx_len || ctx || OID || HASH(Hybrid_Domain || HASH(Message))`\r\n\r\nFurthermore, Including test vectors and examples in the specification would promote uniform implementation across the industry.",
      "createdAt": "2024-08-30T13:11:46Z",
      "updatedAt": "2024-10-21T19:43:43Z",
      "closedAt": "2024-10-21T19:43:43Z",
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @mojtaba-bisheh ,\r\n\r\nThis seems similar to #34 and #45 .\r\nSolution is to use only pure ML-DSA in Composites and do either a PreHash or not when generating M'. \r\n\r\npure M' := Domain || IntegerToBytes(|ctx|, 1) || ctx || Message\r\npreHash M' := Domain || IntegerToBytes(|ctx|, 1) || ctx || HashOID || HASH(Message)\r\n\r\nBoth ECC and ML-DSA get the same M'. The ECC algorithm will do another Hash again.\r\n\r\nDoes this work for you or do you see any issues with that?",
          "createdAt": "2024-10-10T11:29:21Z",
          "updatedAt": "2024-10-10T11:29:48Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We believe we have resolved this issue and we now provide both pure and pre-hash versions as Jan points out above.  ",
          "createdAt": "2024-10-21T00:59:53Z",
          "updatedAt": "2024-10-21T00:59:53Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOL5eEDM6VuoU4",
      "title": "Adding an Applicability Statement to the draft",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/40",
      "state": "CLOSED",
      "author": "yoavnir",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When the composite sigs draft was adopted, the WG concluded that this was a useful technology, but only useful in certain places. I suggest adding an \"Applicability Statement\" to the draft, calling out those places where the technology is applicable.  \r\n\r\nAs I understand it, the biggest justification for composite signatures is that we don't entirely trust either the classic or the PQ algorithms, the classic because maybe the attacker has a CRQC, and the PQ algorithm because it's too new.  So people are hesitant to deploy pure PQ certificates, because if the PQ algorithm turns out to be broken, replacing all the certificates would take a long time and be very difficult or expensive.  This is more or less relevant to different use cases.\r\n\r\nI don't now have proposed text, but just off the top of my head:\r\n* The web - The web is moving to relatively short-term certificates. ACME is part of it. So if it's possible to replace all the web certificates in a few months, is it important to have >1 signatures in a certificate?  Perhaps this is something that we should consult with the CA/BF about.\r\n* Intranets - Corporate networks use certificates for a lot of internal communications. This includes internal web, email protocols, and all kinds of other proprietary protocols. But those are relatively well-controlled. There are people with the authority to decide to replace all the certificates with other single-algorithm certificates. So if an algorithm is broken, they could replace it relatively quickly.\r\n* VPNs or SD-WANs - This is similar to intranet, with the difference that these are often products that are sometimes in service for many years and may have issues with replacing hardware or updating software.\r\n* Internal and client communications between clusters of computers, such as distributed databases or distributed \"software-defined\" storage. Those sometimes have certificates that are quite long-term. On occasion such clusters grow by adding new nodes to existing clusters, resulting in a mix of old and new servers, and even old and new software.  \r\n* Infrastructure - That's a big one for composite signatures, because sometimes infrastructure devices (from smart meters to water or electric grid control) can be installed for decades. We all believe it should be possible to update them with new software and algorithms, but the reality is that a lot of them don't. ",
      "createdAt": "2024-09-07T19:14:21Z",
      "updatedAt": "2024-10-21T19:43:56Z",
      "closedAt": "2024-10-21T19:43:56Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are they suitable for the Web?  Are they suitable for intranets?  For VPNs and SD-WANs?  For storage area networks? For cluster communications such as distributed storage systems?  For infrastructure?\r\n\r\nI think yes to all of the above; composite-ML-DSA has exactly the same applicability as regular ML-DSA is. I believe (and Entrust recommends to our customers) that this is useful literally everywhere; that the hybrid is a small price to pay for some extra comfort with these new crypto algorithms. Let me flip the question around: perhaps it's easier to list the place that composites are not appropriate? The only one that comes to mind are highly bandwidth / CPU constrained use cases where your tolerance on ML-DSA is so tight that you can't even tolerate X25519 on top. \r\n\r\n\r\nThe draft already contains this text, which I think is fairly clear:\r\n\r\n> Cautious implementers may opt to combine cryptographic algorithms in such a way that an attacker would need to break all of them simultaneously to compromise the protected data. These mechanisms are referred to as Post-Quantum/Traditional (PQ/T) Hybrids [I-D.driscoll-pqt-hybrid-terminology].\r\n> Certain jurisdictions are already recommending or mandating that PQC lattice schemes be used exclusively within a PQ/T hybrid framework. The use of Composite scheme provides a straightforward implementation of hybrid solutions compatible with (and advocated by) some governments and cybersecurity agencies [BSI2021].\r\n\r\nBut I'll go ahead and add the following sentence to the draft.\r\n\r\n\"Composite ML-DSA is applicable in any application that would otherwise use ML-DSA, but wants the protection against breaks or catastrophic bugs in ML-DSA.\"\r\n",
          "createdAt": "2024-09-08T19:22:42Z",
          "updatedAt": "2024-09-08T19:23:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The authors agree with the blanked statement Mike is suggesting.  On September 11th we decided to mention this at IETF 121.\r\n",
          "createdAt": "2024-09-11T14:29:27Z",
          "updatedAt": "2024-09-11T14:29:27Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The text has been added into the Draft as suggested above.   @yoavnir  do you agree?",
          "createdAt": "2024-10-21T01:34:56Z",
          "updatedAt": "2024-10-21T01:34:56Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOL5eEDM6WNcSA",
      "title": "We should also expose a context string / domain separator as external input to the composite-sign",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/42",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion here:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/YFW4hVCZAQiVge2Z1kzAlIcM4U8/\r\n\r\nThe idea is that you may want to bind the actually application context, like \"MS Firmware Sign\" in addition to the composite sig OID. This \r\n\r\nIf we make this change, the composite sign would become:\r\n\r\n```\r\nM' := Domain || Ctx || HASH(Message)\r\n```\r\n\r\nor possibly\r\n\r\n```\r\nM' := Domain || HASH(Ctx || Message)\r\n```\r\n\r\nwhere `Ctx` is external input to the composite Sign(), and defaults to the empty string.\r\n\r\nMy concern with doing things outside the HASH is that this is the pre-hash for RSA / ECDSA, so a very long context string could overflow the RSA / ECDSA \"block\" -- therefore I think any kind of variable-length Ctx needs to be inside the hash.",
      "createdAt": "2024-09-11T15:44:12Z",
      "updatedAt": "2024-10-18T14:46:08Z",
      "closedAt": "2024-10-18T14:46:08Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the meeting today, we discussed two versions. I don't think we reached consensus about which was better.\r\n\r\nVersion 1:\r\n```\r\nSign (sk, Message, ctx) -> (signature)\r\n\r\n\r\nSignature Generation Process:\r\n\r\n   1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(ctx || Message)\r\n\r\n   2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx=\"\" )\r\n         S2 := Trad.Sign( K2, A2, M' )\r\n```\r\n\t \r\nVersion 2:\t \r\n```\r\nSign (sk, Message, ctx) -> (signature)\r\n\r\n\r\nSignature Generation Process:\r\n\r\n   1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(Message)\r\n\r\n   2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx )\r\n         S2 := Trad.Sign( K2, A2, HASH(ctx || M') )\r\n```",
          "createdAt": "2024-09-12T20:08:29Z",
          "updatedAt": "2024-09-12T20:08:29Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We did agree that since FIPS 204 defines the API to be:\r\n>ML-DSA.Sign(\ud835\udc60\ud835\udc58, \ud835\udc40, \ud835\udc50\ud835\udc61\ud835\udc65)\r\n\r\nour Composite-ML-DSA should at least have the same API.",
          "createdAt": "2024-09-12T20:09:19Z",
          "updatedAt": "2024-09-12T20:09:19Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Composite author's meeting, we decided to do this:\r\n\r\n```\r\nSignature Generation Process:\r\n\r\n   0. IF |ctx| > 255:\r\n      fail\r\n\r\n   1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(IntegerToBytes(|ctx|, 1) || ctx || Message)\r\n\t \r\n\t where IntegerToBytes(x, alpha) is defined in [FIPS204].\r\n\r\n   2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx )\r\n         S2 := Trad.Sign( K2, A2, M' )\r\n\t \r\nNote that the `M'` construction here mirrors exactly the analogous construction within ML-DSA Algorithm 2 [FIPS204].\r\n```\r\n\r\nNote: we need to update Felipe's PR: https://github.com/lamps-wg/draft-composite-sigs/pull/38/files",
          "createdAt": "2024-09-25T14:38:18Z",
          "updatedAt": "2024-09-25T14:38:18Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "In https://github.com/lamps-wg/draft-composite-sigs/issues/35#issuecomment-2360558887 Falko pointed out that EdDSA also uses context. Shall we pass it to his algo also ?",
          "createdAt": "2024-09-26T12:25:53Z",
          "updatedAt": "2024-09-26T12:25:53Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I was just looking at the ML-DSA draft, and they define the pre-hash as this:\r\n\ud835\udc40 \u2190 BytesToBits(IntegerToBytes(1, 1) \u2225 IntegerToBytes(|\ud835\udc50\ud835\udc61\ud835\udc65|, 1) \u2225 \ud835\udc50\ud835\udc61\ud835\udc65 \u2225 OID \u2225 PH\r\n\r\nWhere OID is equivalent to our Domain, and PH is H (Message)\r\n\r\nSo to align better with what is in pre-hash format of NIST ML-DSA, why don't we re-order to the following:\r\n\r\nM' := Domain || HASH(IntegerToBytes(|ctx|, 1) || ctx || Message)\r\nM' := IntegerToBytes(|ctx|, 1) || ctx || Domain || Hash (Message)\r\n\r\nThe part that is missing is what Max had pointed out. (BytesToBits(IntegerToBytes(1, 1) )     \r\n\r\nSo I think it makes sense to align to:\r\n\r\nM' :=  BytesToBits(IntegerToBytes(1, 1) ||  IntegerToBytes(|ctx|, 1) || ctx || Domain || Hash (Message)\r\n\r\n\r\nThis would also align with Bert Kaliski's \"Modes of Operation\" presentation at ICMC.  For example, they are advocating the \"MTL\" mode using something like this:\r\n\r\nM' :=  BytesToBits(IntegerToBytes(129, 1) ||  IntegerToBytes(|ctx|, 1) || ctx || Domain || Hash (Message)\r\n\r\nSo we could request a different integer value to indicate composite signing, or just use 1 to indicate it is essentially a standard ML-DSA pre-hash\r\n\r\n",
          "createdAt": "2024-09-26T14:52:18Z",
          "updatedAt": "2024-09-26T14:52:18Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "After many conversations we resolved this by adding both a Pure and PreHash Modes for the message format that Align with the FIPS 204 document.\r\n\r\nPure:        M' :=  Domain || len(ctx) || ctx || M\r\nPreHash:  M' :=  Domain || len(ctx) || ctx || HashOID || PH(M)",
          "createdAt": "2024-10-18T14:46:08Z",
          "updatedAt": "2024-10-18T14:46:08Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOL5eEDM6WfqiO",
      "title": "Max suggests dropping SEQUENCE OF wrapper",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/43",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Max,\r\n\r\nIf I understand your proposal, you are suggesting that\r\n\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2) OF BIT STRING\r\nCompositeSignatureValue ::= SEQUENCE SIZE (2) OF BIT STRING\r\n\r\n\r\nBecomes\r\n\r\nCompositeSignaturePublicKey ::= BIT STRING\r\nCompositeSignatureValue ::= BIT STRING\r\n\r\nAn then you need to specify that for id-MLDSA44-RSA2048-PSS-SHA256 the first X bits are the ML-DSA-44 public key / signature, and the remaining Y bits are the RSA-2048.\r\n\r\n\r\nThe original reason for an ASN.1 wrapper was to gracefully handle algorithms with variable-length publickeys, signatures, or ciphertexts, which I believe there were some of in NIST Round 1. This is no longer a concern with FIPS 203 / 204, so we could now remove it. However, I think it will be a fair amount of editorial work (we will need to accurately list out the bit position to split at for each composite alg), and it is asking all existing composite implementations to change, then will require a lot of interop testing. Is this change really worth it?\r\n\r\nIf you feel strongly about this, then perhaps you could prepare the change to the document on a side-branch, and we could bring it to the LAMPS mailing list?\r\n",
      "createdAt": "2024-09-13T13:40:28Z",
      "updatedAt": "2024-09-25T14:48:39Z",
      "closedAt": "2024-09-25T14:48:39Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group discussed the issue on September 25th, and we decided not to change it.   ",
          "createdAt": "2024-09-25T14:48:39Z",
          "updatedAt": "2024-09-25T14:48:39Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOL5eEDM6W5C8r",
      "title": "Description of \"PUBLIC-KEY\" is wrong",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/44",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "Laurent Pion points out that a signature is produced by a private key, not a public key.\r\n\r\n> Chapter 6.1, table 1\r\n> Don\u2019t know if it\u2019s my wrong understanding or a little mistake, PUBLIC-KEYS, is it the composite (private) key required to produce the signature or the public key to verify it?\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/S5CyDKP4xngRmHNdlmHozXrpLzw/\r\n",
      "createdAt": "2024-09-17T16:01:51Z",
      "updatedAt": "2024-10-17T19:08:53Z",
      "closedAt": "2024-10-17T19:08:52Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the description is wrong.  In RFC 5912 it is this:\r\n\r\nSIGNATURE-ALGORITHM ::= CLASS {\r\n    &id             OBJECT IDENTIFIER UNIQUE,\r\n    &Value          OPTIONAL,\r\n    &Params         OPTIONAL,\r\n    &paramPresence  ParamOptions DEFAULT absent,\r\n    &HashSet        DIGEST-ALGORITHM OPTIONAL,\r\n    &PublicKeySet   PUBLIC-KEY OPTIONAL,\r\n    &smimeCaps      SMIME-CAPS OPTIONAL\r\n} WITH SYNTAX {\r\n    IDENTIFIER &id\r\n    [VALUE &Value]\r\n    [PARAMS [TYPE &Params] ARE &paramPresence ]\r\n    [HASHES &HashSet]\r\n    [PUBLIC-KEYS &PublicKeySet]\r\n\r\n\r\nSo we changed the wording in the document to the following to clarify:\r\n\r\nThe following is an explanation how SIGNATURE-ALGORITHM elements are used\r\nto define Composite Signatures:\r\n\r\n| SIGNATURE-ALGORITHM element | Definition |\r\n| ---------                  | ---------- |\r\n| IDENTIFIER                  | The Object ID used to identify the composite Signature Algorithm |\r\n| VALUE                       | The Sequence of BIT STRINGS for each component signature value |\r\n| PARAMS                      | Parameters are absent  |\r\n| PUBLIC-KEYS                 | The composite public key type associated with the composite signature |\r\n\r\n\r\n\r\n",
          "createdAt": "2024-10-16T14:16:34Z",
          "updatedAt": "2024-10-16T14:16:34Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed as part of #59 ",
          "createdAt": "2024-10-17T19:08:52Z",
          "updatedAt": "2024-10-17T19:08:52Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOL5eEDM6XFAn8",
      "title": "Clarify that we are using pure ML-DSA, not HashML-DSA",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/45",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "We should add text in a few places\r\nWe should add this in the section where we define the signature process, and we should also mention it in the appendix about FIPS certification of a composite implementation.\r\n\r\n(Credit for this ticket: Jeff Andersen)",
      "createdAt": "2024-09-18T20:33:42Z",
      "updatedAt": "2024-10-17T19:09:27Z",
      "closedAt": "2024-10-17T19:09:26Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to support both PreHash and Pure modes.  Merged in #59 ",
          "createdAt": "2024-10-17T19:09:26Z",
          "updatedAt": "2024-10-17T19:09:26Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOL5eEDM6XmDo5",
      "title": "Adjust Security Consideration on stripping attacks",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/46",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ounsworth"
      ],
      "labels": [],
      "body": "In response to comments from Falko:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/-wg0a8xuhrosRdZlzvQpYD1r0vE/\r\n\r\nOLD\r\n> When considering stripping attacks, one need consider the case where an attacker has fully compromised one of the component algorithms to the point that they can produce forged signatures that appear valid under one of the component public keys, and thus fool a victim verifier into accepting a forged signature.\r\n\r\nNEW\r\n\r\n> Hybrid signature primitives that are susceptible to stripping attacks violate existential universal forgery by virtue of the fact that the signer produced (\\sigma, M) where \\sigma = {\\sigma_mldsa, \\sigma_trad}, and thus the ability to produce from this valid pairs (\\sigma_mldsa, M) or (\\sigma_trad, M) would constitute existential forgery attacks under the definition of EUF. This could be turned into practical attacks in a number of ways, such as a \u201csignature mis-attribution attack\u201d where the attacker makes a message appear to be signed by a certificate containing the public key {RSA} when in fact it was signed by the public key {ML-DSA, RSA} which happens to share the RSA public key but may in fact belong to a completely different entity. On top of this, a stripping attack isolates the two algorithms, which could lead to still further message forgery attacks against the weaker of the two algorithms.\r\n\r\n(I don\u2019t have the I-D text in front of me right now, so I\u2019ll probably need to adjust it a bit to fit with the section\u2019s flow.)\r\n",
      "createdAt": "2024-09-23T18:18:26Z",
      "updatedAt": "2024-10-16T12:58:21Z",
      "closedAt": "2024-10-16T12:58:21Z",
      "comments": [
        {
          "author": "codespree",
          "authorAssociation": "NONE",
          "body": "# Chained Signature Idea\r\n\r\nThough this may or may not not address stripping attacks, I am just adding it here for your consideration as an idea:\r\n\r\n```\r\ndom_sep(alg1, alg2):\r\n    return oid_to_der(alg1.oid) || oid_to_der(alg2.oid)\r\n\r\npre_hash(alg1, alg2, msg):\r\n    return dom_sep(alg1, alg2) || hash(msg)\r\n\r\nsign(alg1, alg2, sk_alg_1, sk_alg_2, msg):\r\n    // Signing order alg1, alg2 chained\r\n    // Original signature on msg with alg 1 using composite domain separator (alg1, alg2)\r\n    s1 = alg1.sign(sk_alg_1 , pre_hash(alg1, alg2, msg))\r\n\r\n    // Signature on s1 with alg 2 using opposite composite  domain separator (alg2, alg1)\r\n    s1' = alg2.sign(sk_alg_2 , pre_hash(alg2, alg1, s1))\r\n\r\n    // Signing order alg2, alg1 chained\r\n    // Original signature on msg with alg2 using composite domain separator (alg2, alg1)\r\n    s2 = alg2.sign(sk_alg_2, pre_hash(alg2, alg1, msg))\r\n     \r\n    // Signature on s2 with alg 1 with opposite composite  domain separator (alg1, alg2)\r\n    s2' = alg1.sign(sk_alg_1, pre_hash(alg1, alg2, s2)\r\n    \r\n    return comp_sig(s1, s1', s2, s2')\r\n\r\nverify(alg1, alg2, pk_alg1, pk_alg2, comp_sig, msg):\r\n    s1 = comp_sig[0]\r\n    s1' = comp_sig[1]\r\n    s2 = comp_sig[2]\r\n    s2' = comp_sig[3]\r\n\r\n    // Verification of signature s1 on original message with alg1\r\n    u1 = alg1.verify(pk_alg_1 , s1, pre_hash(alg1, alg2, msg))\r\n    // Verification of signature s1' on message s1 with alg 2\r\n    u1' = alg2. verify(pk_alg_2 , s1', pre_hash(alg2, alg1, s1))\r\n    \r\n    // Verification of signature s2 on original message with alg2\r\n    v2 = alg2.verify(pk_alg_2, s2, pre_hash(alg2, alg1, msg))\r\n    // Verification of signature s2' on message s2 with alg1\r\n    v2' = alg1.verify(pk_alg_1, s2', pre_hash(alg2, alg1, s2)\r\n    \r\n    return u1 && u1' && v2 && v2'\r\n```\r\n\r\n# Chained Signature Idea (with nonce)\r\n\r\nWith a nonce, the same idea looks like:\r\n```\r\ndom_sep(alg1, alg2):\r\n    return oid_to_der(alg1.oid) || oid_to_der(alg2.oid)\r\n\r\npre_hash(alg1, alg2, nonce , msg):\r\n    return nonce || dom_sep(alg1, alg2) || hash(msg)\r\n\r\nsign(alg1, alg2, sk_alg_1, sk_alg_2, msg):\r\n    // Generate a random nonce\r\n    nonce = uuid()\r\n\r\n    // Signing order alg1, alg2 chained\r\n    // Original signature on msg with alg 1 using composite domain separator (alg1, alg2)\r\n    s1 = alg1.sign(sk_alg_1 , pre_hash(alg1, alg2, nonce , msg))\r\n\r\n    // Signature on s1 with alg 2 using opposite composite  domain separator (alg2, alg1)\r\n    s1' = alg2.sign(sk_alg_2 , pre_hash(alg2, alg1, nonce, s1))\r\n\r\n    // Signing order alg2, alg1 chained\r\n    // Original signature on msg with alg2 using composite domain separator (alg2, alg1)\r\n    s2 = alg2.sign(sk_alg_2, pre_hash(alg2, alg1, nonce, msg))\r\n     \r\n    // Signature on s2 with alg 1 with opposite composite  domain separator (alg1, alg2)\r\n    s2' = alg1.sign(sk_alg_1, pre_hash(alg1, alg2, nonce, s2)\r\n    \r\n    return comp_sig(nonce, s1, s1', s2, s2')\r\n\r\nverify(alg1, alg2, pk_alg1, pk_alg2, comp_sig, msg):\r\n    nonce = comp_sig[0]\r\n    s1 = comp_sig[1]\r\n    s1' = comp_sig[2]\r\n    s2 = comp_sig[3]\r\n    s2' = comp_sig[4]\r\n\r\n    // Verification of signature s1 on original message with alg1\r\n    u1 = alg1.verify(pk_alg_1 , s1, pre_hash(alg1, alg2, nonce, msg))\r\n    // Verification of signature s1' on message s1 with alg 2\r\n    u1' = alg2. verify(pk_alg_2 , s1', pre_hash(alg2, alg1, nonce, s1))\r\n    \r\n    // Verification of signature s2 on original message with alg2\r\n    v2 = alg2.verify(pk_alg_2, s2, pre_hash(alg2, alg1, nonce, msg))\r\n    // Verification of signature s2' on message s2 with alg1\r\n    v2' = alg1.verify(pk_alg_1, s2', pre_hash(alg2, alg1, nonce, s2)\r\n    \r\n    return u1 && u1' && v2 && v2'\r\n```\r\n\r\nWith a nonce, none of the individual components can be used separately without specifying the same nonce.",
          "createdAt": "2024-09-25T06:47:54Z",
          "updatedAt": "2024-09-25T07:06:53Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOL5eEDM6X2y13",
      "title": "Use raw encodings for EDDSA Public Key ECPoint",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/48",
      "state": "CLOSED",
      "author": "janklaussner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "Hey composite sigs authors, I just wanted to point out that I think the ASN.1 for EDDSA composites is wrong.  It uses ECPoint for the SecondPublicKeytype, but EDDSA public keys aren't encoded using ECPoint, they are raw.\r\n\r\n   pk-MLDSA65-Ed25519-SHA512 PUBLIC-KEY ::=\r\n     pk-CompositeSignature{ id-MLDSA65-Ed25519-SHA512,\r\n     OCTET STRING, ECPoint}\r\nRFC 8410:\r\n\r\n    pk-Ed25519 PUBLIC-KEY ::= {\r\n        IDENTIFIER id-Ed25519\r\n        -- KEY no ASN.1 wrapping --\r\n        PARAMS ARE absent\r\n        CERT-KEY-USAGE {digitalSignature, nonRepudiation,\r\n                        keyCertSign, cRLSign}\r\n        PRIVATE-KEY CurvePrivateKey\r\n    }\r\nSo however you do the encoding for the ML-DSA keys is how you should do the encoding for EDDSA keys as well.\r\n\r\nDaniel",
      "createdAt": "2024-09-25T11:27:38Z",
      "updatedAt": "2024-10-10T10:38:43Z",
      "closedAt": "2024-10-10T10:38:43Z",
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "done with #47  ",
          "createdAt": "2024-10-10T10:38:43Z",
          "updatedAt": "2024-10-10T10:38:43Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOL5eEDM6X4yzW",
      "title": "Security consideration: do we mention the revocation problem?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/49",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "We should mention that when a CA checks a public key to see if it has previously been revoked, this is often done by public key hash, so it is possible that a composite public key is submitted to a CA and even though both component keys have been revoked for key compromise, the CA may not detect it. For this reason, CAs checking composite keys for revocation for key compromise SHOULD check for both component keys independently.\r\n\r\nWe may already have text to this effect, but we should review it.",
      "createdAt": "2024-09-25T15:00:55Z",
      "updatedAt": "2024-10-16T12:58:20Z",
      "closedAt": "2024-10-16T12:58:20Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Requiring fresh keys is what is motivating this security consideration.",
          "createdAt": "2024-09-25T15:03:29Z",
          "updatedAt": "2024-09-25T15:03:29Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOL5eEDM6YFUOQ",
      "title": "PrivateKey section is not explicit about which AlgID OIDs to place in the component OneAsymmetricKeys",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/55",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Relates to #6.\r\n\r\nIf we decide to do the private key compression, then this issue will become moot.",
      "createdAt": "2024-09-26T21:05:28Z",
      "updatedAt": "2024-10-09T14:55:03Z",
      "closedAt": "2024-10-09T14:54:22Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The Group agreed to solve #6 so this issue should no longer be relevant.  ",
          "createdAt": "2024-10-09T14:54:22Z",
          "updatedAt": "2024-10-09T14:54:22Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Removing the redundancy from the Private key, so this issue is no longer valid.",
          "createdAt": "2024-10-09T14:55:02Z",
          "updatedAt": "2024-10-09T14:55:02Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOL5eEDM6ZmHub",
      "title": "Do we lock CMS usage down to Hash specified in OIDs",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/60",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "Currently we have this text:\r\n\r\nWhen signed attributes are absent, the composite signature is computed over the message digest of the content. When signed attributes are present, a hash is computed over the content using the hash function specified in {{tab-cms-shas}}, and then a message-digest attribute is constructed to contain the resulting hash value, and then the result of DER encoding the set of signed attributes, which MUST include a content-type attribute and a message-digest attribute, and then the composite signature is computed over the DER-encoded output. In summary:\r\n\r\nIt seems to imply we MUST use the Hashing algorithm specified in the tab-cms-shas table, but that table says it is Mandatory strength considerations.  So I think we are saying we would allow other Hash algorithms as long as they are considered as secure as the ones listed in tab-cms-shas, but this is not clear.",
      "createdAt": "2024-10-09T20:38:43Z",
      "updatedAt": "2024-10-21T18:59:31Z",
      "closedAt": "2024-10-21T18:59:31Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The text has been updated to be more clear in pull #72 .   Added some text that alternate digest algorithms can be used as long as they preserve the performance and security of the Mandatory hash algorithms.",
          "createdAt": "2024-10-21T18:59:31Z",
          "updatedAt": "2024-10-21T18:59:31Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOL5eEDM6ZxrCn",
      "title": "Review DER encoding of OIDs",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/61",
      "state": "CLOSED",
      "author": "opencrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "opencrypto",
        "johngray-dev"
      ],
      "labels": [
        "bug"
      ],
      "body": "During the implementation of the new version, the DER encoding value seems to give wrong results for the OID. Here's the binary value that I use in my implementation:\r\n```\r\n0x60, 0x86, 0x48, 0x01, 0x86, 0xFA, 0x6B, 0x50, 0x08, 0x01, 0x01\r\n```\r\ninstead of the value in the draft that has a couple of extra bytes.\r\n\r\nAm I missing something?",
      "createdAt": "2024-10-10T22:01:50Z",
      "updatedAt": "2024-10-16T14:06:46Z",
      "closedAt": "2024-10-16T14:06:45Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The Tag and Length values of the Object ID are in the draft now... Thats the 060B part at the beginning\r\n\r\nPlug the ones in the draft in this site:  https://lapo.it/asn1js/\r\n060B6086480186FA6B50080115\r\n\r\nIt gives the following as an object ID\r\n2.16.840.1.114027.80.8.1.21\r\n\r\nWe could strip that off if we wanted, and just have the value, which is:\r\n6086480186FA6B50080115\r\n",
          "createdAt": "2024-10-11T12:48:09Z",
          "updatedAt": "2024-10-11T12:48:09Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@opencrypto these are domain separator string, you can just close your eyes and pretend that it's a random hex string. It does not really matter if it can be decoded correctly or not.",
          "createdAt": "2024-10-16T14:06:36Z",
          "updatedAt": "2024-10-16T14:06:36Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "These aren't really meant to be decoded by software (but they can if you like), that is why we have them in a table for domain separation..",
          "createdAt": "2024-10-16T14:06:46Z",
          "updatedAt": "2024-10-16T14:06:46Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOL5eEDM6aLP_V",
      "title": "Missing MLDSA44_BrainPool256 from algorithm combinations",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/62",
      "state": "CLOSED",
      "author": "opencrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [
        "bug"
      ],
      "body": "In the latest version of the draft where RSA4096 was added seems to be missing the low-level combination for BrainPool curves (MLDSA44 with BrainPool256R1). Shall it be added back?",
      "createdAt": "2024-10-14T17:28:34Z",
      "updatedAt": "2024-10-16T14:04:00Z",
      "closedAt": "2024-10-16T14:03:59Z",
      "comments": [
        {
          "author": "opencrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Also the corresponding domain separator is missing.",
          "createdAt": "2024-10-14T17:41:34Z",
          "updatedAt": "2024-10-14T17:41:34Z"
        },
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "Neither BSI nor ANSSI approve MLDSA44 for use.  If I understand correctly, BrainPool is included for them.  So if MLDSA44 with BrainPool256R1 is added I don't think it will be used.",
          "createdAt": "2024-10-14T18:19:46Z",
          "updatedAt": "2024-10-14T18:19:46Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @danvangeest, and also look at openpgp wg: https://datatracker.ietf.org/meeting/120/materials/slides-120-openpgp-pqc-with-nist-and-brainpool-curves-00.pdf",
          "createdAt": "2024-10-16T06:14:55Z",
          "updatedAt": "2024-10-16T06:14:55Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on the comments, I don't think we need this.  We want to align as much with others as possible, and adding another combination means more OIDs and no point adding it unless we know someone that wants this one.",
          "createdAt": "2024-10-16T13:01:24Z",
          "updatedAt": "2024-10-16T13:01:24Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group agreed to close... We will not add this combination",
          "createdAt": "2024-10-16T14:03:59Z",
          "updatedAt": "2024-10-16T14:03:59Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOL5eEDM6aLdjP",
      "title": "Combination for Level 3 has been changed to (Draft 3) ML_DSA_65 + NISTP384 from (Draft 2) ML_DSA_65 + NISTP256)",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/63",
      "state": "CLOSED",
      "author": "opencrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ounsworth",
        "feventura",
        "johngray-dev",
        "janklaussner"
      ],
      "labels": [
        "bug"
      ],
      "body": "The algorithm mldsa65_p384 is replacing the mldsa64_p256 we had previously. It needs to be reverted back.",
      "createdAt": "2024-10-14T17:53:52Z",
      "updatedAt": "2024-10-16T14:03:01Z",
      "closedAt": "2024-10-16T14:03:01Z",
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @opencrypto , \r\nwe decided to align the algorithm combinations with the openpgp WG. There ML-DSA-65 is only combined with NISTP384 curves. See the presentation from IETF 120 (https://datatracker.ietf.org/meeting/120/materials/slides-120-openpgp-pqc-with-nist-and-brainpool-curves-00.pdf) As there NIST is engaged in the selection I think the current combination fits best. \r\nDo YOU explicitely need MLDSA-65 with NISTP256?",
          "createdAt": "2024-10-15T07:27:36Z",
          "updatedAt": "2024-10-15T07:27:36Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided to close since we want to align with openPGP",
          "createdAt": "2024-10-16T14:03:01Z",
          "updatedAt": "2024-10-16T14:03:01Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOL5eEDM6agUH3",
      "title": "Should we use the context String for the underlying ED448 and X25519 algorithms",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/64",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We are using the Domain as a context String for ML-DSA,\r\n\r\nWe can't use the Domain as the context for RSA or ECDSA as they algorithms don't take a context string.\r\n\r\nHowever, ED448 and X25519 do use a context String and could be used.  \r\n\r\nThat would likely give us SUF security for those algorithm combinations.  ",
      "createdAt": "2024-10-16T14:59:16Z",
      "updatedAt": "2024-10-24T21:49:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Bring up to the mailing list or in the 121 presentation.",
          "createdAt": "2024-10-21T01:27:13Z",
          "updatedAt": "2024-10-21T01:27:13Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Both RFC8410 (EdDSA in X.509) and RFC8419 (EdDSA in CMS) say explicitly that the context string is not used. Since currently X.509 and CMS do not use the context string of EdDSA, then the most backwards compatible thing is to maintain that behaviour for the EdDSA component. I think that maintaining the backwards compat on the traditional component is more important than increasing its security above the security that EdDSA has today.",
          "createdAt": "2024-10-21T19:47:33Z",
          "updatedAt": "2024-10-21T19:48:40Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening issue in light of #79 ",
          "createdAt": "2024-10-24T21:49:58Z",
          "updatedAt": "2024-10-24T21:49:58Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOL5eEDM6ar2yE",
      "title": "Add table of PK, Sig sizes",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/65",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/zfWx5fYjvuvohTOI7asQG4m-NDI/\r\n\r\n> Hi Mike,\r\n>\r\n> Your draft:\r\n> https://datatracker.ietf.org/doc/draft-ietf-lamps-pq-composite-kem/\r\n> could do with table  on Npk, Nsk, and NSig sizes. Such tables greatly help\r\n> in implementation.\r\n>\r\n> The idea is from RFC 9180, Section 7.1\r\n> <https://datatracker.ietf.org/doc/rfc9180/>\r\n>\r\n> [image: image.png]\r\n>\r\n> The details of the calculations can be found here:\r\n>\r\n> https://github.com/codespree/quantcrypt/blob/main/additional_info_keysize.md\r\n>\r\n> All the best,\r\n> Varun\r\n\r\nIn my opinion, we should get sample keys, signatures, and ciphertexts for all algorithms, and then measure them. This sounds like a hackathon project.",
      "createdAt": "2024-10-17T16:16:12Z",
      "updatedAt": "2024-10-21T18:57:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ZPDSSAI",
          "authorAssociation": "NONE",
          "body": "Hi Mike,\r\n\r\nI am Peiduo and I am from Varun(@codespree)'s team. We have computed the public key, secrete key and signature lengths for ML-DSA and its composite variations, and the public key, secrete key, shared secret, and cipher text lengths for ML-KEM and its composite variations. The full table documentation, together with notes on overhead computation, can be found in our project repo [here](https://github.com/codespree/quantcrypt/blob/main/additional_info_keysize.md). \r\n\r\nPlease check if the tables meet the requirement of this issue :) \r\n\r\nBest regards,\r\nZhao Peiduo",
          "createdAt": "2024-10-18T09:51:23Z",
          "updatedAt": "2024-10-18T09:51:23Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for doing these computations.  I had done some computations on a handful of them before IETF 120 and it looks like they align (which is always a good thing).  I think we should be able to add these tables to an Appendix.\r\n",
          "createdAt": "2024-10-21T18:57:36Z",
          "updatedAt": "2024-10-21T18:57:36Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOL5eEDM6atiQf",
      "title": "Align with CMS SignerInfo Digest from the CMS ML-DSA draft",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/66",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://datatracker.ietf.org/doc/draft-salter-lamps-cms-ml-dsa/",
      "createdAt": "2024-10-17T20:01:23Z",
      "updatedAt": "2024-10-21T19:44:28Z",
      "closedAt": "2024-10-21T19:44:28Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The follow lines from the above draft should be added to Composite signature to make it clear that any type of Digest values can be used as long as they meet at least the security requirements in the recommended table:\r\n\r\nFrom draft-salter-lamps-cms-ml-dsa:\r\n\r\n Choice of digest algorithm\r\n   is up to the signer; algorithms for each parameter set are\r\n   recommended below.\r\n\r\n\r\n Section 4 of [I-D.ietf-lamps-cms-sphincs-plus] describes how, when\r\n   the content of a signed-data is large, performance may be improved by\r\n   including signed attributes.  This is as true for ML-DSA as it is for\r\n   SLH-DSA, although ML-DSA signature generation and verification is\r\n   significantly faster than SLH-DSA.\r\n\r\nSignerInfo content\r\n\r\n   When using ML-DSA, the fields of a SignerInfo are used as follows:\r\n\r\n   digestAlgorithm:  Per Section 5.3 of [RFC5652], the digestAlgorithm\r\n      field identifies the message digest algorithm used by the signer,\r\n      and any associated parameters.  To ensure collision resistance,\r\n      the identified message digest algorithm SHOULD produce a hash\r\n      value of a size that is at least twice the collision strength of\r\n      the internal commitment hash used by ML-DSA.\r\n      The SHAKE hash functions defined in [FIPS202] are used internally\r\n      by ML-DSA, and hence the combinations in Table 1 are RECOMMENDED\r\n      for use with ML-DSA.  [RFC8702] describes how SHAKE128 and\r\n      SHAKE256 are used in CMS.  The id-shake128 and id-shake256 digest\r\n      algorithm identifiers are used and the parameters field MUST be\r\n      omitted.\r\n\r\n            +=====================+==========================+\r\n            | Signature algorithm | Message digest algorithm |\r\n            +=====================+==========================+\r\n            | ML-DSA-44           | SHAKE128                 |\r\n            +---------------------+--------------------------+\r\n            | ML-DSA-65           | SHAKE256                 |\r\n            +---------------------+--------------------------+\r\n            | ML-DSA-87           | SHAKE256                 |\r\n            +---------------------+--------------------------+\r\n\r\n              Table 1: Recommended message digest algorithms\r\n                     for ML-DSA signature algorithms\r\n",
          "createdAt": "2024-10-21T16:58:31Z",
          "updatedAt": "2024-10-21T16:58:31Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Added the clarifying text in pull #72 ",
          "createdAt": "2024-10-21T18:55:40Z",
          "updatedAt": "2024-10-21T18:55:40Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOL5eEDM6a2Fn4",
      "title": "Need to add the New PreHash OIDs to the ASN.1 module",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/69",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When Updating the Pre-Hash versions, I forgot to add them to the ASN.1 module.",
      "createdAt": "2024-10-18T15:47:13Z",
      "updatedAt": "2024-10-18T17:17:13Z",
      "closedAt": "2024-10-18T17:17:13Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in Pull #70 ",
          "createdAt": "2024-10-18T17:17:13Z",
          "updatedAt": "2024-10-18T17:17:13Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOL5eEDM6a9fZY",
      "title": "Do we need to define smimecaps for each sa- ?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/71",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-20T01:28:53Z",
      "updatedAt": "2024-10-21T19:44:48Z",
      "closedAt": "2024-10-21T19:44:48Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This was added in Pull #72 ",
          "createdAt": "2024-10-21T19:44:48Z",
          "updatedAt": "2024-10-21T19:44:48Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOL5eEDM6bU0OT",
      "title": "The ML-DSA OIDS in Appendix C are the old prototype OIDS and need to be updated",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/73",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The ML-DSA OIDS in Appendix C are incorrect and the encodings need to be updated to the following:\r\n\r\n     id-ML-DSA-44            2.16.840.1.101.3.4.3.17\r\n     id-ML-DSA-65            2.16.840.1.101.3.4.3.18  \r\n     id-ML-DSA-87            2.16.840.1.101.3.4.3.19 \r\n\r\nThanks to Amador Cervera for pointing this out the day after we published the latest update!\r\n\r\n",
      "createdAt": "2024-10-22T16:24:31Z",
      "updatedAt": "2024-10-23T14:54:59Z",
      "closedAt": "2024-10-23T14:54:59Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOL5eEDM6bgNsV",
      "title": "Fix the IANA indents",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/75",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Somehow they lost their indents and look messy.",
      "createdAt": "2024-10-23T14:54:25Z",
      "updatedAt": "2024-10-23T18:45:25Z",
      "closedAt": "2024-10-23T18:45:25Z",
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOL5eEDM6bowUq",
      "title": "Confusing text in EUF-CMA section",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/77",
      "state": "OPEN",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [
        "johngray-dev"
      ],
      "labels": [],
      "body": "This sentence in section 11.1 is confusing, in particular the part in bold.\r\n\r\n   The latter\r\n   version bears a resemblance to a stripping attack, which parallel\r\n   signatures are subject to, but is slightly different in that the\r\n   cross-protocol EUF-CMA game **also considers modification message\r\n   definition as signed differs from the message the verifier accepts**.\r\n\r\nI don't even have a suggestion on how to fix that, so I'll leave it to the authors.\r\n\r\nAlso I suggest this text to fix the next sentence:\r\n\r\n   In contrast, stripping attacks consider removing one component signature and attempting to verify the remaining signature with the\r\n   same message.\r\n",
      "createdAt": "2024-10-24T10:29:54Z",
      "updatedAt": "2024-12-11T15:38:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 78,
      "id": "I_kwDOL5eEDM6bo1pm",
      "title": "Inconsistent normative language regarding key reuse ",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/78",
      "state": "OPEN",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 4.1 says:\r\n\r\n   In order to ensure fresh keys, the key generation functions MUST be\r\n   executed for both component algorithms.  Compliant parties MUST NOT\r\n   use or import component keys that are used in other contexts,\r\n   combinations, or by themselves as keys for standalone algorithm use.\r\n\r\nAlso I suggest \"use, import, **or export** component keys...\"\r\n\r\nSection 11.2 says:\r\n\r\n   Therefore, it is\r\n   RECOMMENDED to avoid key reuse and always generate fresh component\r\n   keys for a new composite.  It is also RECOMMENDED that CAs performing\r\n   revocation checks on a composite key should also check both component\r\n   keys independently.\r\n\r\nThe normative language needs to be consistent; these should either be MUST/REQUIRED, or SHOULD/RECOMMENDED.",
      "createdAt": "2024-10-24T10:40:42Z",
      "updatedAt": "2024-10-24T21:36:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree.  We will make the language consistent.  We will change it to MUST/REQUIRED.  ",
          "createdAt": "2024-10-24T21:36:30Z",
          "updatedAt": "2024-10-24T21:36:30Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOL5eEDM6bpY68",
      "title": "More about key reuse",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/79",
      "state": "OPEN",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "So, I think I have a use case for key reuse for composite signatures.  To allow the use of the native and alternative private and public keys of Catalyst (hssss) certificates to generate composite signatures.  Composite private and public keys for the certificate wouldn't exist in the wild, but the native and alternative private keys of a certificate could be used to generate a composite signature.\r\n\r\nDue to the flexibility of these certificates, this means that a signature could be generated corresponding to the native key, the alternative key, or a composite of the native+alternative key.\r\n\r\nSome of you authors already know that I'm not generally in favour of Catalyst certificates, but there are those out there who still want to use them, so I'm coming at this from a harm-reduction perspective.  And also from a forward-looking perspective, this draft is setting the standard for composite signatures.  It would be easier if future composite signatures, for example PQ/PQ, could use the framework of this draft (and implementation) to define other composites (obviously with specific security considerations for the component algorithms involved). At that point, both component algorithms may take a context and key reuse could be done safely.\r\n\r\nTo that end, I wonder if it would be worth considering enabling key reuse of the component algorithms which take a context parameter by changing the context from:\r\n\r\nctx = Domain\r\n\r\nto:\r\n\r\nctx = Domain || Hash(PublicKey1 || PublicKey2)\r\n\r\nThis would provide domain separation for a key, ML-DSA for example, to be used standalone or as part of multiple composite keys (even multiple composite keys with the same Domain, because the key hash achieves the separation).  I don't claim it's a good idea to reuse a key in multiple composite keys with the same Domain, just that this idea would protect the key if that happened.\r\n\r\nI'm interested in your opinions.",
      "createdAt": "2024-10-24T11:46:02Z",
      "updatedAt": "2024-11-02T17:28:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "As Scott says elsewhere, 'belt and suspenders` but this is belt and suspenders and superglue.",
          "createdAt": "2024-10-24T11:52:22Z",
          "updatedAt": "2024-10-24T11:52:22Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "My first thought is what if the signer doesn't have access to the public key?   My second thought is this works great to obtain what you want for ML-DSA or other component algorithms that take a context, but not at all for the ones that don't (which is RSA and most EC combinations except the Edwards ones).  So at best in the context of the current draft it would give us separation for 1 of the components, but not the others, which would foil our security claim of EUF-CMA as long as one of them is EUF-CMA.   My third thought is that we had thought about this property a few years ago (For instance, it would work with multiple independent certs as well), and there probably are lots of interesting use cases where keys could be joined to make a composite signature.  After lots of discussions it seems this property wasn't desired in lieu of the security implications it brought to composite.   \r\n\r\nPerhaps for combinations where a context string is used in BOTH algorithms this could make sense...  We had talked about using context strings for other components that could support it.  See  https://github.com/lamps-wg/draft-composite-sigs/issues/64  but it was mostly decided against because the most compatible way is to use no context String...    \r\n\r\nSo in summary for cases where both components take contexts, I would say it is interesting.    For cases where some components don't take a context String, i don't think we want to go there. ",
          "createdAt": "2024-10-24T21:52:09Z",
          "updatedAt": "2024-10-24T21:52:09Z"
        },
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "Here is someone trying to combine separate keys using the composite signature construct.  Check out IPSECME on Monday to see/influence how that goes.\r\nhttps://datatracker.ietf.org/doc/draft-hu-ipsecme-pqt-hybrid-auth/\r\n\r\nRegarding your second thought, yes it protects ML-DSA but not the trad key.  My point is if someone is going to end up doing this anyways, better to protect only the ML-DSA key than neither key.",
          "createdAt": "2024-11-02T17:28:38Z",
          "updatedAt": "2024-11-02T17:28:38Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOL5eEDM6bqicv",
      "title": "Composite vs component context",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/80",
      "state": "OPEN",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been going through all the closed context related issues. #42 says that you decided on `ML-DSA.Sign( K1, A1, M', ctx )`, `ctx` being what was passed into the composite Sign function (https://github.com/lamps-wg/draft-composite-sigs/issues/42#issuecomment-2374284632). I haven't seen any more recent comments that update that.  However, draft -03 says `ML-DSA.Sign( mldsaSK, M', ctx=Domain )`.  Here the context is `Domain`.\r\n\r\nI just want to verify that this was an intended change between that commend and the draft, and not a mistake.\r\n\r\nFWIW, I think that the draft is correct and `Domain` is the way to go because it protects against (signature collisions) / (EUF-CMA attacks) / (I don't know the terminology) where Composite.Sign(M, ctx) would have the same signature as ML-DSA.Sign(Domain || len(ctx) || ctx || M, ctx).  Changing the latter context to `Domain` avoids the collision.\r\n\r\nI also feel in the back of my head that using `Domain || HASH(ctx)` would be even better, but I can't express why.  It just feels safer to mix the application context in all the way down.  But perhaps because the application context is already in M' this doesn't matter.",
      "createdAt": "2024-10-24T13:26:56Z",
      "updatedAt": "2024-10-24T21:58:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that change was made on purpose, based on comments in the mailing list.  We had a marathon weekend working on issues.  Sorry if the reasons for the change weren't entirely clear, but they were specifically added to protect against the attacks you mention.  \r\n\r\nAs for using Domain || HASH(ctx), we can discuss if this strengthens it at all.  I think since it is in M' it shouldn't be needed.  Originally we didn't think we needed in the ML-DSA context since ctx was in M', but it turns out having it as something different does strengthen it.   Adding it would also add another HASH to the computation... probably not a big if we thought it added value.   ",
          "createdAt": "2024-10-24T21:57:36Z",
          "updatedAt": "2024-10-24T21:58:33Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOL5eEDM6cIsai",
      "title": "Typo in algs list table:",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/81",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The column \"Composite Signature AlgorithmID\" should just be \"Composite Signature Algorithm\" because the thing in this column is an algorithm OID, not a full AlgorithmID structure.",
      "createdAt": "2024-10-28T20:52:50Z",
      "updatedAt": "2024-10-28T20:52:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 82,
      "id": "I_kwDOL5eEDM6cKlxT",
      "title": "Clarify we only support use of the RSA PSS OID, not rsaEncryption",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/82",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the notes on RSA-PSS, we should make it clear the OID to be used is https://oidref.com/1.2.840.113549.1.1.10 and not rsaEncryption.   It is noted later in the document, but clarity is always a good thing.  This will make encoding/decoding PSS components more clear.\r\n\r\n",
      "createdAt": "2024-10-29T03:23:17Z",
      "updatedAt": "2024-10-29T03:23:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 83,
      "id": "I_kwDOL5eEDM6ca7r3",
      "title": "Add text to use the empty String in the \"Use in CMS section\"",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/83",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To align with ML-DSA use in CMS, the context string passed into the message format should be empty\r\n\r\nM' = Domain | len(ctx) || ctx || Message\r\n\r\nwhere ctx = {empty}\r\n\r\n",
      "createdAt": "2024-10-30T14:32:31Z",
      "updatedAt": "2024-10-30T14:32:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 84,
      "id": "I_kwDOL5eEDM6cmBnW",
      "title": "Discussion: Reconsider move to abandon sequence of OAKs for private key",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/84",
      "state": "CLOSED",
      "author": "codespree",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moving to \r\n`CompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OctetString`\r\nis not a good idea in my opinion. \r\n\r\nThe reason for this is because this breaks compatibility with the composite KEM key formats:\r\n\r\nFrom the KEM draft:\r\n```\r\n            However, the public key of the traditional component, RSA or Elliptic Curve, is\r\n            required as input to the KEM Combiner function, and is not typically carried\r\n            within an RSA or Elliptic Curve private key. Therefore the publicKey field of\r\n            the second OneAsymmetricKey MUST contain the corresponding\r\n            public key. See Appendix C.3:\r\n            https://lamps-wg.github.io/draft-composite-kem/draft-ietf-lamps-pq-composite-kem.html#impl-cons-decaps-pubkey\r\n```\r\n\r\nWith the older sequence of OAKs structure, it was possible to include the trad public key in the traditional secret key OAK (for composite KEMs)\r\n\r\nBut this is no longer possible with the new structure. \r\n\r\nWhich now means there need to be two different implementations of composite private keys (one with a sequence of bitstrings for ML-DSA composites and one with a sequence of OAKs for KEM).\r\n\r\nI would prefer if there was a common format for this.\r\n\r\nLet me know your thoughts on this and I will modify my code accordingly.\r\n\r\nBy the way, apart from the private key difference, [QuantCrypt](https://github.com/codespree/quantcrypt) is updated with an implementation of your new draft.\r\n\r\nI will also opened an issue in the PQC certificate hackathon repository with the artifacts:\r\nhttps://github.com/IETF-Hackathon/pqc-certificates/issues/149\r\n\r\n@ounsworth ",
      "createdAt": "2024-10-31T15:53:13Z",
      "updatedAt": "2024-11-01T13:52:48Z",
      "closedAt": "2024-11-01T13:52:48Z",
      "comments": [
        {
          "author": "codespree",
          "authorAssociation": "NONE",
          "body": "After some more thought. I guess it doesn't matter that much. Closing this issue.",
          "createdAt": "2024-11-01T13:52:48Z",
          "updatedAt": "2024-11-01T13:52:48Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOL5eEDM6dOWIj",
      "title": "Remove ASN.1 wrapping in signature, public and private key encodings",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/85",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It has been suggested that we remove the ASN.1 in the signature, public and private key encodings.    This will make composite signatures easier to use in other protocols.\r\n\r\nsomething like:\r\n\r\npk =  pk1 || pk2\r\nsk = sk1 || sk2\r\n\r\nComposite signature value =  sig1 || sig2\r\n\r\n\r\nNo ASN1 anywhere.\r\n\r\nSo version -04 will be another breaking change.  ",
      "createdAt": "2024-11-06T11:12:30Z",
      "updatedAt": "2024-11-27T20:55:52Z",
      "closedAt": "2024-11-27T20:55:52Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue was resolved in #89  ",
          "createdAt": "2024-11-27T20:55:52Z",
          "updatedAt": "2024-11-27T20:55:52Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOL5eEDM6dXwmh",
      "title": "Prefix constant string to M' and add statement about attack detection",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/86",
      "state": "OPEN",
      "author": "falko-strenzke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the current proposal M' is starting with the OID. My suggestion is to prefix a \"magic\" constant of length of 16 or 32 bytes to the OID.\r\n\r\nThe reason is the following: In the case that a signature stripping attack is executed where the PQ signature is stipped of, the reamaining traditional signature is valid for the message M'. This amounts to a EUF-CMA violation (under consideration of cross-algorithm chosen message oracle queries).\r\nPrefixing the magic constant allows CMS implementations of the signature verification to perform attack detection by checking the start of the signed data to be equal to the magic string. Otherwise, the forged message cannot be detected and may cause harm in the receiving system.\r\n\r\nThe value of the attack detection mechanism should be mentioned in the text as well. In my view, it should be specified as a \"SHOULD\" feature.",
      "createdAt": "2024-11-07T08:28:20Z",
      "updatedAt": "2024-12-19T06:21:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "Alternatively, since RSA and ECDSA actually sign a hash, and everything else relevant has context inputs, one could do something like the follows to get actual strong non-separability (even for RSA and ECDSA):\r\n\r\nPure:\r\n\r\n`M' = Domain | 0 | len(ctx) | ctx | M`\r\n\r\nPrehashed:\r\n\r\n`M' = Domain | 1 | len(ctx) | ctx | HashOID | PH(M)`\r\n\r\nRSA:\r\n\r\n`RSA_signhash(cSHAKE256(M', ctx=\"sig-composite\"))`\r\n\r\nECDSA:\r\n\r\n`ECDSA_signhash(bytes2bits_be(cSHAKE256(M', ctx=\"sig-composite\")))`\r\n\r\nEd25519:\r\n\r\n`Ed25519ctx_sign(M', ctx=\"sig-composite\")`\r\n\r\nEd448:\r\n\r\n`Ed448_sign(M', ctx=\"sig-composite\")`\r\n\r\nML-DSA:\r\n\r\n`MLDSA_sign(M', ctx=\"sig-composite\")`\r\n\r\n\r\nSome notes:\r\n\r\n- The bytes2bits_be() is to ensure that ECDSA interprets the hash in the expected way.\r\n- This aligns with the model presented in the meeting.",
          "createdAt": "2024-11-07T10:13:35Z",
          "updatedAt": "2024-11-07T10:13:35Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Falko, the current version of composite signatures all use DER Encoded OIDs that start with HEX 060B6086480186FA6B50080 which could be considered the magic String you are talking about.   So we think this already meets the requirement you are asking about.   We acknowledge that the current OIDs will change, and will be assigned by IANA so it is likely they will become shorter.  For example in the IANA registry, it would be something like 1.2.840.113549.1.9.16.3.xx (where xx is the composite algorithms).   So 1.2.840.113549.1.9.16.3 can be considered the MAGIC string (DER encoded of course).  See https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml#security-smime-3  .   Does this satisfy your concern?",
          "createdAt": "2024-12-04T15:39:06Z",
          "updatedAt": "2024-12-04T15:39:06Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@falko-strenzke  I do not understand this sentence:\r\n> Prefixing the magic constant allows CMS implementations of the signature verification to perform attack detection by checking the start of the signed data to be equal to the magic string.\r\n\r\nThis magic prefix that you are talking about is only added by the construction of `M'` inside the Composite Sign(). This would not be carried over the wire in a CMS message because equally the Composite Verify() will add it while constructing `M'`. So I do not understand this suggestion.\r\n\r\n\r\n\r\n@ilaril we have considered this. Thank you for writing out what this would look like. \r\n\r\nWe decided against using the EdDSA ctx because many crypto libraries do not support this, and one of the design goals is to be able to use your existing (potentially certified / change-controlled) legacy crypto code as-is without modification. See #64 \r\n\r\nWe could add a wrapper to RSA and ECDSA as you suggest to bind a ctx, but since we are already adding `Domain` into `M'`, it's not clear to me that this is actually adding any new binding properties.",
          "createdAt": "2024-12-04T15:49:06Z",
          "updatedAt": "2024-12-04T15:50:29Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> This magic prefix that you are talking about is only added by the construction of `M'` inside the Composite Sign(). This would not be carried over the wire in a CMS message because equally the Composite Verify() will add it while constructing `M'`. So I do not understand this suggestion.\r\n\r\nHere the case of a stripping attack is relevant where the attacker removes the PQ signatures and leaves the traditional signature and changes the message to M'. The signature is then valid for M'. If M' starts with the magic sequence, that can be detected by the verifier.",
          "createdAt": "2024-12-05T15:24:12Z",
          "updatedAt": "2024-12-05T15:24:12Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> Falko, the current version of composite signatures all use DER Encoded OIDs that start with HEX 060B6086480186FA6B50080 which could be considered the magic String you are talking about. So we think this already meets the requirement you are asking about. We acknowledge that the current OIDs will change, and will be assigned by IANA so it is likely they will become shorter. For example in the IANA registry, it would be something like 1.2.840.113549.1.9.16.3.xx (where xx is the composite algorithms). So 1.2.840.113549.1.9.16.3 can be considered the MAGIC string (DER encoded of course). See https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml#security-smime-3 . Does this satisfy your concern?\r\n\r\nI don't think it does because\r\na) the prefix seems to be too short (currently 11 byte and you say could get shorter)\r\nb) it is not chosen at random (anyone signing an OID with this prefix would run into an error)\r\nc) I don't think there is any control that prevents the registration of OIDs with a different prefix in the future, e.g., proprietary OIDs",
          "createdAt": "2024-12-05T15:28:09Z",
          "updatedAt": "2024-12-05T15:28:56Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If M' starts with the magic sequence, that can be detected by the verifier.\r\n\r\nThis comment makes no sense to me.\r\n\r\nThe verifier takes as input `Composite-ML-DSA.Sign (sk, M, ctx)`, and it has `Domain` hard-coded.\r\n\r\nThen the verifier itself constructs `M' = Domain || len(ctx) || ctx || M`. `Domain` is a value hard-coded in the source code of the verifier, and pre-fixed to the message by the verifier. What possibly value is there in the verifier detecting something that it itself added? `M'` never goes over the wire.",
          "createdAt": "2024-12-11T15:07:13Z",
          "updatedAt": "2024-12-11T15:07:13Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok. Thanks Falko.  In regards to your comments:\r\na)  What is your recommended length (16 or 32 bytes or anything in between?).  Would using the byte representation of something like \"CompositeAlgorithmSignatures2025\" as a prefix be sufficient?  It is 32 bytes.  So we would have\r\n\r\nM' =  prefix || Domain || ctx.length || ctx || M\r\n\r\nb)  I'm not sure I understand.  You mention using a magic constant, so where does the randomness come into play?  If we used a random prefix, it would have to be stored as part of the signature itself so it could be verified.  \r\n\r\nc)  Yes, I agree, different OIDs with a different prefix could be registered in the future.   So having a prefix of specific length would prevent this.  \r\n\r\nSo I think I agree that a prefix at least guarantees a constant value that is of a specific length (you say 16 - 32 bytes) which I guess is 128 bits to 256 bits.   The only remaining question is why do we need this property?   Can you give a detailed example to help us understand please?",
          "createdAt": "2024-12-11T15:08:16Z",
          "updatedAt": "2024-12-11T15:08:16Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> > If M' starts with the magic sequence, that can be detected by the verifier.\r\n> \r\n> This comment makes no sense to me.\r\n> \r\n> The verifier takes as input `Composite-ML-DSA.Sign (sk, M, ctx)`, and it has `Domain` hard-coded.\r\n> \r\n> Then the verifier itself constructs `M' = Domain || len(ctx) || ctx || M`. `Domain` is a value hard-coded in the source code of the verifier, and pre-fixed to the message by the verifier. What possibly value is there in the verifier detecting something that it itself added? `M'` never goes over the wire.\r\n\r\nI wrote \"... and changes the message to `M'`\". This is why M' goes over the wire. Please look at the description I have given above. You are trying to map it to the verification of the composite algorithm, which is not relevant here.  The relevant case is the alteration to a message-signature pair that is valid under the standalone-scheme verification. In that case the forged message `M'` starts with the \"magic prefix\" which can be detected by the verifier.\r\n\r\n@ounsworth \r\n",
          "createdAt": "2024-12-16T09:08:16Z",
          "updatedAt": "2024-12-16T09:08:43Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Falko, I think the confusion is because you mention M' .   In Composite M' is defined as the message format of the Composite. \r\n\r\nM' = Domain || len(ctx) || ctx || M\r\n\r\nIt seems you are using M' to mean something slightly different.  I've  re-read you comment multiple times and am still trying to figure out what you mean.\r\n\r\n  \"Here the case of a stripping attack is relevant where the attacker removes the PQ signatures and leaves the traditional signature and changes the message to M'. The signature is then valid for M'. If M' starts with the magic sequence, that can be detected by the verifier.:\r\n\r\nSo I'm trying to follow what you are saying..  You say the attacker removes the PQ signatures and leaves the traditional signature.  So I think you mean:\r\n\r\ninstead of:\r\n mldsaSig = ML-DSA.Sign( mldsaSK, M', ctx=Domain )\r\n tradSig = Trad.Sign( tradSK, M' )\r\n\r\nPQ is stripped out and we just have the following traditional component:\r\n  tradSig = Trad.Sign( tradSK, M' )\r\n\r\nSo I think you are saying a regular traditional verifier would verify the stripped traditional signature by having an attacker compute M' (from M) and handing the traditional stripped signature and the constructed message:\r\nif not Trad.Verify( pk2, M', s2) then\r\n          output \"Invalid signature\"\r\n\r\nThe same thing could NOT be done with the ML-DSA PQ component because of the context.\r\n\r\n  \"If M' starts with the magic sequence, that can be detected by the verifier\"\r\n\r\n- I don't understand how the traditional verifier would detect this, it would know nothing about the composite magic sequence (unless you are advocating that traditional verifiers be updated with this knowledge to detect this kind of attack?).   The composite verifier would already fail because it would be expected 2 signature components and would only have 1.  \r\n\r\nSo please help me understand if I'm on the right track, or give us a more detailed explanation of how this works.  I am obviously missing something important that isn't obvious to me.  \r\n",
          "createdAt": "2024-12-18T14:49:56Z",
          "updatedAt": "2024-12-18T15:25:00Z"
        },
        {
          "author": "falko-strenzke",
          "authorAssociation": "NONE",
          "body": "> Hi Falko, I think the confusion is because you mention M' . In Composite M' is defined as the message format of the Composite.\r\n> \r\n> M' = Domain || len(ctx) || ctx || M\r\n> \r\n> It seems you are using M' to mean something slightly different. I've re-read you comment multiple times and am still trying to figure out what you mean.\r\n\r\nNo, the `M'` I refer to is the same one as you give above.\r\n> \r\n> \"Here the case of a stripping attack is relevant where the attacker removes the PQ signatures and leaves the traditional signature and changes the message to M'. The signature is then valid for M'. If M' starts with the magic sequence, that can be detected by the verifier.:\r\n> \r\n> So I'm trying to follow what you are saying.. You say the attacker removes the PQ signatures and leaves the traditional signature. So I think you mean:\r\n> \r\n> instead of: mldsaSig = ML-DSA.Sign( mldsaSK, M', ctx=Domain ) tradSig = Trad.Sign( tradSK, M' )\r\n> \r\n> PQ is stripped out and we just have the following traditional component: tradSig = Trad.Sign( tradSK, M' )\r\n\r\nYes, that is the attack I am referring to.\r\n\r\n> So I think you are saying a regular traditional verifier would verify the stripped traditional signature by having an attacker compute M' (from M) and handing the traditional stripped signature and the constructed message: if not Trad.Verify( pk2, M', s2) then output \"Invalid signature\"\r\n\r\nYes, the attacker replaces `M` with `M'` in the message.\r\n\r\n> \r\n> The same thing could NOT be done with the ML-DSA PQ component because of the context.\r\n\r\nExactly.\r\n\r\n> \r\n> \"If M' starts with the magic sequence, that can be detected by the verifier\"\r\n> \r\n> *  I don't understand how the traditional verifier would detect this, it would know nothing about the composite magic sequence (unless you are advocating that traditional verifiers be updated with this knowledge to detect this kind of attack?). \r\n\r\nExaclty, the implementation of the verifier would have to be updated to know the magic sequence and classify a message starting with it as an attack message.\r\n\r\n> The composite verifier would already fail because it would be expected 2 signature components and would only have 1.\r\n\r\nFor the verifier of a composite signature, in principle the inverse attack was possible: The attacker lets the signer sign two messages `M'_pq` and `M'_trad` with the PQ and the traditional scheme standalone, respectively. He makes up these two message exactly in the way so that they will later be valid messages when the two signatures are interpreted as component signatures of the composite scheme. Now, for the traditional scheme there is no hinderance to have `M'_trad` signed. For the PQ scheme, having `M'_pq` signed  is hindered by the fact that it would need to set a specific value of the context parameter, which the current version of draft-ietf-lamps-cms-ml-dsa does not allow: \"When using ML-DSA as described in this document, the context string is not used.\" So this attack is not applicable if draft-ietf-lamps-cms-ml-dsa is not changed in this respect. If the draft would be changed to allow the arbitrary values of the context parameter for standalone ML-DSA, the magic prefix could also be used to detect fadulent messages during signing, since the two `M'_...` messages of the component signatures would have to start with that magic prefix.\r\n\r\n",
          "createdAt": "2024-12-19T06:18:11Z",
          "updatedAt": "2024-12-19T06:21:54Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOL5eEDM6eYPqF",
      "title": "Change the key reuse from NOT RECOMMENDED to MUST NOT",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/87",
      "state": "OPEN",
      "author": "sophieschmieg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current key reuse sections merely does NOT RECOMMEND reusing old key material, citing the domain separators added as a defense against out of context (signature stripping) attacks.\r\n\r\nHowever, a domain separator MUST be chosen from a prefix-free set, and in this case we are trying to domain separate against the classical use, which does not include a domain separator at all, i.e. has the empty string as a domain prefix.\r\n\r\nThe empty string is a prefix of every string, therefore there is no secure way of domain separating the hybrid.\r\n\r\nThe only alternative I see to a MUST NOT on key reuse is including a domain separator for the classical use case as well, but this will be a breaking change for old clients, and if you introduce a breaking change, you might as well just use a new key instead.\r\n\r\nTherefore, I would like us to step up the language from RECOMMEND to MUST.",
      "createdAt": "2024-11-14T00:00:32Z",
      "updatedAt": "2024-11-14T00:00:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 88,
      "id": "I_kwDOL5eEDM6fN2Xc",
      "title": "Editorial changes to version 3",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/88",
      "state": "CLOSED",
      "author": "PiotrPopis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have the following proposed editing changes to\r\n[draft-ietf-lamps-pq-composite-sigs-03.txt]:\r\n1. Title\r\n> Composite ML-DSA For use in X.509 Public Key Infrastructure and CMS\r\n\r\nComposite ML-DSA for use in X.509 Public Key Infrastructure and CMS\r\n2. Section 3\r\n> separablity\r\n\r\nseparability\r\n3. Section 4.2.2\r\n> conisting\r\n\r\nconsisting\r\n4. Section 4.2.2 and 4.3.2\r\n> A placeholder for the specific ML-DSA algorithm and\r\n           parameter set to use, for example \"RSASA-PSS with id-sha256\"\r\n           or \"Ed25519\".\r\n\r\nA placeholder for the specific traditional algorithm and\r\n           parameter set to use, for example \"RSASA-PSS with id-sha256\"\r\n           or \"Ed25519\".\r\n5. Section 4.3 and 4.3.1\r\n> In the pre-hash mode the Domain separator Section 7.3 is concatenated\r\n> (...)\r\n\r\nIn the pre-hash mode the Domain separator (see Section 7.3) is concatenated\r\n(...)\r\n6. Section 4.3.1\r\n> This mode mirrors HashML-DSA.Sign(sk, M, ctx, PH) defined in Section 5.4.1\r\n> of [FIPS.204].\r\n\r\nThis mode mirrors HashML-DSA.Sign(sk, M, ctx, PH) defined in Algorithm 4\r\n   in Section 5.4.1 of [FIPS.204].\r\nRationale: similar to Section 4.2.2.\r\n7. Section 5.1\r\n> For use with this document, ML-DSA keys MUST be be the raw BIT STRING\r\n   representation as specified in (...)\r\n\r\nFor use with this document, ML-DSA keys MUST be the raw BIT STRING\r\n   representation as specified in (...)\r\n8. Section 5.4\r\nI suggest considering changing nonRepudiation to contentCommitment as it is\r\nmore in line with the current version of RFC 5280.\r\n9. Section 6.2\r\n> encoing\r\n\r\nencoding\r\n10. Section 7.1\r\n> Composite-ML-DSA Algorithm Identifiers\r\n\r\nPureComposite-ML-DSA Algorithm Identifiers\r\nRationale: similar to Section 7.2.\r\n11. Section 7.2\r\n> The Pre-Hash algorithm is used as the PH algorithm in and the DER Encoded\r\n> OID value (...)\r\n\r\nThe Pre-Hash algorithm is used as the PH algorithm and the DER Encoded OID\r\nvalue (...)\r\n12. Section 7.4\r\n> At the higher security levels of pre-hashed Composite ML-DSA, for\r\n   example id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512, the 384-bit\r\n   elliptic curve component is used with SHA2-384 is its pre-hash (i.e.\r\n   the pre-hash that is considered to be internal to the ECDSA\r\n   component), yet SHA2-512 is used as the pre-hash for the overall\r\n   composite because in this case the pre-hash must not weaken the ML-\r\n   DSA-87 component against a collision attack.\r\n\r\nAt the higher security levels of pre-hashed Composite ML-DSA, for\r\n   example id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512, the 384-bit\r\n   elliptic curve component is used with SHA2-384 which is its pre-hash\r\n(i.e. the pre-hash that is considered to be internal to the ECDSA\r\n   component), yet SHA2-512 is used as the pre-hash for the overall\r\n   composite because in this case the pre-hash must not weaken the ML-\r\n   DSA-87 component against a collision attack.\r\nRationale: adding \"which\" seems reasonable to me, but I'm not a native\r\nEnglish speaker, so maybe my suggestion is inappropriate (I'm not sure).\r\n\r\nRegards - Piotr Popis",
      "createdAt": "2024-11-19T08:08:45Z",
      "updatedAt": "2024-11-29T19:49:45Z",
      "closedAt": "2024-11-29T19:49:44Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Peter, I added your suggested changes.   We are going to remove the HashComposite-ML-DSA in favor of use of the external mu from FIPS 204 Algorithm 7 step 6.  ",
          "createdAt": "2024-11-29T19:49:44Z",
          "updatedAt": "2024-11-29T19:49:44Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDOL5eEDM6gBkyw",
      "title": "Remove HashComposite-ML-DSA in place of external mu+tradhash",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/90",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Much discussion has happened at IETF around making use of the external mu in ML-DSA (Algorithm 7, line 6 of FIPS 204).   This allows the hash of the message to be calculated externally while producing the same output as in Algorithm 4 of FIPS 204.   This means we no longer have a need to support the Hash ML-DSA...   This will reduce the number of OIDS by half which is good.   \r\n\r\nQuestion is do we actually need to do anything other than remove Hash Composite ML-DSA?    Probably a paragraph explaining that it can be used could be added.  ",
      "createdAt": "2024-11-22T22:29:43Z",
      "updatedAt": "2024-12-04T16:01:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Ed448 and X25519 use pre-hash modes controlled by OIDs, so if HashComposite-ML-DSA is removed, there will not be a way to use pre-hashing with Ed448 and X25519.    \r\n",
          "createdAt": "2024-12-04T16:01:22Z",
          "updatedAt": "2024-12-04T16:01:22Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOL5eEDM6iARI7",
      "title": "Extra example for key reuse",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/92",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The question then is whether an attacker could take a messages signed by {PQ, RSA} and by simply dropping a signature make it appear to have been signed by either the {RSA} or {PQ} cert, and thus be processed under a different verifier policy?  The obvious counter-argument is that if you can break RSA then why do you need to tamper with an originally-valid message, why not just forge a completely new message? An example would be that you can't yet fully break RSA, but you want to force a downgrade so that an S/MIME reply is only encrypted with RSA instead of the hybrid and thus you can file it away for eventual harvest-now-decrypt-later.",
      "createdAt": "2024-12-04T14:44:47Z",
      "updatedAt": "2024-12-04T14:44:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 94,
      "id": "I_kwDOL5eEDM6jHTjY",
      "title": "ML-DSA Private key sizes 32bytes or expanded?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/94",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think more discussion is needed about whether the private key format should allow the expanded format as well as the seed.   If an implementation only had access to the expanded format, and needed to export the key, then it may not have access to the seed.   If there is no way to support this in a reasonable way, then there WILL be operational issues down the road.\r\n\r\n- Max suggests we could have a separate section for the private key.   For the traditional component, if we know the keysize, we can look for 32+trad or expanded mldsa+ trad and know which one to use.   That would be more efficient than using the first 32 bytes, expanding them (which will work even if the key is already expanded).\r\n\r\n",
      "createdAt": "2024-12-12T18:21:28Z",
      "updatedAt": "2024-12-12T18:21:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 96,
      "id": "I_kwDOL5eEDM6kH_c6",
      "title": "Many of the composite signatures lower the security of ML-DSA from SUF-CMA to EUF-CMA",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/96",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "**John Preu\u00df Mattsson:**\r\nI dislike that the document creates EUF-CMA composites of the SUF-CMA ML-DSA and makes is sound like the composites are better. The abstract states:\r\n\r\n\"These combinations are tailored to meet security best practices\"\r\n\"where the operator wants extra protection\"\r\n\r\nWhile there has been a lot of PQC discussions regarding new exotic security properties of debatable practical value, SUF-CMA is not a new exotic property. It is best practice and the IETF standardized version of EdDSA and the NIST standardized ML-DSA are both SUF-CMA. Users and developers are known to expect signatures to be SUF-CMA and developers believing EUF-CMA signatures to be SUF-CMA have caused significant vulnerabilities in the past.  https://en.bitcoin.it/wiki/Transaction_malleability\r\n\r\nMy preference would be that IETF does not standardize any EUF-CMA composites of the SUF-CMA ML-DSA. If this is done anyway, the fact that some of the composites weakens security properties compared to standalone ML-DSA must be very clear and mentioned together with any claims of improved security, which would currently be in the abstract. Wheater a composite is SUF-CMA and EUF-CMA should be clearly marked.\r\n\r\n**Bas Westerbaan:**\r\nAgreed.\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/f9yHqaXnze4qNubvDa0OkVUcoNY/\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/GzjPEaNgKDb9_trgeFkvXLc-Cho/\r\n",
      "createdAt": "2024-12-20T22:15:23Z",
      "updatedAt": "2024-12-20T22:15:23Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 8,
      "id": "PR_kwDOL5eEDM5xs5E5",
      "title": "Update tov13",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/8",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Added back the v13 changes\r\n- Fixed issues #2 and #3\r\n- Added changes since adoption section\r\n- Added Scott Fluher as an auther",
      "createdAt": "2024-06-06T16:03:49Z",
      "updatedAt": "2024-06-20T03:19:17Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "de8244a96beb9000d84c6979a2fcc913c4d32719",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "UpdateTov13",
      "headRefOid": "ad27c830706d2d34ba4a92cefca15b440adda3f5",
      "closedAt": "2024-06-06T16:05:02Z",
      "mergedAt": "2024-06-06T16:05:02Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "b7f6a91cd28f8324904466b4e2911495ace19023"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOL5eEDM5x9jYU",
      "title": "Fix typos",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/12",
      "state": "CLOSED",
      "author": "jiep",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-10T11:09:06Z",
      "updatedAt": "2024-07-03T20:50:35Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "b7f6a91cd28f8324904466b4e2911495ace19023",
      "headRepository": "jiep/draft-composite-sigs",
      "headRefName": "patch-1",
      "headRefOid": "43070ba61ceae7b528446d32a5113785157b696a",
      "closedAt": "2024-07-03T20:50:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We merged your comments separately.   We changed the n to 2 as you suggested, we reworded the about the y bitstrength, and we looked up what NIST used in their documents and they used ML-DSA-44 (for example), so we will continue to use that one.    Thank you so much for your comments and suggestions.  We also added you to the acknowledgement section at the end of the document.  ",
          "createdAt": "2024-07-03T20:49:46Z",
          "updatedAt": "2024-07-03T20:49:46Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "As mentioned above, we manually merged your comments and made some suggested wording changes.  ",
          "createdAt": "2024-07-03T20:50:34Z",
          "updatedAt": "2024-07-03T20:50:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOL5eEDM5zAHxz",
      "title": "4 signed info use in cms",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/13",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge the changes for #4 into the main branch.   Reviewed and edits by the authors group.\r\n\r\nAdded a \"Use in CMS\" section\r\nRemoved a Falon reference from the ASN.1 document (which was a typo in reference to Falcon)\r\nAdded SMIME-CAPS into the sa-CompositeSignature definition in the ASN.1 module\r\nFixed nits and other typos",
      "createdAt": "2024-06-19T20:36:44Z",
      "updatedAt": "2024-06-20T03:19:09Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "d59d73da181cf23f8ecce17f7daf8c5a0e310fc3",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "4-signedInfo-UseInCMS",
      "headRefOid": "b4cf50eafb96d85c0d49cc067c3507bfad5b68f6",
      "closedAt": "2024-06-19T20:38:30Z",
      "mergedAt": "2024-06-19T20:38:30Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "1c4f87224c9dc3c2850bd64d0e9f478635e659e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOL5eEDM50kQkB",
      "title": "Add appendix with component algorithm references",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/16",
      "state": "MERGED",
      "author": "janklaussner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* appendix with references of signature, curves and hashes\r\n* updated section 'Algorithm Identifiers' with reference to appendix and IDs of component algorithms\r\n* updated algorithm description for signature generation and verification to use Domain separator",
      "createdAt": "2024-07-05T21:00:55Z",
      "updatedAt": "2024-07-08T15:43:37Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "e89f78848179101641dbbe3d02447fde62831570",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "7-add-a-new-section-explicitely-list-spki-algids",
      "headRefOid": "7d649b8eb7e445921aeea6633571e8420d2c4f2d",
      "closedAt": "2024-07-08T15:43:37Z",
      "mergedAt": "2024-07-08T15:43:37Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "4b8da2388ecca2b2930400f0df5462ad901156e2"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a good start, but since these are fixed values, I think we should actually provide HEX DER encoded AlgorithmIDs for each row, then there is absolutely no ambiguity.",
          "createdAt": "2024-07-07T15:23:40Z",
          "updatedAt": "2024-07-07T15:23:40Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, once we have this sorted out here, we will need to do the same in composite-kems: https://github.com/lamps-wg/draft-composite-kem/issues/20",
          "createdAt": "2024-07-07T15:24:33Z",
          "updatedAt": "2024-07-07T15:24:33Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is a good start, but since these are fixed values, I think we should actually provide HEX DER encoded AlgorithmIDs for each row, then there is absolutely no ambiguity.\r\n\r\nYou mean in the appendix? These values are not fed into the signature, they just help to identify the component algorithm used. Is your point that providing DER OID values instead of ASN.1 OIDs helps the implementer with this?",
          "createdAt": "2024-07-08T07:52:50Z",
          "updatedAt": "2024-07-08T07:52:50Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "@ounsworth  I don't understand why we would need to put hex encodings of the OIDS for the component signatures.  They are not used during the signature computation process.   We already hex encode the composite OIDs themselves which is a representation of the entire composite algorithm.  I think what Jan has here is fine.",
          "createdAt": "2024-07-08T12:32:08Z",
          "updatedAt": "2024-07-08T12:32:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6A911N",
          "commit": {
            "abbreviatedOid": "cdc6e20"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-08T15:32:26Z",
          "updatedAt": "2024-07-08T15:32:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOL5eEDM50n1iX",
      "title": "Addressing CW comments",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/18",
      "state": "MERGED",
      "author": "opencrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addressing CW comments in the different sections.",
      "createdAt": "2024-07-07T22:39:55Z",
      "updatedAt": "2024-07-08T16:54:59Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "4b8da2388ecca2b2930400f0df5462ad901156e2",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "1-carl-wallaces-comments-on-composite-signatures-v13",
      "headRefOid": "df9ef9eafbe77a8f4cc5f5787924d02fbba603ac",
      "closedAt": "2024-07-08T16:54:59Z",
      "mergedAt": "2024-07-08T16:54:59Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "ac890f5c4f5bd2561df3c53a97b312bce0327023"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOL5eEDM5545xm",
      "title": "Added context string consideration",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/38",
      "state": "CLOSED",
      "author": "feventura",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added context string consideration, as defined in #35.",
      "createdAt": "2024-08-29T20:50:57Z",
      "updatedAt": "2024-10-09T17:08:30Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "a20cd4c3183dba03c885b64ddab03e5fc0951562",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "issue-35",
      "headRefOid": "2957443d71c8085b3e52963004ac748d3282972a",
      "closedAt": "2024-10-09T17:08:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do not merge, we decided to do this differently. See comments #42 ",
          "createdAt": "2024-09-25T14:38:47Z",
          "updatedAt": "2024-09-25T14:38:47Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "All the changes in this pull request are now in #59 which will eventually get pushed to main",
          "createdAt": "2024-10-09T17:08:30Z",
          "updatedAt": "2024-10-09T17:08:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6MGYXR",
          "commit": {
            "abbreviatedOid": "6351668"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-10-06T08:40:28Z",
          "updatedAt": "2024-10-06T09:21:19Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Where does this IF statement come from? I don't see an equivalent in FIPS 204 in either Algorithm 2 or Algorithm 7. I appreciate the attempt at error-handling, but I'm not sure that this notation really works because FIPS 204 talks about returning an error or \"\u22a5\", but does not talk about returning NULL. I will replace this with an English sentence about error handling.",
              "createdAt": "2024-10-06T08:40:28Z",
              "updatedAt": "2024-10-06T09:21:19Z"
            },
            {
              "originalPosition": 173,
              "body": "Which \"section on pre-hashing the message\" is this referring to? I don't see one.",
              "createdAt": "2024-10-06T09:18:32Z",
              "updatedAt": "2024-10-06T09:21:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOL5eEDM57K0KL",
      "title": "Update version to use ML-DSA standard version",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/41",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Upped the version of the OIDs and domain separators.\r\nCloses #37 ",
      "createdAt": "2024-09-11T14:10:02Z",
      "updatedAt": "2024-09-24T21:46:02Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "0c5ced7b63a14467cb501eb415cdcb5b7cdc90b4",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mldsa-standardized",
      "headRefOid": "1fa995acb090cbe7fc4a7d020fc5257591e7fd50",
      "closedAt": "2024-09-24T21:45:58Z",
      "mergedAt": "2024-09-24T21:45:58Z",
      "mergedBy": "ounsworth",
      "mergeCommit": {
        "oid": "66252f92269a84a03b02c3f00b70911a4698ca70"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good. I'm gonna merge this so that other changes can be done in top of it.",
          "createdAt": "2024-09-24T21:45:54Z",
          "updatedAt": "2024-09-24T21:45:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOL5eEDM58k0AM",
      "title": "Updated ASN.1 module as per Carl's suggestion",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/47",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Closes #9",
      "createdAt": "2024-09-24T21:44:18Z",
      "updatedAt": "2024-10-10T10:36:15Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "66252f92269a84a03b02c3f00b70911a4698ca70",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mikeo_asn1_9",
      "headRefOid": "0b30ff1595e77c20d4187cd6e5a8bd5f8291f1d2",
      "closedAt": "2024-09-25T18:56:42Z",
      "mergedAt": "2024-09-25T18:56:42Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "23586b756da5d59a4956ab068952f524c596bbb7"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to add a 3rd version of EcCompositeSignaturePublicKey called EdCompositeSignaturePublicKey because EdDSA public keys are not EcPoint. See #48 ",
          "createdAt": "2024-09-25T14:43:43Z",
          "updatedAt": "2024-09-25T14:43:43Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "closes #20 ",
          "createdAt": "2024-09-25T15:06:32Z",
          "updatedAt": "2024-09-25T15:06:32Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closes #48 ",
          "createdAt": "2024-09-25T16:42:10Z",
          "updatedAt": "2024-09-25T16:42:10Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I checked that the ASN.1 module compiles in asn.1 playground.",
          "createdAt": "2024-09-25T17:36:03Z",
          "updatedAt": "2024-09-25T17:36:03Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Closes #48",
          "createdAt": "2024-10-10T10:36:13Z",
          "updatedAt": "2024-10-10T10:36:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOL5eEDM58suj2",
      "title": "Add Mike's changes into my pull request",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/50",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add Mike's changes from main into this branch.",
      "createdAt": "2024-09-25T19:01:07Z",
      "updatedAt": "2024-09-25T19:04:30Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "22-24AlgorithmCombos",
      "baseRefOid": "ba287064993e60212a3aaa42c05f941a9b9a3f47",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "main",
      "headRefOid": "23586b756da5d59a4956ab068952f524c596bbb7",
      "closedAt": "2024-09-25T19:04:30Z",
      "mergedAt": "2024-09-25T19:04:30Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "555ae7c131ca2b62a9c279b357b53336eac93df5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOL5eEDM58s20C",
      "title": "22 24 algorithm combos",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/51",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-25T19:14:28Z",
      "updatedAt": "2024-09-25T19:18:24Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "23586b756da5d59a4956ab068952f524c596bbb7",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "22-24AlgorithmCombos",
      "headRefOid": "93b61dda6ce6958ffcbe29312116d328292c4b3f",
      "closedAt": "2024-09-25T19:18:24Z",
      "mergedAt": "2024-09-25T19:18:24Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "caa9a901e51fe82c5ad60f967bae86b228ef9433"
      },
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Add support for new RSA 4096 combinations",
          "createdAt": "2024-09-25T19:18:13Z",
          "updatedAt": "2024-09-25T19:18:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOL5eEDM58wVhl",
      "title": "Update ML-DSA and ECC combinations",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/52",
      "state": "MERGED",
      "author": "janklaussner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- remove ML-DSA-44 brainpool-256 combination\r\n- changed ML-DSA-65 NIST combination from 256 to 384\r\n- updated combinations rational",
      "createdAt": "2024-09-26T08:00:48Z",
      "updatedAt": "2024-10-02T15:29:42Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "caa9a901e51fe82c5ad60f967bae86b228ef9433",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "26-nist-is-suggesting-that-both-pq-l3-+-l5-should-be-paired-with-p-384",
      "headRefOid": "6950d8e5ae0449c618aaec838d2dce19a5363c84",
      "closedAt": "2024-10-02T15:29:30Z",
      "mergedAt": "2024-10-02T15:29:30Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "a20cd4c3183dba03c885b64ddab03e5fc0951562"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janklaussner  I think you missed updated the ASN.1 module in the file `Composite-MLDSA-2024.asn`.\r\nUPDATE: I have added a commit to this PR that changes the ASN.1 module. Please review for mistakes.",
          "createdAt": "2024-09-26T18:43:32Z",
          "updatedAt": "2024-09-26T18:47:21Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Reviewed by authors group!  Great Job!",
          "createdAt": "2024-10-02T15:28:51Z",
          "updatedAt": "2024-10-02T15:28:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 53,
      "id": "PR_kwDOL5eEDM581cUa",
      "title": "Removing security consideration section Public Key Algorithm Selectio\u2026",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/53",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026n Criteria because it no longer aligns.",
      "createdAt": "2024-09-26T18:41:37Z",
      "updatedAt": "2024-10-17T19:26:21Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "ed1ffd6d64819c36572fa3baf0dfe059ef549e8f",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mikeo_selection_criteria",
      "headRefOid": "6a18dfedb4638e7d2d260479713dc8a955096312",
      "closedAt": "2024-10-17T19:26:21Z",
      "mergedAt": "2024-10-17T19:26:21Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "db3a6aed31c61bec8ed71b71d0535a7011745932"
      },
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group will resolve conflicts and remove",
          "createdAt": "2024-10-09T14:46:59Z",
          "updatedAt": "2024-10-09T14:46:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOL5eEDM581oI0",
      "title": "Added a security consideration about key reuse",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/54",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #49 \r\nCloses #46\r\n\r\nRelated to, but does not fully address #27 ",
      "createdAt": "2024-09-26T19:11:34Z",
      "updatedAt": "2024-10-16T14:46:34Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "caa9a901e51fe82c5ad60f967bae86b228ef9433",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mikeo_key_reuse",
      "headRefOid": "60e83ba5a3786e94ae0c86043ef45a6f46757e28",
      "closedAt": "2024-10-16T12:58:19Z",
      "mergedAt": "2024-10-16T12:58:19Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "e727467211be0c1b25fc418c097d8de48eeb91ae"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closes #27 ",
          "createdAt": "2024-09-30T15:54:22Z",
          "updatedAt": "2024-09-30T15:54:22Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After several rounds of back-and-forth with Britta, Falko, and Markku about the EUF-CMA properties, I think this PR is ready to me merged.",
          "createdAt": "2024-10-11T10:32:18Z",
          "updatedAt": "2024-10-11T10:32:18Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merge it!",
          "createdAt": "2024-10-15T19:18:42Z",
          "updatedAt": "2024-10-15T19:18:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6LW7Xf",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T16:21:44Z",
          "updatedAt": "2024-09-30T16:21:44Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "The draft does not provide SNS though. I recommend the following change:\r\n\r\nThe signature combiner defined in this document achieves both Weak Non-Separability and Strong Non-Separability as defined in {{I-D.ietf-pquip-hybrid-signature-spectrums}}. Consider a composite signature, message pair `(\\sigma, M)` which is actually `((\\sigma1, \\sigma2), M)`. Weak Non-Separability is trivially obtained since evidence of the hybrid is left behind since the pair `(\\sigma1, M)` will not verify under the first component key, but rather only `(\\sigma2, Domain || M)` which binds the domain separator of the composite algorithm that was used. \r\n\r\nExistential Unforgeability under a Chosen Message Attack (EUF-CMA) for the composite signature algorithm as a whole, is conditioned on the algorithm identifier being per specification used as defined, namely that `Domain || M` is the expected format that the verification algorithm will check to validate under the component algorithms. Thus there is a policy mechanism enforced by the verifier. Within protocols that use X.509 certificates, the certificate will dictate that the signature is associated with a composite public key, and so barring key reuse (discussed in {{sec-cons-key-reuse}}), this provides the necessary binding for both Weak Non-Separabality and EUF-CMA security.",
              "createdAt": "2024-09-30T16:21:44Z",
              "updatedAt": "2024-09-30T16:21:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LW9lc",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T16:26:22Z",
          "updatedAt": "2024-09-30T16:26:22Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Typo: catastrophic \r\n\r\nRecommended edit: When using single-algorithm cryptography, the best practice is to always generate fresh key material for each purpose, for example when renewing a certificate, or obtaining both a TLS and S/MIME certificate for the same device, however in practice key reuse in such scenarios is not always catastrophic to security and therefore often tolerated, despite cross-protocol attacks having been shown.  (suggested citation here)",
              "createdAt": "2024-09-30T16:26:22Z",
              "updatedAt": "2024-09-30T16:26:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LW-G-",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T16:27:28Z",
          "updatedAt": "2024-09-30T16:27:28Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Also recommended to remove the following:\r\n\r\nWith composite keys we have a much stricter security requirement. However this reasoning does not hold in the PQ / Tradational hybrid setting.",
              "createdAt": "2024-09-30T16:27:28Z",
              "updatedAt": "2024-09-30T16:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LXAVJ",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T16:32:18Z",
          "updatedAt": "2024-09-30T16:32:18Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Typo: sigle-algorithm -> single-algorithm\r\n\r\nRecommended edit: \r\nFor example, it might be tempting for an operator to take an already-deployed RSA key pair and combine it with an ML-DSA key pair to form a hybrid key pair for use in a hybrid algorithm. Within a hybrid signature context this leads to a class of attacks referred to as \"stripping attacks\" discussed in {{sec-cons-non-separability}} and may also open up risks from further cross-protocol attacks. Despite the weak non-separability property offered by the composite signature combiner, it is still RECOMMENDED to avoid key reuse as key reuse in single-algorithm use cases could introduce EUF-CMA vulnerabilities.  ",
              "createdAt": "2024-09-30T16:32:18Z",
              "updatedAt": "2024-09-30T16:32:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LXBJQ",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T16:34:07Z",
          "updatedAt": "2024-09-30T16:34:07Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Recommended edit to remove clause (and fix typos):\r\n\r\nTherefore, it is RECOMMENDED to avoid key reuse and always generate fresh component keys for a new composite. It is also RECOMMENDED that CAs performing revocation checks on a composite key should also check both component keys independently.",
              "createdAt": "2024-09-30T16:34:07Z",
              "updatedAt": "2024-09-30T16:34:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LYrHR",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T20:26:15Z",
          "updatedAt": "2024-09-30T20:26:15Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Could you please explain why this draft doesn't provide SNS? That was the whole reason we added the domain separator. Is it not true that it provides \"SNS except for the one pair (\\sigma1, Domain || M) ?",
              "createdAt": "2024-09-30T20:26:15Z",
              "updatedAt": "2024-09-30T20:26:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LYrZC",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T20:26:57Z",
          "updatedAt": "2024-09-30T20:26:57Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I grabbed your updated paragraph.",
              "createdAt": "2024-09-30T20:26:57Z",
              "updatedAt": "2024-09-30T20:26:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LYr1q",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T20:28:08Z",
          "updatedAt": "2024-09-30T20:28:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I grabbed your updated paragraph.\r\n\r\nDo you have a citation in mind? Some fishing around on Google Scholar, this looks close, but probably not an exact hit for this sentence:\r\n\r\nhttps://www.usenix.org/conference/usenixsecurity19/presentation/muller",
              "createdAt": "2024-09-30T20:28:08Z",
              "updatedAt": "2024-09-30T20:28:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LYs0O",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T20:30:36Z",
          "updatedAt": "2024-09-30T20:30:37Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Thanks.",
              "createdAt": "2024-09-30T20:30:37Z",
              "updatedAt": "2024-09-30T20:30:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LYtQL",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T20:31:42Z",
          "updatedAt": "2024-09-30T20:31:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Thanks.",
              "createdAt": "2024-09-30T20:31:42Z",
              "updatedAt": "2024-09-30T20:31:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LZPjR",
          "commit": {
            "abbreviatedOid": "de589b7"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-30T21:50:17Z",
          "updatedAt": "2024-09-30T21:50:17Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nWithin the broader context of PQ / Traditional hybrids, we need to consider new attack surfaces that arise due to the hybrid constructions and did not exist in single-algorithm contexts. One of these is key reuse where the component keys within a hybrid are also used by themselves within a single-algorithm context. For example, it might be tempting for an operator to take an already-deployed RSA key pair and combine it with an ML-DSA key pair to form a hybrid key pair for use in a hybrid signature construction. Within a hybrid signature context this leads to a class of attacks referred to as \"stripping attacks\" discussed in {{sec-cons-non-separability}} and may also open up risks from further cross-protocol attacks. Despite the weak non-separability property offered by the composite signature combiner, it is still RECOMMENDED to avoid key reuse as key reuse in single-algorithm use cases could introduce EUF-CMA vulnerabilities.\r\n```",
              "createdAt": "2024-09-30T21:50:17Z",
              "updatedAt": "2024-09-30T21:50:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LaVUL",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T00:58:28Z",
          "updatedAt": "2024-10-01T00:58:29Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Sure - SNS would (cryptographically) result in failure of verification if separation occurred. Anything that relies on policy cannot in fact achieve that - if an implementation could be tricked into using a single component public key to verify and given a stripped signature, that signature might verify in this case as there is no cryptographic binding in the algorithm. \r\n\r\nThe domain separator could help a policy that knows to check this and does provide an artifact if separated (so WNS). ",
              "createdAt": "2024-10-01T00:58:29Z",
              "updatedAt": "2024-10-01T00:58:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LaXCH",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-01T01:08:27Z",
          "updatedAt": "2024-10-01T01:08:27Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The 'nine lives of bleichenbacher's cat' paper by Ronen et al covered key reuse across several different servers (I am not sure if you want to use that one though). ALPACA attacks may be an example of what you mean https://informatik.rub.de/neuigkeiten/nds/alpaca-attack-cross-protocol-attacks/",
              "createdAt": "2024-10-01T01:08:27Z",
              "updatedAt": "2024-10-01T01:08:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LlfpT",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T03:56:48Z",
          "updatedAt": "2024-10-02T03:56:48Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "The enforcement is handled at the cryptoAPI layer, which is essentially the composite signature algorithm boundary itself.  For a violation to occur the \"black box\" composite signature algorithm verifier would have to be implemented incorrectly.  How is that any different than a bad implementation of any existing algorithm?    If I can trick someone into trusting a malicious verifier (for any algorithm), then the same thing happens.  Its easy to write a bad verifier for any existing algorithm, I just return true.  ",
              "createdAt": "2024-10-02T03:56:48Z",
              "updatedAt": "2024-10-02T03:56:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6Llh9Z",
          "commit": {
            "abbreviatedOid": "de589b7"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T04:12:18Z",
          "updatedAt": "2024-10-02T04:12:18Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I like this comment, but we already prohibit the re-use of keys in this draft in numerous places.   So I actually think the RECOMMENDED is not strong enough.\r\n\r\nSection 4.1: \r\n\" The key generation functions MUST be executed for both algorithms.\r\n   Compliant parties MUST NOT use or import component keys that are used\r\n   in other contexts, combinations, or by themselves (i.e., not only in\r\n   X.509 certificates).\"\r\n\r\nSection 5.2:\r\n\" Component keys of a CompositeSignaturePublicKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\"\r\n\r\nSection 5.3:\r\n\"Component keys of a CompositeSignaturePrivateKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\"\r\n\r\nSection 11.3:\r\n\"This specification assumes that all of the component keys within\r\n       a composite key are freshly generated for the composite; ie a\r\n       given public key MUST NOT appear as a component within a\r\n       composite key and also within single-algorithm constructions.\"\r\n\r\nPerhaps a supplementary sentence added to the above:\r\n\r\n\"Despite the weak non-separability property offered by the composite signature combiner, it is still RECOMMENDED to avoid key reuse as key reuse in single-algorithm use cases could introduce EUF-CMA vulnerabilities.  That is why this specification mandates that component keys MUST NOT be used in any other context.\"\r\n",
              "createdAt": "2024-10-02T04:12:18Z",
              "updatedAt": "2024-10-02T04:12:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6LliX2",
          "commit": {
            "abbreviatedOid": "53cd54a"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-02T04:15:11Z",
          "updatedAt": "2024-10-02T04:15:12Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "One is cryptographic and the other is in policy. It is like the difference between the asymptotic improbability of finding a hash collision vs mandating two different values, or the computational security infeasibility of breaking IND-CPA to distinguish plaintext from random vs a confidentiality policy mandating that no one read a cleartext message. Unlike the latter of each case, the former ones offer a mathematical assurance.\r\n\r\nSNS is not about creation of a malicious verifier that skips verification, it is about a mathematical boundary that two signatures either verify or not, but it is computationally infeasible to verify only one. ",
              "createdAt": "2024-10-02T04:15:11Z",
              "updatedAt": "2024-10-02T04:15:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOL5eEDM587uXQ",
      "title": "Clarified AlgIDs for component private keys.",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/56",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #55",
      "createdAt": "2024-09-27T14:51:44Z",
      "updatedAt": "2024-10-19T23:16:19Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "caa9a901e51fe82c5ad60f967bae86b228ef9433",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mikeo_private_key_oid",
      "headRefOid": "34e828882f1c2f8345eeba542cabf7418a27c1e1",
      "closedAt": "2024-10-19T23:16:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "opencrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this pull request shall be merged. Besides the fact that it reference KEM algorithms, I completely disagree with using wrong algorithm identifiers for the components. This is, to me, completely wrong and I vote for NOT MERGING this pull request. More and more it feels like we are over-engineering what already works fine and allows for the re-use of existing code. We should not change the OneAsymmetric key standard (please!).",
          "createdAt": "2024-10-14T17:32:53Z",
          "updatedAt": "2024-10-14T17:34:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOL5eEDM59YMnJ",
      "title": "Add DER ancodings of SPKI and Signature algorithm Identifiers.",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/57",
      "state": "MERGED",
      "author": "janklaussner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-02T13:37:08Z",
      "updatedAt": "2024-10-17T19:41:17Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "db3a6aed31c61bec8ed71b71d0535a7011745932",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "7-add-a-new-section-explicitely-list-spki-algids-1",
      "headRefOid": "a404601651eb8e0bc1f33afb39d45f20b6b12236",
      "closedAt": "2024-10-17T19:41:10Z",
      "mergedAt": "2024-10-17T19:41:10Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "4da7ef18f0aac498de1db978f6170b28be734584"
      },
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@ounsworth , @johngray-dev this PR is ready for review...",
          "createdAt": "2024-10-14T16:42:38Z",
          "updatedAt": "2024-10-14T16:42:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6NbaQw",
          "commit": {
            "abbreviatedOid": "0483143"
          },
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T14:56:08Z",
          "updatedAt": "2024-10-16T15:01:21Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "wrong id",
              "createdAt": "2024-10-16T14:56:08Z",
              "updatedAt": "2024-10-16T15:01:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6Nbiqd",
          "commit": {
            "abbreviatedOid": "0483143"
          },
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T15:08:15Z",
          "updatedAt": "2024-10-16T15:08:15Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "done",
              "createdAt": "2024-10-16T15:08:15Z",
              "updatedAt": "2024-10-16T15:08:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6NoH_4",
          "commit": {
            "abbreviatedOid": "3c8c123"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-17T19:31:09Z",
          "updatedAt": "2024-10-17T19:31:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOL5eEDM5-G6Jt",
      "title": "Issue 35",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/58",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Integrate the changes from the issue35 with Main, so the latest updates to the OID tables can be picked up by issue 35",
      "createdAt": "2024-10-09T16:57:20Z",
      "updatedAt": "2024-10-09T17:04:41Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "integrate_issue35_with_main",
      "baseRefOid": "a20cd4c3183dba03c885b64ddab03e5fc0951562",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "issue-35",
      "headRefOid": "2957443d71c8085b3e52963004ac748d3282972a",
      "closedAt": "2024-10-09T17:04:40Z",
      "mergedAt": "2024-10-09T17:04:40Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "72f7909d7f7ae08c86e6076872f3160148d973e5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOL5eEDM5-G9fd",
      "title": "Integrate issue35 with main",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/59",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updating the pull request to have the latest main changes for adding the context String and the pure and pre-hash modes of composite.",
      "createdAt": "2024-10-09T17:05:50Z",
      "updatedAt": "2024-10-17T19:08:15Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "e727467211be0c1b25fc418c097d8de48eeb91ae",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "integrate_issue35_with_main",
      "headRefOid": "851821e4ca956b3be2689f91d1b0178d374247b4",
      "closedAt": "2024-10-17T19:08:08Z",
      "mergedAt": "2024-10-17T19:08:08Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "ed1ffd6d64819c36572fa3baf0dfe059ef549e8f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6M9Sk-",
          "commit": {
            "abbreviatedOid": "06a24e3"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-10-13T09:36:34Z",
          "updatedAt": "2024-10-13T09:59:07Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nA composite signature's value MUST include two signature components and MUST be in the same order as the components from the corresponding verification public key.\r\n```",
              "createdAt": "2024-10-13T09:37:37Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n   2. Compute the Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the length of ctx, the value ctx and the original message M\r\n```",
              "createdAt": "2024-10-13T09:39:12Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nThis mode mirrors `ML-DSA.Verify(pk, M, signature, ctx)` defined in Section 5.3 of [FIPS.204]. Verification of a composite signature involves reconstructing the `M'` message by concatenating the composite domain separator \"Domain\" {{sec-oid-concat}} with the length of the context string `ctx` in bytes, the context string `ctx`, and finally the original message `M` .\r\n```",
              "createdAt": "2024-10-13T09:42:48Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 140,
              "body": "This whole paragraph needs to be re-done. The prohibition of recursive composites is a hold-over from generics and no longer makes sense.",
              "createdAt": "2024-10-13T09:46:08Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 142,
              "body": "The order of steps should be synced with .Sign(). For example, ,Sign() has \r\n\r\n```\r\n1. If |ctx| > 255\r\n2. Compute the Message format M'\r\n3. Separate the private key into componet keys.\r\n```\r\n\r\nBut here in .Verify(), we have:\r\n\r\n```\r\n1. Separate the keys and signatures\r\n2. If |ctx| > 255\r\n3. Format the Message as follows\r\n```\r\n\r\nI think the order in .Verify() makes more sense, so we should change .Sign() to match.",
              "createdAt": "2024-10-13T09:49:23Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\n   3. Compute the Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the length of ctx, the value ctx and the original message M\r\n```",
              "createdAt": "2024-10-13T09:50:07Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 268,
              "body": "Again, we should make sure that the order of steps is aligned with the pure algs above.",
              "createdAt": "2024-10-13T09:51:42Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 371,
              "body": "Again, we should make sure that the order of steps is aligned with the pure algs above.",
              "createdAt": "2024-10-13T09:52:15Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 385,
              "body": "```suggestion\r\nThe following tables summarize the details for each explicit composite signature algorithms:\r\n```",
              "createdAt": "2024-10-13T09:53:03Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 402,
              "body": "```suggestion\r\n| id-MLDSA44-Ed25519                  | &lt;CompSig&gt;.23 | id-ML-DSA-44  | id-Ed25519 | None |\r\n```",
              "createdAt": "2024-10-13T09:53:26Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 411,
              "body": "```suggestion\r\n| id-MLDSA65-Ed25519                      | &lt;CompSig&gt;.30  | id-ML-DSA-65 | id-Ed25519 | None |\r\n```",
              "createdAt": "2024-10-13T09:53:40Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 416,
              "body": "```suggestion\r\n| id-MLDSA87-Ed448                        | &lt;CompSig&gt;.33 | id-ML-DSA-87 | id-Ed448 | None |\r\n```",
              "createdAt": "2024-10-13T09:53:51Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 394,
              "body": "```suggestion\r\nPure Composite-ML-DSA Signature public key types:\r\n```",
              "createdAt": "2024-10-13T09:54:41Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            },
            {
              "originalPosition": 422,
              "body": "```suggestion\r\nHashComposite-ML-DSA Signature public key types:\r\n```",
              "createdAt": "2024-10-13T09:54:55Z",
              "updatedAt": "2024-10-13T09:59:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6NbCQe",
          "commit": {
            "abbreviatedOid": "06a24e3"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T14:27:22Z",
          "updatedAt": "2024-10-16T14:27:22Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "Suggestion:\r\n\r\nIf Error during Desequencing, or if any of the component keys or signature values are not of the correct key type or length for the given component algorithm then output \"Invalid signature\" and stop.",
              "createdAt": "2024-10-16T14:27:22Z",
              "updatedAt": "2024-10-16T14:27:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6NbIdu",
          "commit": {
            "abbreviatedOid": "b4ab950"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T14:32:54Z",
          "updatedAt": "2024-10-16T14:32:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "typo in component",
              "createdAt": "2024-10-16T14:32:54Z",
              "updatedAt": "2024-10-16T14:32:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6Nc82f",
          "commit": {
            "abbreviatedOid": "06a24e3"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T17:16:12Z",
          "updatedAt": "2024-10-16T17:16:12Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "Group agreed with this change. ",
              "createdAt": "2024-10-16T17:16:12Z",
              "updatedAt": "2024-10-16T17:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6NdAI5",
          "commit": {
            "abbreviatedOid": "06a24e3"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T17:22:38Z",
          "updatedAt": "2024-10-16T17:22:38Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I don't agree.   If we want to change them to be the same order, then we change Verify.     In Sign() if ctx > 255 then computing M' would fail because the length of the context can't be encoded into a single byte and computing M' would fail or be incorrect.  Why do all that when a simple check of the length would tell us if we can encode M' properly?    For verify, I don't really think the order matters as separating the keys is independent of the context check, but since the context check is faster, lets just do that one first in verify so they match up...  ",
              "createdAt": "2024-10-16T17:22:38Z",
              "updatedAt": "2024-10-16T17:22:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6NeF0t",
          "commit": {
            "abbreviatedOid": "06a24e3"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T19:26:46Z",
          "updatedAt": "2024-10-16T19:26:46Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I made the change to Verify so the two now match.  The first step is now the context check in a cases (both for pure and pre-hash).",
              "createdAt": "2024-10-16T19:26:46Z",
              "updatedAt": "2024-10-16T19:26:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6Nn8kZ",
          "commit": {
            "abbreviatedOid": "43de3e5"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-17T19:03:34Z",
          "updatedAt": "2024-10-17T19:03:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOL5eEDM5_CAvI",
      "title": "Digicert feedback.",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/67",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #32",
      "createdAt": "2024-10-17T23:51:22Z",
      "updatedAt": "2024-10-17T23:54:36Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "4da7ef18f0aac498de1db978f6170b28be734584",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mikeo_digicert_feedback",
      "headRefOid": "ddb17c3b4319dd2a518cd24595563255e608738b",
      "closedAt": "2024-10-17T23:54:06Z",
      "mergedAt": "2024-10-17T23:54:06Z",
      "mergedBy": "ounsworth",
      "mergeCommit": {
        "oid": "172975bfb31189138cbca3453304be4fe572c5f1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 68,
      "id": "PR_kwDOL5eEDM5_HujT",
      "title": "Update draft-ietf-lamps-pq-composite-sigs.md",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/68",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changed text to Compact the Private Key format",
      "createdAt": "2024-10-18T15:39:59Z",
      "updatedAt": "2024-10-18T17:18:07Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "172975bfb31189138cbca3453304be4fe572c5f1",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "6-CompactPrivateKey",
      "headRefOid": "8e30367ac3e52c10c115ac7763964f3832ab816a",
      "closedAt": "2024-10-18T17:18:01Z",
      "mergedAt": "2024-10-18T17:18:00Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "57432b8becae4eb5b0505dc90c97588a968ca8d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOL5eEDM5_H5iV",
      "title": "Update Composite-MLDSA-2024.asn",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/70",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update the ASN.1 module to for prehash OIDs and Fix up the pure ones by removing the Hashes for the ED448 and X25519 curves",
      "createdAt": "2024-10-18T16:08:41Z",
      "updatedAt": "2024-10-18T17:16:53Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "172975bfb31189138cbca3453304be4fe572c5f1",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "69-AddPreHashOIDStoASN1",
      "headRefOid": "287443a795450f1eea6a14502ec86c711f2387e2",
      "closedAt": "2024-10-18T17:16:47Z",
      "mergedAt": "2024-10-18T17:16:47Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "4a6a717cb0244f7b1e37ce04f226ac9bee3e3016"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 72,
      "id": "PR_kwDOL5eEDM5_Olad",
      "title": "ietf121_top-to-bottom",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/72",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- [x] Top-to-bottom alignment pass\r\n- [ ] Go through all the xml2rfc compiler warnings\r\n- [ ] Run spell-check",
      "createdAt": "2024-10-20T14:30:05Z",
      "updatedAt": "2024-10-21T20:31:09Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "57432b8becae4eb5b0505dc90c97588a968ca8d5",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "ietf121_top-to-bottom",
      "headRefOid": "5171ff0f7b152032dfa6b13f57b9bb3f7ef78e45",
      "closedAt": "2024-10-21T20:31:01Z",
      "mergedAt": "2024-10-21T20:31:01Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "5475fda1ac94b11bb4b35a6e27bef806a65bb5ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 74,
      "id": "PR_kwDOL5eEDM5_nq-T",
      "title": "Update draft-ietf-lamps-pq-composite-sigs.md",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/74",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed the missed and older ML-DSA Algorithm Identifier\r\nresolves #73 ",
      "createdAt": "2024-10-23T13:42:58Z",
      "updatedAt": "2024-10-23T14:54:59Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "5475fda1ac94b11bb4b35a6e27bef806a65bb5ac",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "73-Fix-AppendixC-OIDS",
      "headRefOid": "519e539ad5d231a176404afe69ceb555420a4667",
      "closedAt": "2024-10-23T14:54:58Z",
      "mergedAt": "2024-10-23T14:54:58Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "2e3945e7b13c3b2afa701f66e17eecb7de5ebef6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 76,
      "id": "PR_kwDOL5eEDM5_qCPh",
      "title": "Update draft-ietf-lamps-pq-composite-sigs.md",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/76",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix the IANA section indents\r\nresolves #75 ",
      "createdAt": "2024-10-23T17:59:34Z",
      "updatedAt": "2024-10-23T18:45:28Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "2e3945e7b13c3b2afa701f66e17eecb7de5ebef6",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "75-FixIanaIndents",
      "headRefOid": "a3c0166ca9a3a9a3429715d5d8cb55e2ef7a686e",
      "closedAt": "2024-10-23T18:45:24Z",
      "mergedAt": "2024-10-23T18:45:24Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "bee5e67ac708bfa8dd5e4f44ae8ff566c131d537"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "PR_kwDOL5eEDM6C2030",
      "title": "Removing DER wrapper",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/89",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First stab at removing SEQUENCE ASN.1 encodings",
      "createdAt": "2024-11-22T18:53:01Z",
      "updatedAt": "2024-11-29T19:29:37Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "bd4d0ed01d744a0c9c05c7b41612f141c4b23be3",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "85_RemoveASN1Wrapping",
      "headRefOid": "6b1326bcd6a10b153de57d40929c6c375c7c69e6",
      "closedAt": "2024-11-27T20:55:02Z",
      "mergedAt": "2024-11-27T20:55:02Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "d606485559e47442442cc369b1a22d127b3a5221"
      },
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "#closes 85",
          "createdAt": "2024-11-26T15:55:48Z",
          "updatedAt": "2024-11-26T15:55:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6SYEha",
          "commit": {
            "abbreviatedOid": "f7c8435"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-22T21:43:50Z",
          "updatedAt": "2024-11-22T22:08:02Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n  2. Parse each constituent encoded key.\r\n       The first 3 bytes encodes the length of mldsaEncodedKey, which MAY \r\n       be used to separate the mldsaEncodedKey and tradEncodedKey, and then \r\n       is to be discarded.\r\n```",
              "createdAt": "2024-11-22T21:43:50Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\n   The BIT STRING itself is generated by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}}, and an RSAPublicKey (which is a DER encoded RSAPublicKey).\r\n```",
              "createdAt": "2024-11-22T21:49:24Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-11-22T21:49:38Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 156,
              "body": "```suggestion\r\n    The BIT STRING itself is generated by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}} and an ECDSAPublicKey (which is a DER encoded ECPoint).\r\n```",
              "createdAt": "2024-11-22T21:50:50Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-11-22T21:50:59Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 165,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-11-22T21:51:14Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n    The BIT STRING itself is generated by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}} and a raw Edwards public key according to [RFC8410].\r\n```",
              "createdAt": "2024-11-22T21:51:26Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 172,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-11-22T21:52:46Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-11-22T21:53:29Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nSome applications may need to reconstruct the `SubjectPublicKeyInfo` objects corresponding to each component public key. {{tab-sig-algs}} or {{tab-hash-sig-algs}} in {{sec-alg-ids}} provides the necessary mapping between composite and their component algorithms for doing this reconstruction.\r\n```",
              "createdAt": "2024-11-22T21:56:42Z",
              "updatedAt": "2024-11-22T22:08:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6SYkaA",
          "commit": {
            "abbreviatedOid": "8e96eb5"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-22T22:54:06Z",
          "updatedAt": "2024-11-22T22:55:09Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "```suggestion\r\n       be used to separate the mldsaEncodedKey and tradEncodedKey, and then\r\n```",
              "createdAt": "2024-11-22T22:54:06Z",
              "updatedAt": "2024-11-22T22:55:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL5eEDM6SYll6",
          "commit": {
            "abbreviatedOid": "11dddad"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-22T22:55:48Z",
          "updatedAt": "2024-11-22T22:55:49Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n       The first 3 bytes encodes the length of mldsaEncodedKey, which MAY\r\n```",
              "createdAt": "2024-11-22T22:55:48Z",
              "updatedAt": "2024-11-22T22:55:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOL5eEDM6Dma5J",
      "title": "Update draft-ietf-lamps-pq-composite-sigs.md",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/91",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add Peter's suggested changes in #88 ",
      "createdAt": "2024-11-29T19:46:39Z",
      "updatedAt": "2024-11-29T19:49:39Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "7d345c471e6fe15ed07bc3d212d46f009885a15a",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "88_editorialChanges",
      "headRefOid": "f086e08a930659d5c912e5ef89f19053db51064f",
      "closedAt": "2024-11-29T19:49:39Z",
      "mergedAt": "2024-11-29T19:49:39Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "63f0cfe7463ac718f2cc67eec6a439114905ad4c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "PR_kwDOL5eEDM6E4PEX",
      "title": "added a sentence to offset table",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/93",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-11T15:43:49Z",
      "updatedAt": "2024-12-11T16:00:00Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "63f0cfe7463ac718f2cc67eec6a439114905ad4c",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "ounsworth-patch-1",
      "headRefOid": "9d17a4dddae485afe9a9db77e6a793ac73ec28b1",
      "closedAt": "2024-12-11T16:00:00Z",
      "mergedAt": "2024-12-11T16:00:00Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "40b8aef94ed90d884a4255dbbaf54f658fc55b88"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 95,
      "id": "PR_kwDOL5eEDM6F5SNd",
      "title": "Fix typo",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/95",
      "state": "OPEN",
      "author": "jiep",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-20T10:06:00Z",
      "updatedAt": "2024-12-20T10:06:00Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "bdd1e2f389f37ca31c26944f8d98d612a9cc7bb7",
      "headRepository": "jiep/draft-composite-sigs",
      "headRefName": "main",
      "headRefOid": "1d3ffaf6d0c569b1caa11e579685f289bd583e19",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}
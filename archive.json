{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-19T00:47:53.906968+00:00",
  "repo": "lamps-wg/draft-composite-sigs",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOL5eEDM6LI9I2",
      "title": "Carl Wallace's comments on composite signatures v13",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/1",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "opencrypto"
      ],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/147\r\n\r\nBelow are some comments, suggestions, and questions based on a brief review of draft-ounsworth-pq-composite-sigs-13.\r\n\r\nGeneral\r\n\r\nThe draft defines a set of 13 algorithms. Is LAMPS the right forum to vet algorithms? Generally, LAMPS deals with specs that describe how to use a given algorithm relative to PKIX and S/MIME artifacts, not algorithm specifications.\r\nIs the \"Internet PKI\" really the target? Is this kind of designation appropriate for what would appear to be a general-purpose algorithm specification?\r\nThe draft needs a thorough review to sharpen the fact that it now defines a set of 13 algorithms, not a framework for using composite key and signature combinations. Statements like \"should be regarded as a single key\" muddy the water. Even the term \"composite key\" is unhelpful. It's likely that most instances of the word \"composite\" could be written \"Composite ML-DSA.\" Given that this spec defines a means of generating and using keys and signatures, there's no need for all the \"drop-in replacement\" verbiage.\r\nOffhand, I think all of the relevant structures could use templates. Assuming this is correct, it may be worth including a section that notes ASN.1 decoders/encoders are not required.\r\nAll references to \"explicit composites\" should be reviewed and either deleted or amended.\r\nAbstract\r\n\r\nIs a \"X.509, PKIX, and CMS\" target appropriate for an algorithm specification? Is there some reason any of these 13 algorithms could not be used in a different context?\r\ns/Signaturem/Signature\r\nSections 2.3.1 - 2.3.3\r\n\r\nThese sections should include references to the relevant sections of each possible component algorithm. There is a list of algorithms in Section 5 (with a broken link for ML-DSA) but, given this is an algorithm specification, including more detail in the key generation, signature generation and signature verification sections would be appropriate and helpful.\r\ns/sketched/defined\r\nThere are two references to \"recursive composite public keys.\" These should be removed given they are not supported by definition.\r\nSection 2.3.1\r\n\r\ns/The KeyGen() -> (pk, sk) of a composite signature algorithm will perform the KeyGen() of the respective component signature algorithms / KeyGen() will perform the KeyGen() of the respective component signature algorithms\r\nIt's probably worth including pseudocode as done for Sign() and Verify()\r\nRewrite the last sentence to be Composite ML-DSA specific: The component keys MUST be uniquely generated for use in a Composite ML-DSA key.\r\nSection 2.3.2\r\n\r\nThe second and third steps could use some work. In step 2, S1 and S2 are raw signatures from a component algorithm. In step 3, they are BIT STRINGs containing the raw signatures. Additionally, it is unlikely the \"algorithm specifications\" address encoding as a BIT STRING. Suggest rewriting bullet 3 as below:\r\n\r\nEncode each component signature S1 and S2 as BIT STRINGs B1 and B2 then as a SEQUENCE\r\n\r\nsignature ::= Sequence { B1, B2 }\r\n\r\ns/A composite signature MUST produce/Sign() MUST produce\r\n\r\nSection 2.4\r\n\r\nDrop the word concatenation. No OIDs are being concatenated. There are other references to OID concatenation throughout the document that should be reviewed as well.\r\nSection 2.6\r\n\r\nDepending on the answer to the first question in General above, the following sentence may need to be removed or amended: \"If other combinations are needed, a separate specification should be submitted to the IETF LAMPS working group.\"\r\nThe statement that this \"also does not preclude future specification from extending these structures\" is false. The definitions are fixed at length 2. That someone could define a new specification with other lengths need not be commented on here. Suggest removing this sentence.\r\nSection 3\r\n\r\nReplace \"multiple algorithms\" with \"algorithm pairs\" or similar. Same comment applies throughout the draft.\r\nFWIW, I did not test compile the ASN.1 or work with the examples yet.\r\nGiven ECPoint is an alias for OCTET STRING do we need to ability to define types for each component, or can the object class be simplified to assert all component keys are simply OCTET STRINGs?\r\nSection 3.2\r\n\r\nThe reference to Table 3 is not altogether apt. The table lists signature algorithms. There should probably be a similar table for use in reconstituting SubjectPublicKeyInfo values (i.e., including curve name for parameters).\r\nSection 3.4\r\n\r\nWhy is this section necessary? The public key format defined by this specification is CompositeSignaturePublicKey. If someone wants to encode this in an OCTET STRING or BIT STRING that's their business.\r\nI would delete the entire section, but if the section remains, I would definitely delete the last sentence. The definitions provided call for DER encoding. Immediately following that with allowance for BER in the \u201cinterests of simplicity and avoiding compatibility issues\u201d is odd in that it provides for neither. If you want to support BER and DER, cite BER encoding. But why do that? Amongst other things, that would break ability to templatize the artifacts.\r\nSection 5\r\n\r\nRemove \"for explicit combinations\" from the first sentence.\r\nRemove the second paragraph given the list is exhaustive for this specification.\r\nRemove the third paragraph since only 13 algorithms are defined. There is no flexibility provided for in this specification to define other combinations.\r\nSecurity Considerations\r\n\r\nThis section should incorporate security considerations from component algorithms by reference.\r\nThe section still reflects the earlier versions before the scope was limited to focus on 13 algorithms. It could use some pruning. Maybe move some of the stripping discussion to the signature generation section.\r\nAll considerations are listed under the same heading. These should be broken up into new subsections (or the heading removed).\r\nSection B.2\r\n\r\nThis section (and subsections) should probably be deleted. At a minimum, they aren't really \"Implementation considerations\" for the 13 algorithms that are the subject of the draft.",
      "createdAt": "2024-06-04T21:14:50Z",
      "updatedAt": "2024-07-08T16:54:59Z",
      "closedAt": "2024-07-08T16:54:59Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th -  Lets all look at Carl's comments and discussion on June 19th.  ",
          "createdAt": "2024-06-05T14:41:05Z",
          "updatedAt": "2024-06-05T14:41:05Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOL5eEDM6LI9xE",
      "title": "Address Kris comments about Section B.1 on FIPS #145",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/2",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/145\r\n\r\nAddress Kris's comments:\r\n\r\nZjQcmQRYFpfptBannerEnd\r\nIn the section \"B.1 FIPS certification\", the draft says:\r\n\r\n\"algorithm to be [...] considered FIPS-approved even when one of the component algorithms is not\"\r\nand then\r\n\"overall composite should be considered full strength and thus FIPS-approved\"\r\nI think, the \"full strength\" may be misleading. Also the term is not clearly defined. Hence, it could be understood as \"full strength of classical+PQ\" and that is opposite to what NIST FAQ [1] says. I.e. let say MLDSA is FIPS-approved in a future, and we create composite with MLDSA-44 + some on-ramp signature that claims level 5. Does it mean the strength of that construct should be considered FIPS-approved with security strength of equal to level 2 or 5?\r\n\r\nAs this draft is now about creating composite signatures with MLDSA, so do we need B.1? The discussion about FIPS-approved dual signature schemes sounds like a great discussion to have, but in a different place (and ideally on CMUF forum).\r\n\r\nMy suggestion would be to remove B.1 to avoid spreading potentially misleading information about important topic.\r\n\r\nAdditional nit:\r\n\r\nThe abstract says \"Composite algorithms are provided which combine ML-DSA with RSA, ECDSA, Ed25519, and Ed448.\". Shouldn't it say MLDSA only?\r\n--\r\nKris Kwiatkowski\r\nCryptography Dev\r\n\r\n\r\n--- Group discussed this and decide to change the following:\r\n\r\nchange:\r\noverall composite should be considered full strength and thus FIPS-approved\"\r\nto\r\noverall composite should be considered at least as strong and thus FIPS-approved\"\r\n\r\nuntil FIPS deprecates RSA or EC...",
      "createdAt": "2024-06-04T21:16:55Z",
      "updatedAt": "2024-06-06T16:07:03Z",
      "closedAt": "2024-06-06T16:07:03Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The comment was addressed and the issue has been resolved is -01 version",
          "createdAt": "2024-06-06T16:07:03Z",
          "updatedAt": "2024-06-06T16:07:03Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOL5eEDM6LI-F0",
      "title": "Unreferenced section \"Parallel PKIs\"",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/3",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/143\r\n\r\nThe section [\"Parallel PKIs\"](https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/blob/final13copies/draft-ounsworth-pq-composite-sigs.md#parallel-pkis) in \"Implementation Considerations\" introduces a term that is not used throughout the document and therefore should be removed.\r\n\r\nTeam decided to remove the section on Parallel PKI's",
      "createdAt": "2024-06-04T21:17:56Z",
      "updatedAt": "2024-06-06T16:06:02Z",
      "closedAt": "2024-06-06T16:06:01Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue was resolve in version -01",
          "createdAt": "2024-06-06T16:06:01Z",
          "updatedAt": "2024-06-06T16:06:01Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOL5eEDM6LI-ad",
      "title": "Add a \"SignedInfo Conventions\" section",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/4",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:   https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/136\r\n\r\nMake-like-picture from\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-lamps-cms-sphincs-plus-03#name-signed-data-conventions\r\n\r\nWe also need to add SMIME-CAPS to the ASN.1. See the draft-cms-sphincs-plus\r\n\r\nDoing this saves writing a separate draft of using this draft in CMS... Use link from Mike above SPHINCS template.",
      "createdAt": "2024-06-04T21:19:04Z",
      "updatedAt": "2024-06-19T20:39:11Z",
      "closedAt": "2024-06-19T20:39:11Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Action:  John to take a look at this (from what Mike did in Composite KEM), with the idea that maybe lamps will want us to put it in a separate document.   To present this section next meeting (June 19th).",
          "createdAt": "2024-06-05T14:40:05Z",
          "updatedAt": "2024-06-05T14:40:05Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue resolved in Pull request #13 ",
          "createdAt": "2024-06-19T20:39:11Z",
          "updatedAt": "2024-06-19T20:39:11Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOL5eEDM6LI_C2",
      "title": "Resolve OID registration - Entrust assignment or IANA assignment",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/5",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/126\r\n\r\nRuss suggested Entrust could just assign the OIDs for composite sigs since we maintain an OID repository. Discuss this with the authors group and add to the next version -13?\r\n\r\nFrom Russ: \": If you are going to use the Entrust OID arc for the module assignment, why not assign it now.\"\r\n\r\nFor example, the module assignment could be:\r\nComposite-Signatures-2023\r\n{ joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)\r\nalgorithm(80) composite(8) id-composite-signatures-2023 (1) }\r\n\r\nToday we have:\r\nComposite-Signatures-2023\r\n{ joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)\r\nalgorithm(80) id-composite-signatures-2023 (TBDMOD) }\r\n\r\nAnd in Composite KEM we are using (for comparison):\r\n\r\nComposite-KEM-2023\r\n{iso(1) identified-organization(3) dod(6) internet(1)\r\nsecurity(5) mechanisms(5) pkix(7) id-mod(0)\r\nid-mod-composite-kems(TBDMOD) }\r\n\r\n\r\nMike and I discussed, we think having IANA assignment would make it more official and not look like it is only for Entrust.   The group decided that IANA assignment is the way to go, this will align with Composite KEM as well\r\n\r\n",
      "createdAt": "2024-06-04T21:21:15Z",
      "updatedAt": "2024-06-04T21:21:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOL5eEDM6LI_pD",
      "title": "Should we consider compacting the CompositeSignaturePrivateKey Format like we did with the public key format?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/6",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/121\r\n\r\nWe simplified the composite signature public key format from:\r\n\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo\r\nto\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2) OF BIT STRING\r\n\r\nWe haven't changed the CompositePrivateKeyFormat:\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OneAsymmetricKey\r\n\r\nOneAsymmetric Key from RFC 5958 is this:\r\n\r\nOneAsymmetricKey ::= SEQUENCE {\r\nversion Version,\r\nprivateKeyAlgorithm PrivateKeyAlgorithmIdentifier,\r\nprivateKey PrivateKey,\r\nattributes [0] Attributes OPTIONAL,\r\n...,\r\n[[2: publicKey [1] PublicKey OPTIONAL ]],\r\n...\r\n}\r\n\r\nPrivateKey ::= OCTET STRING\r\n-- Content varies based on type of key. The\r\n-- algorithm identifier dictates the format of\r\n-- the key.\r\n\r\nOneAsymmetricKey can carry the public key and has the algorithmIdentifier and version fields which are really redundant information. I think we could simply do this:\r\n\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF PrivateKey\r\n\r\nwhich is effectively:\r\nCompositeSignaturePrivateKey ::= SEQUENCE SIZE (2) OF OCTET STRING\r\n\r\nIt would allow sending composite private keys in PKCS12, or in raw encrypted blobs, to be smaller.\r\n\r\n\r\nAs of May 8th, 2024 - We are leaning in making this compact change - after getting the v14 update published on the lamp-wg github.\r\n\r\nIt also has the benefit of making key consistency better defined as a static mapping of the algorithm details needs to be used to reonstruct the private key.",
      "createdAt": "2024-06-04T21:23:19Z",
      "updatedAt": "2024-08-14T14:19:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th - We will keep this one here, revisit after the final standards are released.",
          "createdAt": "2024-06-05T14:32:52Z",
          "updatedAt": "2024-06-05T14:32:52Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "From Piotr:\r\n\r\nHi All\r\n\r\nI strongly support this change and point out that it is consistent with the current wording of Section 5.3, which indicates that CompositeSignaturePrivateKey is a component of the OneAsymmetricKey structure, not the OneAsymmetricKey structure itself. See:\r\n\r\n> When a CompositeSignaturePrivateKey is conveyed inside a\r\n\r\n> OneAsymmetricKey structure (version 1 of which is also known as\r\n\r\n> PrivateKeyInfo) [RFC5958], the privateKeyAlgorithm field SHALL be set\r\n\r\n> to the corresponding composite algorithm identifier defined according\r\n\r\n> to Section 7, the privateKey field SHALL contain the\r\n\r\n> CompositeSignaturePrivateKey, and the publicKey field MUST NOT be\r\n\r\n> present.\r\n\r\nAlso discussed this related issue for libOQS:   https://github.com/open-quantum-safe/oqs-provider/issues/466",
          "createdAt": "2024-08-14T14:18:00Z",
          "updatedAt": "2024-08-14T14:18:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "August 14th, 2024:   The authors group has agreed to do this work:  ",
          "createdAt": "2024-08-14T14:19:42Z",
          "updatedAt": "2024-08-14T14:19:42Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOL5eEDM6LJAQa",
      "title": "Add a new section: explicitely list SPKI AlgIds",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/7",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "From:  https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs/issues/116\r\n\r\nWe should add a section listing explicitly the DER-encoded AlgorithmIdentifiers for the components of each composite public key and signature algorithm. This is important to resolve ambiguity on, for example, whether the RSA should have a NULL param, and the ECC curve params.\r\n\r\nExample, for id-MLDSA44-ECDSA-P256-SHA256 the ML-DSA SPKI would have an AlgorithmIdentifier of:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ml-dsa\r\n    }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  }\r\nAnd the ECDSA-P256-SHA256 would have a SPKI would have an AlgorithmIdentifier of:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ecPublicKey,\r\n       secp256r1  \r\n  }\r\nwhich is:\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) keyType(2) 1 },\r\n       iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3) prime(1) 7}\r\nAnd the signature algorithm for id-MLDSA44-ECDSA-P256-SHA256, the first component signature algorithm would have an AlgorithmIdentifier of\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n        id-ml-dsa\r\n    }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  }\r\nand the second component signature algorithm would have an AlgorithmIdentifier of\r\n\r\n   AlgorithmIdentifier  ::=  SEQUENCE  {\r\n          ecdsa-with-SHA256\r\n  }\r\nwhich is:\r\n\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n           {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2\r\n       }\r\n  }\r\nWith that done, we should replace the message prefix values in Sectien 2.4 with the SHA256 hash of the signature AlgorithmIdentifiers. This has two nice properties that are better than using the ASCII encoding of the OID name: 1) they are all the same length (ie the length of SHA256), and 2) if the inner OIDs change, for example with a new Kyber version, then the message prefix changes, which prevents cryptographic compatibility issues; or otherwise stated: provides signature domain-separation based on the component OIDs.\r\n\r\n--- SHA256 of the DER encoding of the following ASN.1 value\r\n--- Security Consideration note: the choice of SHA256 here is not security-relevant since it is only to generate fixed string values.\r\n\r\nSEQUENCE {\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n        {\r\n     1.3.6.1.4.1.2.267.12.4.4\r\n      }\r\n  },\r\nAlgorithmIdentifier  ::=  SEQUENCE  {\r\n           {\r\n     iso(1) member-body(2) us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2\r\n       }\r\n  }\r\n}",
      "createdAt": "2024-06-04T21:24:28Z",
      "updatedAt": "2024-09-11T14:36:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "June 5th - Group would like to make the draft more clear in this regard, but not explode the draft.  Suggestion of a table or template section for RSA to make things more clear.    Action:  Jan to take a look at this for the next meeting (June 19th, 2024).",
          "createdAt": "2024-06-05T14:37:29Z",
          "updatedAt": "2024-06-05T14:37:29Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @johngray-dev,  @ounsworth ,\r\nI tried to write these things together (https://github.com/lamps-wg/draft-composite-sigs/blob/7-add-a-new-section-explicitely-list-spki-algids/draft-ietf-lamps-pq-composite-sigs.md) and have a question: \r\n\r\nThe algorithm for compiling the component OIDs to the hash value is easy but nevertheless an algorithm with the possibility for errors.\r\nIf we want domain separation that way we definitely need to include the EC parameter OID in the algorithm, else NIST and brainpool curves would have the same hash. Additionally we should have a rational why we do not include the PreHash OID here. Or include this also.\r\n\r\nThis said, this whole thing only makes sense during the development phase, because we dont know the MLDSA OIDs yet. But once they are fixed, also our combination matrix is fixed with new and official CompSig OIDs. So just Hashing the CompSig OID would do the same job and is much easier to describe in the signature algorithm.\r\nI am afraid reviewers would reject the compilation algorithm for the same reason.\r\n\r\nSo the question is, do we want to go the whole way of flexibility and define the compilation algorithm (that I would gladly do and maybe reuse for the kofn algorithm) or do we go the shortcut.\r\n\r\nWhat do you think? Do I miss something here?",
          "createdAt": "2024-06-28T15:48:25Z",
          "updatedAt": "2024-06-28T15:48:25Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening issue because the SPKI part of the issue has not been completed yet. ",
          "createdAt": "2024-09-11T14:36:38Z",
          "updatedAt": "2024-09-11T14:36:38Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOL5eEDM6LZ3vD",
      "title": "ML-DSA public keys should be unwrapped BIT STRINGS with no ASN.1 typing",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/9",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See on-list discussion: https://mailarchive.ietf.org/arch/msg/spasm/oH68LMpwXtpvltK2PnQSCUO9s0k/\r\n\r\nI see that draft-ietf-lamps-dilithium-certificates-03 does this:\r\n\r\n~~~\r\n  pk-MLDSA PUBLIC-KEY ::= {\r\n    IDENTIFIER id-MLDSA\r\n    -- KEY no ASN.1 wrapping --\r\n    PARAMS ARE absent\r\n    CERT-KEY-USAGE { nonRepudiation, digitalSignature,\r\n                    keyCertSign, cRLSign }\r\n    --- PRIVATE-KEY no ASN.1 wrapping --\r\n  }\r\n~~~\r\n",
      "createdAt": "2024-06-06T17:32:33Z",
      "updatedAt": "2024-08-05T10:13:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Carl suggested:\r\n\r\n~~~\r\nOr this (also not yet test compiled) definition:\r\n\r\n     id-raw-key ::= SOME OBJECT IDENTIFIER\r\n   pk-CompositeSignature {OBJECT IDENTIFIER:id,\r\n     FirstPublicKeyType,SecondPublicKeyType }\r\n       PUBLIC-KEY ::= {\r\n         IDENTIFIER id\r\n         KEY SEQUENCE {\r\n           firstPublicKey BIT STRING (CONTAINING FirstPublicKeyType  | ENCODED BY id-raw-key),\r\n           secondPublicKey BIT STRING (CONTAINING SecondPublicKeyType | ENCODED BY id-raw-key)\r\n         }\r\n         PARAMS ARE absent\r\n         CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign}\r\n       }\r\n\r\n~~~",
          "createdAt": "2024-06-06T18:31:18Z",
          "updatedAt": "2024-06-06T18:31:18Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Russ suggested:\r\n\r\n~~~\r\npk-MLDSA87-ECDSA-P384-SHA512 PUBLIC-KEY ::= {\r\n  IDENTIFIER id-MLDSA87-ECDSA-P384-SHA512\r\n  KEY SEQUENCE {key1 BIT STRING, key2 ECPoint}\r\n  PARAMS ARE absent\r\n  CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign} )\r\n~~~\r\n\r\nwith some text to explain that BIT STRING is unwrapped / raw.",
          "createdAt": "2024-06-06T21:12:51Z",
          "updatedAt": "2024-06-06T21:12:51Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #11 ?",
          "createdAt": "2024-07-03T15:00:14Z",
          "updatedAt": "2024-07-03T15:00:14Z"
        },
        {
          "author": "carl-wallace",
          "authorAssociation": "NONE",
          "body": "The suggestion attributed to me on June 6th is obsolete. There was a later suggestion that eliminates the embedded SEQUENCE, which causes bloat in code generated using these ASN.1 definitions. See: https://mailarchive.ietf.org/arch/msg/spasm/b7rvHiKnA80oZ-VqQY7LIoFdsu8/. \r\n\r\nNote, the reason for the suggestion of id-raw-key was your use of CONTAINING in the definition. You can't use CONTAINING with data not describing using ASN.1, so this isn't a case where you can use prose as with Russ' suggestions (there is no CONTAINING clause in SubjectPublicKeyInfo).",
          "createdAt": "2024-08-05T10:13:11Z",
          "updatedAt": "2024-08-05T10:13:11Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOL5eEDM6LZ38A",
      "title": "ASN.1 module still contains FN-DSA definitions",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/10",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Remove them.",
      "createdAt": "2024-06-06T17:32:57Z",
      "updatedAt": "2024-06-18T15:13:04Z",
      "closedAt": "2024-06-18T15:13:03Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed the \"Falon\" definition (which was a typo and why I missed it in the first place).   See:  https://github.com/lamps-wg/draft-composite-sigs/commit/d3e2c8e1296bf6d9d634ab7d0e9c7629e243aac0\r\n\r\n\r\n",
          "createdAt": "2024-06-18T15:13:03Z",
          "updatedAt": "2024-06-18T15:13:03Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOL5eEDM6LZ42X",
      "title": "Should the pk-CompositeSignature ASN.1 constructor be unrolled for each type?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/11",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We defined the pk-CompositeSignature information object class so that the rest of the ASN.1 module could be more compact, but it might be limiting optimization since this draft is now ML-DSA only. Perhaps we should remove this and and just directly define the PUBLIC-KEY structure for each public key type?\r\n\r\nSee, for example, the definition from draft-ietf-lamps-dilithium-certificates-03\r\n\r\n~~~\r\n  pk-MLDSA PUBLIC-KEY ::= {\r\n    IDENTIFIER id-MLDSA\r\n    -- KEY no ASN.1 wrapping --\r\n    PARAMS ARE absent\r\n    CERT-KEY-USAGE { nonRepudiation, digitalSignature,\r\n                    keyCertSign, cRLSign }\r\n    --- PRIVATE-KEY no ASN.1 wrapping --\r\n  }\r\n~~~",
      "createdAt": "2024-06-06T17:35:24Z",
      "updatedAt": "2024-07-03T14:51:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided to look at this in more detail post IETF 120.",
          "createdAt": "2024-07-03T14:48:21Z",
          "updatedAt": "2024-07-03T14:48:21Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The optimization that I would like us to take advantage of is to more closely match the public key encoding from \r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-lamps-dilithium-certificates-03#name-asn1-module\r\n\r\nWe should check the DER encoding of the Dilithium public key within a composite public key against the sample in the dilithium-certs draft. The question is whether the composite is adding an extra OCTET STRING tag which is not strictly necessary.",
          "createdAt": "2024-07-03T14:51:10Z",
          "updatedAt": "2024-07-03T14:51:10Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOL5eEDM6M6Mps",
      "title": "SHA256withECDSA vs ECDSAwithSHA256",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/14",
      "state": "CLOSED",
      "author": "danvangeest",
      "authorAssociation": "NONE",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "I'm curious why in the \"Composite Signature Algorithms\" table, SHA256withECDSA for example is used instead of ECDSAwithSHA256? Isn't the latter more commonly used terminology?",
      "createdAt": "2024-06-20T10:13:31Z",
      "updatedAt": "2024-07-08T17:08:16Z",
      "closedAt": "2024-07-08T17:08:16Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "In July 3rd, Jan said he would update the table.  ",
          "createdAt": "2024-07-03T14:41:47Z",
          "updatedAt": "2024-07-03T14:41:47Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "updated the naming in the table in PR#16",
          "createdAt": "2024-07-05T21:03:17Z",
          "updatedAt": "2024-07-05T21:03:17Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Confirmed that Jan resolved this in #16 ",
          "createdAt": "2024-07-08T17:08:16Z",
          "updatedAt": "2024-07-08T17:08:16Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOL5eEDM6N66ds",
      "title": "PSS parameter spec tables should include the SALT length",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/15",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The suggested PSS parameter tables for id-MLDSA44-RSA2048-PSS-SHA256 and id-MLDSA65-RSA3072-PSS-SHA512 don't give any indication of the salt length to use.   \r\n\r\nIn my implementation we used 64-bytes for both, but RFC's 4055 and 8017 suggest the typical salt length as one that matches the hashing length.  This would indicate a \"typical\" salt length of 32 for id-MLDSA44-RSA2048-PSS-SHA256 and 64 id-MLDSA65-RSA3072-PSS-SHA512\r\n\r\nRFC 8017 section 9.1 says this:\r\n\r\nTypical salt lengths in octets are hLen (the length of the output\r\n       of the hash function Hash) and 0.  In both cases, the security of\r\n       RSASSA-PSS can be closely related to the hardness of inverting\r\n       RSAVP1. \r\n\r\nFrom Tim Holobeek:\r\n\r\nHello,\r\n\r\nOur engineering team has been looking at composite signatures, and found a potential ambiguity.  The draft uses OIDs for everything, with no parameters (good), but this begs the question of what the right parameters are for rsa-pss, in particular the salt length, which isn\u2019t included in the parameters table.\r\n\r\nThere\u2019s also the question of what the right answer is, which honestly I haven\u2019t had time to review.  They\u2019re saying that RFC 4055 suggests matching the length of the hash in its security considerations section, which sounds reasonable, but Openssl seems to be hard-coded to always use 64 bytes of salt.  Which sounds right to me for SHA512 but not necessarily SHA256.",
      "createdAt": "2024-06-28T19:17:03Z",
      "updatedAt": "2024-07-03T20:45:54Z",
      "closedAt": "2024-07-03T20:45:53Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments.   We added PSS salt parameters.   We used 256 bits for id-MLDSA44-RSA2048-PSS-SHA256 and 512 bits for  id-MLDSA65-RSA3072-PSS-SHA512\r\n\r\nhttps://github.com/lamps-wg/draft-composite-sigs/commit/5753715bfe3cf35b5f797b14d8584041459a3266",
          "createdAt": "2024-07-03T20:45:53Z",
          "updatedAt": "2024-07-03T20:45:53Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOL5eEDM6OtEHB",
      "title": "Synchronize sections and writing style of composite sigs and kems",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/17",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-07T19:05:13Z",
      "updatedAt": "2024-07-07T19:05:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOL5eEDM6O0h2y",
      "title": "Should the DomSep be Hash( DER(OID) ) instead of DER(OID)",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/19",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The rationale for making it a hash is so that the domain separator Hex string is the same length, even if the OIDs end up being different lengths; for example if IANA decides to assign from multiple arcs, or if in the future (Falcon, new PQ sigs), we get OIDs from different arcs.\r\n\r\nOn the other hand, maybe it is ok for the domain separators to be different lengths, as long as they are pre-determined and not completely variable length (ie length is controllable by an attacker).",
      "createdAt": "2024-07-08T17:05:06Z",
      "updatedAt": "2024-09-11T14:34:04Z",
      "closedAt": "2024-09-11T14:34:04Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Authors group agreed we will keep it as a DER (OID) instead of a HASH (DER(OID)).",
          "createdAt": "2024-09-11T14:34:04Z",
          "updatedAt": "2024-09-11T14:34:04Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOL5eEDM6O80RT",
      "title": "Read Carl's email",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/20",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/spasm/b7rvHiKnA80oZ-VqQY7LIoFdsu8/. The point below is the that using a template like this with an embedded ASN.1 definition causes compilers (or at least the compiler I use) to emit far more code than if the structure were factored out of the template definition. I\u2019ve not spent any time with composite-kem yet, but it looks like some of the comments I had relative to the composite-signatures draft would apply here too.",
      "createdAt": "2024-07-09T13:56:32Z",
      "updatedAt": "2024-07-09T13:56:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOL5eEDM6O87nU",
      "title": "Feedback from Piotr",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/21",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/69ApI6-0EjcaQrel70vAV1Avyho/",
      "createdAt": "2024-07-09T14:09:54Z",
      "updatedAt": "2024-07-09T14:09:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 22,
      "id": "I_kwDOL5eEDM6PReke",
      "title": "Match \"Algorithm selection criteria\" to actual selections",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/22",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the Security Consideration section \"Public Key Algorithm Selection Criteria\" says:\r\n\r\n> A single RSA combination is provided at a key size of 3072 bits, matched with NIST PQC Level 3 algorithms.\r\n\r\nBut that's not true because we actually have 4 RSA combinations at both Level 2 and Level 3.\r\n\r\n~~~\r\nid-MLDSA44-RSA2048-PSS-SHA256\r\nid-MLDSA44-RSA2048-PKCS15-SHA256\r\nid-MLDSA65-RSA3072-PSS-SHA512\r\nid-MLDSA65-RSA3072-PKCS15-SHA512\r\n~~~",
      "createdAt": "2024-07-11T17:44:09Z",
      "updatedAt": "2024-07-11T17:44:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOL5eEDM6PUw0z",
      "title": "An End User would like a composite with an RSA-4096 component algorithm",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/23",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An end user wants us to add a 4096 bit composite combination:\r\n\r\nMy reading of the specs matches like this:\r\nhttps://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf\r\n\r\n112 bits of security   RSA 2048   \r\n128 bits of security   RSA 3072   ML-DSA-44\r\n192 bits of security   RSA 7680   ML-DSA-65\r\n256 bits of security RSA-15360  ML-DSA-87\r\n\r\nSo we can either switch the RSA-3072 ones to 4096 or add new composite combinations with RSA-4096\r\n",
      "createdAt": "2024-07-12T03:38:38Z",
      "updatedAt": "2024-07-21T14:42:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@johngray-dev : duplicate of #24 ?",
          "createdAt": "2024-07-19T08:04:47Z",
          "updatedAt": "2024-07-19T08:04:47Z"
        },
        {
          "author": "opencrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Shall this be handled with the IANA registry for the combinations?",
          "createdAt": "2024-07-21T14:42:12Z",
          "updatedAt": "2024-07-21T14:42:12Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOL5eEDM6PbIxz",
      "title": "Make RSA 4096 combos",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/24",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We have been asked to add RSA-4096 combos for existing infrastructures where deployed software or policy requires 4096 bit keys.\r\n\r\nSuggestion is that since RSA 4096 is not much above 128 bit security (certainly not as much as AES-192 or SHA-384), we should pair it with the same cipher suites as the RSA-3072 combo. Or maybe even replace the 3072 combo?",
      "createdAt": "2024-07-12T20:01:36Z",
      "updatedAt": "2024-07-31T14:18:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "@ounsworth I would rather add combinations, and yes, the same as with RSA 3072.\r\n1. RSA 4096 is expensive when I think of our smart card products\r\n2. RSA 3072 is expected to be secure enough *at least* till 2030 by BSI\r\n3. not even RSA 1024 is cracked till now (80 bits security) so I expect it to last 10 more years... without CRQC of course",
          "createdAt": "2024-07-15T07:49:30Z",
          "updatedAt": "2024-07-15T07:49:30Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "**Should we drop the key size from the OID at all?**\r\n\r\nYes: Piotr, Scott\r\nNo: Tim, Sophie, Mike",
          "createdAt": "2024-07-29T14:39:02Z",
          "updatedAt": "2024-07-29T14:39:02Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Group decided to add two new RSA 4096 combinations... one for PKCS 1.5, and PSS...  ",
          "createdAt": "2024-07-31T14:18:00Z",
          "updatedAt": "2024-07-31T14:18:00Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOL5eEDM6PxLUB",
      "title": "Add back text to not reuse component keys",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/25",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For the security proofs, it is imperative that the RSA / ECC keys be generated fresh for the composite and not re-used from existing deployments. I swear we had text to this effect. Certainly this deserves its own Security Consideration section.",
      "createdAt": "2024-07-16T20:58:03Z",
      "updatedAt": "2024-07-17T13:59:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "In draft-ietf-lamps-pq-composite-sigs-02, you have the following text:\r\n\r\nSection 4.1:\r\n   Compliant parties MUST NOT use or import component keys that are used\r\n   in other contexts, combinations, or by themselves (i.e., not only in\r\n   X.509 certificates).\r\n\r\nSection 5.2:\r\n   Component keys of a CompositeSignaturePublicKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\r\n\r\nSection 5.3:\r\n   Component keys of a CompositeSignaturePrivateKey MUST NOT be used in\r\n   any other type of key or as a standalone key.\r\n\r\nI agree this should be more prominent, and in the Security Considerations section, with reference to the proofs.\r\n\r\nDo you have a reference to the security proofs which make this imperative, which you could link here (for my own curiousity)?  Is this just related to Weak Non-Separability where if you reuse the component signature keys then you open yourself up to downgrade/stripping attacks, and if you don't reuse them then you cut off those attacks?  Or is the reuse forbidden for a more fundamental security reason, even if you use WNS artifacts in your composite scheme?",
          "createdAt": "2024-07-17T10:12:25Z",
          "updatedAt": "2024-07-17T10:12:25Z"
        },
        {
          "author": "danvangeest",
          "authorAssociation": "NONE",
          "body": "Ah I see that I am reading my emails out of order and this PR came from here: https://mailarchive.ietf.org/arch/msg/spasm/Ab7_g1Q3mVMCZH_GXiDLb-7dxVw/\r\n\r\nHowever, that thread is about composite KEM so I wonder if the same security concerns about simultaneous creation/combined usage also apply to composite signatures?",
          "createdAt": "2024-07-17T10:33:10Z",
          "updatedAt": "2024-07-17T10:33:10Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We didn't have text that was removed.  It was added in those 3 places to emphasize that keys are not to be used in other contexts.  This came as a result of conversations on the mailing list, but there were no formal proofs..  It is easy to conceive that allowing the same keys to be used outside a composite key independently would allow the generation of a composite signature indistinguishable from one generated by a composite key itself.  I suppose it shouldn't be hard to write a paragraph about that in the security considerations section.\r\n\r\n",
          "createdAt": "2024-07-17T13:59:56Z",
          "updatedAt": "2024-07-17T13:59:56Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOL5eEDM6QccME",
      "title": "NIST is suggesting that both PQ L3 + L5 should be paired with P-384",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/26",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "janklaussner"
      ],
      "labels": [],
      "body": "https://datatracker.ietf.org/meeting/120/materials/slides-120-openpgp-pqc-with-nist-and-brainpool-curves-00.pdf",
      "createdAt": "2024-07-22T17:19:47Z",
      "updatedAt": "2024-09-17T16:00:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The ML-DSA + ECC pairings to use are this:\r\n\r\n```\r\nML-DSA-44+NIST-P-256 \r\nML-DSA-65+NIST-P-384 \r\nML-DSA-65+brainpoolP256r1 \r\nML-DSA-87+NIST-P-384 \r\nML-DSA-87+brainpoolP384r1\r\n```",
          "createdAt": "2024-09-17T16:00:29Z",
          "updatedAt": "2024-09-17T16:00:29Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOL5eEDM6Q3fwk",
      "title": "We should be clear about which non-separability level we acheive",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/27",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a reference to draft-ietf-pquip-hybrid-signature-spectrums, and be clear (possibly with a full security consideration section) about which level this is achieving.",
      "createdAt": "2024-07-25T16:17:18Z",
      "updatedAt": "2024-07-25T16:29:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Potential text:\r\n\r\n>Inclusion of a composite signature algorithm OID inside a signed message achieved \u201cWeak Non-Separability\u201d, but that when you consider that within PKI, the verifier has the verification public key within a certificate, and that re-use of public keys between composite and non-composite certificates is forbidden, then all together this achieves \u201cStrong Non-Separability\u201d. We are in discussions with Dr. Hale about whether \u201cSimultaneous Verification\u201d can be achieved in this draft; the complexity is that most SV techniques require merging the two algorithms in such a way that you can\u2019t use, for example ECDSA from your existing codebase and ML-DSA from OpenQuantumSafe, but instead you have to write new code for the merged composite algorithm. This would also invalidate any existing FIPS / CC certifications of the existing traditional algorithm code, and being able to leverage existing certified code in the transition is a primary goal of composite.",
          "createdAt": "2024-07-25T16:24:57Z",
          "updatedAt": "2024-07-25T16:29:29Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOL5eEDM6S31IC",
      "title": "Update draft to support Official ML-DSA standard",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/28",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new FIPS 204 standard for ML-DSA was released.   We need to update the draft pointing to this draft:\r\nhttps://csrc.nist.gov/pubs/fips/204/ipd\r\n",
      "createdAt": "2024-08-13T19:53:01Z",
      "updatedAt": "2024-08-13T19:53:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOL5eEDM6S_K_3",
      "title": "List security strength of each composite",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/29",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the LAMPS mail list:\r\n\r\nHi Piotr,\r\n\r\n> \u201cIn addition, it might be appropriate to add a column, for example, in Table 6 (or even better, in a new table in Section 11.1) indicating the \"overall\" Security strength, which would take into account the weakest element.\u201d\r\n\r\nWhile I agree that this will be useful to a reader, I think that coming up with a single \u201coverall security strength\u201d for a composite will be difficult. For example, are you considering before or after your adversary has a CRQC? Perhaps the best we could do is to have two columns for \u201cClassical security\u201d and \u201cPQ Security\u201d and list different numbers in each column. Is this worth doing? \r\n",
      "createdAt": "2024-08-14T14:34:54Z",
      "updatedAt": "2024-08-14T14:34:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOL5eEDM6S_uSS",
      "title": "Simplify HW implementation",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/30",
      "state": "OPEN",
      "author": "mojtaba-bisheh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, the IETF defines \u201cid-MLDSA87-ECDSA-P384-SHA512,\u201d which restricts the input message to SHA-512 for the hybrid signature of MLDSA and NISTP384. However, including the SHA-384 option would reduce hardware complexities and align with both ECC and PQC standards.\r\n\r\nThe inclusion of \u201cid-MLDSA87-ECDSA-P384-SHA384\u201d would be compatible with existing standards and provide greater flexibility for implementations. FIPS 186-5 permits the use of both SHA-384 and SHA-512 for ECDSA P384. Additionally, FIPS 204 does not limit pre-hashed mode to SHA-512, stating: \"Algorithm 4 shows the DER encodings of the OIDs for SHA-256, SHA-512, and SHAKE128. However, it may be used with other hash functions or XOFs.\"\r\n\r\nFor example, one of the use cases of SHA384 in hardware implementation is [Caliptra](https://github.com/chipsalliance/caliptra-rtl), that exclusively uses SHA-384 for ECDSA P384. \r\n\r\nThe inclusion of \u201cid-MLDSA87-ECDSA-P384-SHA384\u201d would align with existing standards, provide more flexibility for implementations, and help enhance compatibility and facilitate broader deployment of PQC.",
      "createdAt": "2024-08-14T15:27:10Z",
      "updatedAt": "2024-08-28T16:53:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current version of the composite signature generation algorithm starts with\r\n\r\n```\r\n1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(Message)\r\n\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := Sign( K1, A1, M' )\r\n         S2 := Sign( K2, A2, M' )\r\n```\r\n\r\nSo there is a common pre-hash that applies to both halves of the composite. Therefore the pre-hash needs to match the security level of the strongest of the components. ML-DSA-87 is a NIST Level 5 algorithm, [which NIST defines as](https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria)):\r\n\r\n> comparable to a key search on a block cipher with a 256-bit key (e.g. AES 256)\r\n\r\nwhich requires SHA-512. Switching to SHA-384 would reduce this combination to a Level 4.",
          "createdAt": "2024-08-28T14:19:19Z",
          "updatedAt": "2024-08-28T14:19:59Z"
        },
        {
          "author": "mojtaba-bisheh",
          "authorAssociation": "NONE",
          "body": ">>Switching to SHA-384 would reduce this combination to a Level 4.\r\n\r\nI understand your point, however, SHA-384 can meet the requirements of applications that use id-MLDSA87-ECDSA-P384-SHA***.",
          "createdAt": "2024-08-28T16:53:13Z",
          "updatedAt": "2024-08-28T16:53:29Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOL5eEDM6TA-t0",
      "title": "List overall strength estimates for each composite",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/31",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See: https://mailarchive.ietf.org/arch/msg/spasm/s0wPyhHpaxKsSKMwLBypagm4iL0/",
      "createdAt": "2024-08-14T18:10:26Z",
      "updatedAt": "2024-08-29T19:34:32Z",
      "closedAt": "2024-08-29T19:34:32Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #29 ",
          "createdAt": "2024-08-29T19:34:32Z",
          "updatedAt": "2024-08-29T19:34:32Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOL5eEDM6TQ4ks",
      "title": "Digicert feedback",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/32",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/ReWx7kichMke-HuTHjCih3iZpD0/\r\n\r\nDigiCert's CA engineering team has some comments on the open issues related\r\nto the composite-sigs draft. We're going to put them in one email just\r\nbecause we have comments on quite a few of them.\r\n\r\nISSUE #1\r\n(Github issue:  https://github.com/lamps-wg/draft-composite-sigs/issues/9)\r\n\r\nASN.1 wrapping confuses people. This came up in the hash-based signatures\r\nupdates last call. Nobody knows what ASN.1 is, or what the consequences\r\nof omiting it are (to be clear, there are really none).\r\n\r\nWe agree that this is largely a question of people being unfamiliar with\r\nASN.1, and that explanatory text is sufficient. All that is needed is a\r\nclear explanation of example what the BIT STRING is, and explaining that\r\nit's simply the bits of the key itself seems pretty straightforward.\r\n\r\nOne can then say something similar to: \r\n\r\n\"In some situations and protocols, the key might be wrapped in ASN.1 or \r\nmay have some other additional decoration or encoding. If so, such wrapping \r\nMUST be removed prior to encoding the key itself as a BIT STRING.\"\r\n\r\nHopefully that makes things crystal clear.\r\n\r\nISSUE #2\r\n(Github Issue: https://github.com/lamps-wg/draft-composite-sigs/issues/19)\r\n\r\nWe don't think it's worth the extra complexity and expense of an additional\r\nhash operation just to achieve a fixed size output. The variation in size\r\nis already pretty small.\r\n\r\nISSUE #3\r\n(Github issue: https://github.com/lamps-wg/draft-composite-sigs/issues/6)\r\n\r\nAgain, we don't believe the additional complexity is worth it for a pretty\r\ntrivial improvement in the private key size. But it's not a strong opinion,\r\nwe could go either way.\r\n\r\nOpen Issues affect both Composite Signatures and Composite KEM:\r\nISSUE #4\r\n\r\nChair hat off, I and the CA team are concerned about the slow progress of \r\nthe composite signature work. In particular, tying it to the Composite KEM\r\ndraft and waiting for the CFRG work on KEM Combiners seems like an\r\nabsolutely horrible idea to us. We would like to see Composite Signatures\r\nprogress ASAP.\r\n\r\nISSUE #5\r\n(Github issues:\r\nhttps://github.com/lamps-wg/draft-composite-kem/issues/37\r\nhttps://github.com/lamps-wg/draft-composite-sigs/issues/24\r\nhttps://github.com/lamps-wg/draft-composite-sigs/issues/23)\r\n\r\nThis is a fun one, and we've spent quite a bit of time discussing it\r\ninternally.\r\n\r\nIn particular, we're still debating the question about exactly how many\r\nbackwards compatibility options are really necessary. For example, given\r\nthat you already need to add lattice, is it really necessary to allow\r\nPKCS15 to continue to exist? For RSA, there's the reasonable argument that\r\nthat might be all you have in your validated hardware/software, but if you\r\nhave RSA as a primitive, can't you do PSS instead of PKCS15? Remember, you\r\nalready have to make changes on both the signing and verify side anyway.\r\n\r\nWe're trending in the direction of thinking that the primary decision is\r\nthe security level and post-quantum algorithm, and the classical side is\r\njust determined by what \"makes sense\" for that security level and algorithm.\r\n\r\nSo what you really want is something like \"id-SL1-MLKEM-RSA\" where the\r\ndocument specifies exactly what \"RSA\" means in the context of a SL1 MLKEM512\r\ncomposite, e.g. RSA4096-PSS-SHA512. This basically means striving for\r\nat most one combination for each triple of (security level, PQC flavor, classical \r\nflavor) and eliminating unnecessary complexity and diversity of options in what \r\nis essentially a redundancy/backup mechanism.\r\n\r\nThe basic idea is to more aggressively standardize the backwards \r\ncompatibility options to only what's actually necessary, instead of\r\ntrying to be backwards compatible with the universe of current behavior,\r\nwhich both unnecessarily complicates things, and preserves some practices\r\n(e.g. PKCS15) longer than is perhaps prudent.\r\n\r\n-Tim\r\n",
      "createdAt": "2024-08-16T17:29:47Z",
      "updatedAt": "2024-08-16T17:29:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOL5eEDM6T5Pjf",
      "title": "Burt's feedback: context string in domain separator?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/33",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/vzomXUHvJOouzIcC82WkMF4DP-g/\r\n\r\n> Should the domain separator also include an optional context string, similar to the domain separator NIST has defined for the recently published FIPS 204/205 [1]?  The context string would provide a way to \u201cseparate uses of the protocol between different protocols \u2026 and between different uses within the same protocol\u201d (Sec. 8.3 of [2]).  \r\n\r\n> Similarly, if an underlying signature algorithm supports a context string, what value should be given to the context string when the algorithm is used with the composite construction?  If the composite construction is updated to include an optional context string in the domain separator, should the context strings for the underlying algorithm and for the overall construction be the same?  Or should the context string for the underlying algorithm instead somehow indicate the \u201cuse\u201d of the underlying algorithm is \u201cfor signing a composite signature hash value\u201d?\r\n\r\n[2] S. Josefsson, I. Liusvaara.  Edwards-Curve Digital Signature Algorithm (EdDSA).  RFC 8032, January 2017",
      "createdAt": "2024-08-22T16:29:29Z",
      "updatedAt": "2024-08-22T16:31:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good suggestion. I support having the composite .Sign() accept a context string, and passing it through to underlying component primitives that support a context string (ie ML-DSA).",
          "createdAt": "2024-08-22T16:31:55Z",
          "updatedAt": "2024-08-22T16:31:55Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOL5eEDM6T5RGI",
      "title": "Burt's feedback: should we define pre-hashed modes for composite?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/34",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/spasm/vzomXUHvJOouzIcC82WkMF4DP-g/\r\n\r\n> Should the domain separator include an initial byte that identifies the type of domain separator, again similar to NIST\u2019s definition?  For instance, the value 1 could indicate that the message is pre-hashed as currently proposed in draft-ietf-lamps-pq-composite-sigs.  A different value could support another option:  the message is not pre-hashed, but instead is prepended with a domain separator, and then passed to the two signature algorithms.  That option would avoid the need for an additional hashing operation to be specified.  (The domain separator could still include an OID for the combination of the two signature algorithms in order to separate different combinations of algorithms.)\r\n\r\n> If an underlying signature algorithm supports pure and pre-hash modes, which mode should be used with the composite signature construction?  Presumably pure mode when the composite construction includes pre-hashing, because the message will already have been hashed by the time it reaches the underlying signature algorithm, but this should be stated explicitly.\r\n\r\n> In addition to pre-hashing as currently proposed, should there be an option for including a randomizer and/or the signers\u2019 public keys in the input to the pre-hash operation, in addition to the message?  As Joe Harvey observed in comments to NIST earlier this year [3], without such an option, pre-hashing introduces a dependency on collision resistance, whereas the security of the underlying signature algorithm may be based on other security assumptions (e.g., target collision resistance, second preimage resistance).   Moreover, a collision, if found, could potentially be used against multiple users, whereas the underlying signature algorithm may have been designed to provide security in the multi-user model.  (This is not an argument for reducing the size of the hash function output by using randomization, but rather for considering that the use of pre-hashing may change the security assumptions compared to the underlying algorithm, and providing the protocol designer a way to revert to the original assumptions.)\r\n",
      "createdAt": "2024-08-22T16:32:57Z",
      "updatedAt": "2024-08-22T16:40:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair point, currently the composite draft presents a pure-sign mode, and uses ML-DSA in its pure-sign mode. But with NIST deciding to support both pure and pre-hash modes of ML-DSA, we should probably do that same for composite-ML-DSA.\r\n\r\nThis represents a fairly large amount of design work since all the points raised by Burt, plus probably more, are in-scope.",
          "createdAt": "2024-08-22T16:37:51Z",
          "updatedAt": "2024-08-22T16:37:51Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the point about prefix byte does not apply: since we are already hashing in the OID, and we would presumably define different OIDs for pure and pre-hashed modes, I think that anything you would want to capture in the prefix byte is already captured in the OID.",
          "createdAt": "2024-08-22T16:40:25Z",
          "updatedAt": "2024-08-22T16:40:25Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOL5eEDM6Ujg1T",
      "title": "Should we have a nonempty ML-DSA context string?",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/35",
      "state": "OPEN",
      "author": "sfluhrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ML-DSA has a 'context string' as an input; the idea is to allow the capability to bind a signature to a specific context.\r\n\r\nShould we specify that, when we implement ML-DSA within a composite signature, that we have a nonempty context?\r\n\r\nIf the verifier will never accept a signature signed by a specific ML-DSA key except as part of a composite signature, we don't gain anything.  However, it might be a helpful 'belt-and-suspenders' if some application would happen to reuse the ML-DSA public key.\r\n\r\nIf we do have a nonempty context string, what should it be:\r\n- Should it be the OID for the composite (so that the signature can be used only as a part of that specific combination)\r\n- Should it be the hash of the composite public key (so that we're safe even if some fool changes the other components)\r\n\r\nThoughts?",
      "createdAt": "2024-08-28T14:51:26Z",
      "updatedAt": "2024-08-29T20:23:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion between John, Felipe, and myself. \r\nDecision is to change one sentence is the draft:\r\n\r\nOLD:\r\n```\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := Sign( K1, A1, M' )\r\n         S2 := Sign( K2, A2, M' )\r\n```\r\n\r\nNEW:\r\n```\r\n2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx=\"\" )\r\n         S2 := TradSign( K2, A2, M' )\r\n\r\nSince Composite ML-DSA incorporates the domain separator into a pre-hash, which serves theh same purpose as the ML-DSA context string, the ML-DSA context string is left empty.\r\n```",
          "createdAt": "2024-08-29T20:23:31Z",
          "updatedAt": "2024-08-29T20:23:31Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOL5eEDM6UvNow",
      "title": "Update to final FIPS 204",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/36",
      "state": "CLOSED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-29T19:35:12Z",
      "updatedAt": "2024-09-08T19:30:44Z",
      "closedAt": "2024-09-08T19:30:44Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOL5eEDM6Uvw1y",
      "title": "Version Composite OIDs for use with standard ML-DSA version",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/37",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update the Composite Signature OIDS to the following:\r\n\r\n2.16.840.1.114027.80.8.1.21   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-RSA2048-PSS-SHA256    060B6086480186FA6B50080115\r\n2.16.840.1.114027.80.8.1.22   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-RSA2048-PKCS15-SHA256 060B6086480186FA6B50080116\r\n2.16.840.1.114027.80.8.1.23   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-Ed25519-SHA512        060B6086480186FA6B50080117 \r\n2.16.840.1.114027.80.8.1.24   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-ECDSA-P256-SHA256     060B6086480186FA6B50080118\r\n2.16.840.1.114027.80.8.1.25   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA44-ECDSA-brainpoolP256r1-SHA256 060B6086480186FA6B50080119\r\n2.16.840.1.114027.80.8.1.26   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-RSA3072-PSS-SHA512 060B6086480186FA6B5008011A\r\n2.16.840.1.114027.80.8.1.27   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-RSA3072-PKCS15-SHA512 060B6086480186FA6B5008011B\r\n2.16.840.1.114027.80.8.1.28   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-ECDSA-P256-SHA512 060B6086480186FA6B5008011C\r\n2.16.840.1.114027.80.8.1.29   entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-ECDSA-brainpoolP256r1-SHA512 060B6086480186FA6B5008011D\r\n2.16.840.1.114027.80.8.1.30  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA65-Ed25519-SHA512 060B6086480186FA6B5008011E\r\n2.16.840.1.114027.80.8.1.31  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-ECDSA-P384-SHA512 060B6086480186FA6B5008011F\r\n2.16.840.1.114027.80.8.1.32  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-ECDSA-brainpoolP384r1-SHA512 060B6086480186FA6B50080120\r\n2.16.840.1.114027.80.8.1.33  entrust-Algorithm-ExplicitComposite-Signature.id-MLDSA87-Ed448-SHA512 060B6086480186FA6B50080121",
      "createdAt": "2024-08-29T20:48:06Z",
      "updatedAt": "2024-08-29T20:48:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOL5eEDM6U2FII",
      "title": "Clarifying Composite Signature Specifications for Consistent Implementation",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/39",
      "state": "OPEN",
      "author": "mojtaba-bisheh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am seeking clarification on the input message for the composite signature specification to ensure consistent understanding and implementation. Given that ML-DSA operates in two modes\u2014pure and pre-hash\u2014and there are various prefixes/OIDs for the pre-hashed mode, this clarification is crucial. \r\nThere is also one more hashing operation within the ECC boundary that should not be mistaken for what the composite signature needs in `M' := Domain || HASH(Message)` step.\r\n\r\nThere are two options here:\r\n\r\nOne option is to move hybrid domain concatenation into HASH operation (similar to ML-DSA scheme),i.e., `M' := HASH(Domain || Message)`. In this case, there is one other HASH operation for both ECC and pre-hash ML-DSA:\r\nfor ECC: `HASH(M') = HASH(HASH(Hybrid_Domain || Message))`\r\nfor pure ML-DSA: = `HASH(tr || M') = H(tr || 0x00 || ctx_len || ctx || HASH(Hybrid_Domain || Message))`\r\nfor pre-hash ML-DSA: = `HASH(tr || M') = H(tr || 0x01 || ctx_len || ctx || OID || HASH(HASH(Hybrid_Domain || Message))`\r\nThis back-to-back hashing operation for ECC and pre-hash MLDSA makes no sense, so you can remove the hash operation and just append message with an OID that reduces the complexity of the computation too.\r\n\r\nSecond option is keeping the current condition as:\r\nfor ECC: `HASH(M') = HASH(Hybrid_Domain || HASH(Message))`\r\nfor pure ML-DSA: = `HASH(tr || M') = H(tr || 0x00 || ctx_len || ctx || Hybrid_Domain || HASH(Message))`\r\nfor pre-hash ML-DSA: = `HASH(tr || M') = H(tr || 0x01 || ctx_len || ctx || OID || HASH(Hybrid_Domain || HASH(Message))`\r\n\r\nFurthermore, Including test vectors and examples in the specification would promote uniform implementation across the industry.",
      "createdAt": "2024-08-30T13:11:46Z",
      "updatedAt": "2024-08-30T20:50:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 40,
      "id": "I_kwDOL5eEDM6VuoU4",
      "title": "Adding an Applicability Statement to the draft",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/40",
      "state": "OPEN",
      "author": "yoavnir",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When the composite sigs draft was adopted, the WG concluded that this was a useful technology, but only useful in certain places. I suggest adding an \"Applicability Statement\" to the draft, calling out those places where the technology is applicable.  \r\n\r\nAs I understand it, the biggest justification for composite signatures is that we don't entirely trust either the classic or the PQ algorithms, the classic because maybe the attacker has a CRQC, and the PQ algorithm because it's too new.  So people are hesitant to deploy pure PQ certificates, because if the PQ algorithm turns out to be broken, replacing all the certificates would take a long time and be very difficult or expensive.  This is more or less relevant to different use cases.\r\n\r\nI don't now have proposed text, but just off the top of my head:\r\n* The web - The web is moving to relatively short-term certificates. ACME is part of it. So if it's possible to replace all the web certificates in a few months, is it important to have >1 signatures in a certificate?  Perhaps this is something that we should consult with the CA/BF about.\r\n* Intranets - Corporate networks use certificates for a lot of internal communications. This includes internal web, email protocols, and all kinds of other proprietary protocols. But those are relatively well-controlled. There are people with the authority to decide to replace all the certificates with other single-algorithm certificates. So if an algorithm is broken, they could replace it relatively quickly.\r\n* VPNs or SD-WANs - This is similar to intranet, with the difference that these are often products that are sometimes in service for many years and may have issues with replacing hardware or updating software.\r\n* Internal and client communications between clusters of computers, such as distributed databases or distributed \"software-defined\" storage. Those sometimes have certificates that are quite long-term. On occasion such clusters grow by adding new nodes to existing clusters, resulting in a mix of old and new servers, and even old and new software.  \r\n* Infrastructure - That's a big one for composite signatures, because sometimes infrastructure devices (from smart meters to water or electric grid control) can be installed for decades. We all believe it should be possible to update them with new software and algorithms, but the reality is that a lot of them don't. ",
      "createdAt": "2024-09-07T19:14:21Z",
      "updatedAt": "2024-09-11T14:29:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are they suitable for the Web?  Are they suitable for intranets?  For VPNs and SD-WANs?  For storage area networks? For cluster communications such as distributed storage systems?  For infrastructure?\r\n\r\nI think yes to all of the above; composite-ML-DSA has exactly the same applicability as regular ML-DSA is. I believe (and Entrust recommends to our customers) that this is useful literally everywhere; that the hybrid is a small price to pay for some extra comfort with these new crypto algorithms. Let me flip the question around: perhaps it's easier to list the place that composites are not appropriate? The only one that comes to mind are highly bandwidth / CPU constrained use cases where your tolerance on ML-DSA is so tight that you can't even tolerate X25519 on top. \r\n\r\n\r\nThe draft already contains this text, which I think is fairly clear:\r\n\r\n> Cautious implementers may opt to combine cryptographic algorithms in such a way that an attacker would need to break all of them simultaneously to compromise the protected data. These mechanisms are referred to as Post-Quantum/Traditional (PQ/T) Hybrids [I-D.driscoll-pqt-hybrid-terminology].\r\n> Certain jurisdictions are already recommending or mandating that PQC lattice schemes be used exclusively within a PQ/T hybrid framework. The use of Composite scheme provides a straightforward implementation of hybrid solutions compatible with (and advocated by) some governments and cybersecurity agencies [BSI2021].\r\n\r\nBut I'll go ahead and add the following sentence to the draft.\r\n\r\n\"Composite ML-DSA is applicable in any application that would otherwise use ML-DSA, but wants the protection against breaks or catastrophic bugs in ML-DSA.\"\r\n",
          "createdAt": "2024-09-08T19:22:42Z",
          "updatedAt": "2024-09-08T19:23:00Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The authors agree with the blanked statement Mike is suggesting.  On September 11th we decided to mention this at IETF 121.\r\n",
          "createdAt": "2024-09-11T14:29:27Z",
          "updatedAt": "2024-09-11T14:29:27Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOL5eEDM6WNcSA",
      "title": "We should also expose a context string / domain separator as external input to the composite-sign",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/42",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion here:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/YFW4hVCZAQiVge2Z1kzAlIcM4U8/\r\n\r\nThe idea is that you may want to bind the actually application context, like \"MS Firmware Sign\" in addition to the composite sig OID. This \r\n\r\nIf we make this change, the composite sign would become:\r\n\r\n```\r\nM' := Domain || Ctx || HASH(Message)\r\n```\r\n\r\nor possibly\r\n\r\n```\r\nM' := Domain || HASH(Ctx || Message)\r\n```\r\n\r\nwhere `Ctx` is external input to the composite Sign(), and defaults to the empty string.\r\n\r\nMy concern with doing things outside the HASH is that this is the pre-hash for RSA / ECDSA, so a very long context string could overflow the RSA / ECDSA \"block\" -- therefore I think any kind of variable-length Ctx needs to be inside the hash.",
      "createdAt": "2024-09-11T15:44:12Z",
      "updatedAt": "2024-09-12T20:09:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the meeting today, we discussed two versions. I don't think we reached consensus about which was better.\r\n\r\nVersion 1:\r\n```\r\nSign (sk, Message, ctx) -> (signature)\r\n\r\n\r\nSignature Generation Process:\r\n\r\n   1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(ctx || Message)\r\n\r\n   2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx=\"\" )\r\n         S2 := Trad.Sign( K2, A2, M' )\r\n```\r\n\t \r\nVersion 2:\t \r\n```\r\nSign (sk, Message, ctx) -> (signature)\r\n\r\n\r\nSignature Generation Process:\r\n\r\n   1. Compute the new Message M' by concatenating the Domain identifier (i.e., the DER encoding of the Composite signature algorithm identifier) with the Hash of the Message\r\n\r\n         M' := Domain || HASH(Message)\r\n\r\n   2. Generate the 2 component signatures independently, by calculating the signature over M'\r\n      according to their algorithm specifications that might involve the use of the hash-n-sign paradigm.\r\n\r\n         S1 := ML-DSA.Sign( K1, A1, M', ctx )\r\n         S2 := Trad.Sign( K2, A2, HASH(ctx || M') )\r\n```",
          "createdAt": "2024-09-12T20:08:29Z",
          "updatedAt": "2024-09-12T20:08:29Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We did agree that since FIPS 204 defines the API to be:\r\n>ML-DSA.Sign(\ud835\udc60\ud835\udc58, \ud835\udc40, \ud835\udc50\ud835\udc61\ud835\udc65)\r\n\r\nour Composite-ML-DSA should at least have the same API.",
          "createdAt": "2024-09-12T20:09:19Z",
          "updatedAt": "2024-09-12T20:09:19Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOL5eEDM6WfqiO",
      "title": "Max suggests dropping SEQUENCE OF wrapper",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/43",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Max,\r\n\r\nIf I understand your proposal, you are suggesting that\r\n\r\nCompositeSignaturePublicKey ::= SEQUENCE SIZE (2) OF BIT STRING\r\nCompositeSignatureValue ::= SEQUENCE SIZE (2) OF BIT STRING\r\n\r\n\r\nBecomes\r\n\r\nCompositeSignaturePublicKey ::= BIT STRING\r\nCompositeSignatureValue ::= BIT STRING\r\n\r\nAn then you need to specify that for id-MLDSA44-RSA2048-PSS-SHA256 the first X bits are the ML-DSA-44 public key / signature, and the remaining Y bits are the RSA-2048.\r\n\r\n\r\nThe original reason for an ASN.1 wrapper was to gracefully handle algorithms with variable-length publickeys, signatures, or ciphertexts, which I believe there were some of in NIST Round 1. This is no longer a concern with FIPS 203 / 204, so we could now remove it. However, I think it will be a fair amount of editorial work (we will need to accurately list out the bit position to split at for each composite alg), and it is asking all existing composite implementations to change, then will require a lot of interop testing. Is this change really worth it?\r\n\r\nIf you feel strongly about this, then perhaps you could prepare the change to the document on a side-branch, and we could bring it to the LAMPS mailing list?\r\n",
      "createdAt": "2024-09-13T13:40:28Z",
      "updatedAt": "2024-09-13T13:40:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 44,
      "id": "I_kwDOL5eEDM6W5C8r",
      "title": "Description of \"PUBLIC-KEY\" is wrong",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/44",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Laurent Pion points out that a signature is produced by a private key, not a public key.\r\n\r\n> Chapter 6.1, table 1\r\n> Don\u2019t know if it\u2019s my wrong understanding or a little mistake, PUBLIC-KEYS, is it the composite (private) key required to produce the signature or the public key to verify it?\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/spasm/S5CyDKP4xngRmHNdlmHozXrpLzw/\r\n",
      "createdAt": "2024-09-17T16:01:51Z",
      "updatedAt": "2024-09-17T16:03:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 45,
      "id": "I_kwDOL5eEDM6XFAn8",
      "title": "Clarify that we are using pure ML-DSA, not HashML-DSA",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/issues/45",
      "state": "OPEN",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We should add text in a few places\r\nWe should add this in the section where we define the signature process, and we should also mention it in the appendix about FIPS certification of a composite implementation.\r\n\r\n(Credit for this ticket: Jeff Andersen)",
      "createdAt": "2024-09-18T20:33:42Z",
      "updatedAt": "2024-09-18T20:33:42Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 8,
      "id": "PR_kwDOL5eEDM5xs5E5",
      "title": "Update tov13",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/8",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Added back the v13 changes\r\n- Fixed issues #2 and #3\r\n- Added changes since adoption section\r\n- Added Scott Fluher as an auther",
      "createdAt": "2024-06-06T16:03:49Z",
      "updatedAt": "2024-06-20T03:19:17Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "de8244a96beb9000d84c6979a2fcc913c4d32719",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "UpdateTov13",
      "headRefOid": "ad27c830706d2d34ba4a92cefca15b440adda3f5",
      "closedAt": "2024-06-06T16:05:02Z",
      "mergedAt": "2024-06-06T16:05:02Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "b7f6a91cd28f8324904466b4e2911495ace19023"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOL5eEDM5x9jYU",
      "title": "Fix typos",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/12",
      "state": "CLOSED",
      "author": "jiep",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-10T11:09:06Z",
      "updatedAt": "2024-07-03T20:50:35Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "b7f6a91cd28f8324904466b4e2911495ace19023",
      "headRepository": "jiep/draft-composite-sigs",
      "headRefName": "patch-1",
      "headRefOid": "43070ba61ceae7b528446d32a5113785157b696a",
      "closedAt": "2024-07-03T20:50:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We merged your comments separately.   We changed the n to 2 as you suggested, we reworded the about the y bitstrength, and we looked up what NIST used in their documents and they used ML-DSA-44 (for example), so we will continue to use that one.    Thank you so much for your comments and suggestions.  We also added you to the acknowledgement section at the end of the document.  ",
          "createdAt": "2024-07-03T20:49:46Z",
          "updatedAt": "2024-07-03T20:49:46Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "As mentioned above, we manually merged your comments and made some suggested wording changes.  ",
          "createdAt": "2024-07-03T20:50:34Z",
          "updatedAt": "2024-07-03T20:50:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOL5eEDM5zAHxz",
      "title": "4 signed info use in cms",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/13",
      "state": "MERGED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge the changes for #4 into the main branch.   Reviewed and edits by the authors group.\r\n\r\nAdded a \"Use in CMS\" section\r\nRemoved a Falon reference from the ASN.1 document (which was a typo in reference to Falcon)\r\nAdded SMIME-CAPS into the sa-CompositeSignature definition in the ASN.1 module\r\nFixed nits and other typos",
      "createdAt": "2024-06-19T20:36:44Z",
      "updatedAt": "2024-06-20T03:19:09Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "d59d73da181cf23f8ecce17f7daf8c5a0e310fc3",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "4-signedInfo-UseInCMS",
      "headRefOid": "b4cf50eafb96d85c0d49cc067c3507bfad5b68f6",
      "closedAt": "2024-06-19T20:38:30Z",
      "mergedAt": "2024-06-19T20:38:30Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "1c4f87224c9dc3c2850bd64d0e9f478635e659e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOL5eEDM50kQkB",
      "title": "Add appendix with component algorithm references",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/16",
      "state": "MERGED",
      "author": "janklaussner",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* appendix with references of signature, curves and hashes\r\n* updated section 'Algorithm Identifiers' with reference to appendix and IDs of component algorithms\r\n* updated algorithm description for signature generation and verification to use Domain separator",
      "createdAt": "2024-07-05T21:00:55Z",
      "updatedAt": "2024-07-08T15:43:37Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "e89f78848179101641dbbe3d02447fde62831570",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "7-add-a-new-section-explicitely-list-spki-algids",
      "headRefOid": "7d649b8eb7e445921aeea6633571e8420d2c4f2d",
      "closedAt": "2024-07-08T15:43:37Z",
      "mergedAt": "2024-07-08T15:43:37Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "4b8da2388ecca2b2930400f0df5462ad901156e2"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a good start, but since these are fixed values, I think we should actually provide HEX DER encoded AlgorithmIDs for each row, then there is absolutely no ambiguity.",
          "createdAt": "2024-07-07T15:23:40Z",
          "updatedAt": "2024-07-07T15:23:40Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, once we have this sorted out here, we will need to do the same in composite-kems: https://github.com/lamps-wg/draft-composite-kem/issues/20",
          "createdAt": "2024-07-07T15:24:33Z",
          "updatedAt": "2024-07-07T15:24:33Z"
        },
        {
          "author": "janklaussner",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is a good start, but since these are fixed values, I think we should actually provide HEX DER encoded AlgorithmIDs for each row, then there is absolutely no ambiguity.\r\n\r\nYou mean in the appendix? These values are not fed into the signature, they just help to identify the component algorithm used. Is your point that providing DER OID values instead of ASN.1 OIDs helps the implementer with this?",
          "createdAt": "2024-07-08T07:52:50Z",
          "updatedAt": "2024-07-08T07:52:50Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "@ounsworth  I don't understand why we would need to put hex encodings of the OIDS for the component signatures.  They are not used during the signature computation process.   We already hex encode the composite OIDs themselves which is a representation of the entire composite algorithm.  I think what Jan has here is fine.",
          "createdAt": "2024-07-08T12:32:08Z",
          "updatedAt": "2024-07-08T12:32:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL5eEDM6A911N",
          "commit": {
            "abbreviatedOid": "cdc6e20"
          },
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-08T15:32:26Z",
          "updatedAt": "2024-07-08T15:32:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOL5eEDM50n1iX",
      "title": "Addressing CW comments",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/18",
      "state": "MERGED",
      "author": "opencrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addressing CW comments in the different sections.",
      "createdAt": "2024-07-07T22:39:55Z",
      "updatedAt": "2024-07-08T16:54:59Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "4b8da2388ecca2b2930400f0df5462ad901156e2",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "1-carl-wallaces-comments-on-composite-signatures-v13",
      "headRefOid": "df9ef9eafbe77a8f4cc5f5787924d02fbba603ac",
      "closedAt": "2024-07-08T16:54:59Z",
      "mergedAt": "2024-07-08T16:54:59Z",
      "mergedBy": "johngray-dev",
      "mergeCommit": {
        "oid": "ac890f5c4f5bd2561df3c53a97b312bce0327023"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOL5eEDM5545xm",
      "title": "Added context string consideration",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/38",
      "state": "OPEN",
      "author": "feventura",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added context string consideration, as defined in #35.",
      "createdAt": "2024-08-29T20:50:57Z",
      "updatedAt": "2024-08-30T12:46:30Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "32d88d9e083ab25bbbe61a8febae922ae9509824",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "issue-35",
      "headRefOid": "2c81704578bd45d89caecaa36fe2fe6679f62cf6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOL5eEDM57K0KL",
      "title": "Update version to use ML-DSA standard version",
      "url": "https://github.com/lamps-wg/draft-composite-sigs/pull/41",
      "state": "OPEN",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Upped the version of the OIDs and domain separators.\r\nCloses #37 ",
      "createdAt": "2024-09-11T14:10:02Z",
      "updatedAt": "2024-09-11T14:10:02Z",
      "baseRepository": "lamps-wg/draft-composite-sigs",
      "baseRefName": "main",
      "baseRefOid": "0c5ced7b63a14467cb501eb415cdcb5b7cdc90b4",
      "headRepository": "lamps-wg/draft-composite-sigs",
      "headRefName": "mldsa-standardized",
      "headRefOid": "1fa995acb090cbe7fc4a7d020fc5257591e7fd50",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}




LAMPS                                                       M. Ounsworth
Internet-Draft                                                   J. Gray
Intended status: Standards Track                                 Entrust
Expires: 4 September 2025                                        M. Pala
                                                             OpenCA Labs
                                                            J. Klaussner
                                                    Bundesdruckerei GmbH
                                                              S. Fluhrer
                                                           Cisco Systems
                                                            3 March 2025


  Composite ML-DSA for use in X.509 Public Key Infrastructure and CMS
               draft-ietf-lamps-pq-composite-sigs-latest

Abstract

   This document defines combinations of ML-DSA [FIPS.204] in hybrid
   with traditional algorithms RSASSA-PKCS1-v1_5, RSASSA-PSS, ECDSA,
   Ed25519, and Ed448.  These combinations are tailored to meet security
   best practices and regulatory requirements.  Composite ML-DSA is
   applicable in any application that uses X.509, PKIX, and CMS data
   structures and protocols that accept ML-DSA, but where the operator
   wants extra protection against breaks or catastrophic bugs in ML-DSA.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://lamps-
   wg.github.io/draft-composite-sigs/draft-ietf-lamps-pq-composite-
   sigs.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-ietf-lamps-pq-composite-sigs/.

   Discussion of this document takes place on the LAMPS Working Group
   mailing list (mailto:spams@ietf.org), which is archived at
   https://datatracker.ietf.org/wg/lamps/about/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/spams/.

   Source for this draft and an issue tracker can be found at
   https://github.com/lamps-wg/draft-composite-sigs.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 4 September 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Changes in -04
   2.  Introduction
     2.1.  Conventions and Terminology
     2.2.  Composite Design Philosophy
   3.  Overview of the Composite ML-DSA Signature Scheme
     3.1.  Pure vs Pre-hashed modes
   4.  Composite ML-DSA Functions
     4.1.  Key Generation
     4.2.  Pure Signature Mode
       4.2.1.  Composite-ML-DSA.Sign
       4.2.2.  Composite-ML-DSA.Verify
     4.3.  PreHash-Signature Mode
       4.3.1.  HashComposite-ML-DSA-Sign signature mode
       4.3.2.  HashComposite-ML-DSA-Verify
     4.4.  SerializeKey and DeserializeKey
     4.5.  SerializeSignatureValue and DeSerializeSignatureValue
     4.6.  ML-DSA public key, private key and signature sizes for
           serialization and deserialization
   5.  Composite Key Structures
     5.1.  CompositeMLDSAPublicKey
     5.2.  CompositeMLDSAPrivateKey
     5.3.  Encoding Rules
     5.4.  Key Usage Bits
   6.  Composite Signature Structures
     6.1.  sa-CompositeSignature
     6.2.  CompositeSignatureValue
   7.  Algorithm Identifiers
     7.1.  PureComposite-ML-DSA Algorithm Identifiers
     7.2.  HashComposite-ML-DSA Algorithm Identifiers
     7.3.  Domain Separators
     7.4.  Rationale for choices
     7.5.  RSASSA-PSS
       7.5.1.  RSA2048-PSS
       7.5.2.  RSA3072-PSS
       7.5.3.  RSA4096-PSS
   8.  Use in CMS
     8.1.  Underlying Components
     8.2.  SignedData Conventions
     8.3.  Signature generation and verification
     8.4.  Certificate Conventions
     8.5.  SMIMECapabilities Attribute Conventions
   9.  ASN.1 Module
   10. IANA Considerations
     10.1.  Object Identifier Allocations
       10.1.1.  Module Registration - SMI Security for PKIX Module
               Identifier
       10.1.2.  Object Identifier Registrations - SMI Security for
               PKIX Algorithms
   11. Security Considerations
     11.1.  Why Hybrids?
     11.2.  Non-separability and EUF-CMA
     11.3.  Key Reuse
     11.4.  Policy for Deprecated and Acceptable Algorithms
     11.5.  Use of Prefix to for attack mitigation
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Samples
     A.1.  Explicit Composite Signature Examples
   Appendix B.  Component Algorithm Reference
   Appendix C.  Component AlgorithmIdentifiers for Public Keys and
           Signatures
   Appendix D.  Implementation Considerations
     D.1.  FIPS certification
     D.2.  Backwards Compatibility
       D.2.1.  Hybrid Extensions (Keys and Signatures)
   Appendix E.  Intellectual Property Considerations
   Appendix F.  Contributors and Acknowledgements
     F.1.  Making contributions
   Authors' Addresses

1.  Changes in -04

   Interop-affecting changes:

   *  Remove the ASN.1 SEQUENCE Wrapping around the Public Keys, Private
      Keys and Composite Signature Value

   *  Added a prefix into the message format to allow traditional
      verifiers to detect if a composite signature has been stripped

   *  Added a fixed 4-byte length value to identify the length of the
      first ML-DSA component so keys and signatures can be separated

   *  Issued new prototype OIDs for testing purposes since the above
      changes break backwards compatiblity with version -03

   Editorial changes: * Added normative language to make it clear that
   key reuse is prohibited * Updated the security considerations section

2.  Introduction

   The advent of quantum computing poses a significant threat to current
   cryptographic systems.  Traditional cryptographic algorithms such as
   RSA, Diffie-Hellman, DSA, and their elliptic curve variants are
   vulnerable to quantum attacks.  During the transition to post-quantum
   cryptography (PQC), there is considerable uncertainty regarding the
   robustness of both existing and new cryptographic algorithms.  While
   we can no longer fully trust traditional cryptography, we also cannot
   immediately place complete trust in post-quantum replacements until
   they have undergone extensive scrutiny and real-world testing to
   uncover and rectify potential implementation flaws.

   Unlike previous migrations between cryptographic algorithms, the
   decision of when to migrate and which algorithms to adopt is far from
   straightforward.  Even after the migration period, it may be
   advantageous for an entity's cryptographic identity to incorporate
   multiple public-key algorithms to enhance security.

   Cautious implementers may opt to combine cryptographic algorithms in
   such a way that an attacker would need to break all of them
   simultaneously to compromise the protected data.  These mechanisms
   are referred to as Post-Quantum/Traditional (PQ/T) Hybrids
   [I-D.ietf-pquip-pqt-hybrid-terminology].

   Certain jurisdictions are already recommending or mandating that PQC
   lattice schemes be used exclusively within a PQ/T hybrid framework.
   The use of Composite scheme provides a straightforward implementation
   of hybrid solutions compatible with (and advocated by) some
   governments and cybersecurity agencies [BSI2021].

   Composite ML-DSA is applicable in any application that would
   otherwise use ML-DSA, but wants the protection against breaks or
   catastrophic bugs in ML-DSA.

2.1.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.  These words may also appear in this
   document in lower case as plain English words, absent their normative
   meanings.

   This document is consistent with the terminology defined in
   [I-D.ietf-pquip-pqt-hybrid-terminology].  In addition, the following
   terminology is used throughout this document:

   *ALGORITHM*: The usage of the term "algorithm" within this document
   generally refers to any function which has a registered Object
   Identifier (OID) for use within an ASN.1 AlgorithmIdentifier.  This
   loosely, but not precisely, aligns with the definitions of
   "cryptographic algorithm" and "cryptographic scheme" given in
   [I-D.ietf-pquip-pqt-hybrid-terminology].

   *BER*: Basic Encoding Rules (BER) as defined in [X.690].

   *CLIENT*: Any software that is making use of a cryptographic key.
   This includes a signer, verifier, encrypter, decrypter.  This is not
   meant to imply any sort of client-server relationship between the
   communicating parties.

   *DER*: Distinguished Encoding Rules as defined in [X.690].

   *PKI*: Public Key Infrastructure, as defined in [RFC5280].

   *PUBLIC / PRIVATE KEY*: The public and private portion of an
   asymmetric cryptographic key, making no assumptions about which
   algorithm.

   *SIGNATURE*: A digital cryptographic signature, making no assumptions
   about which algorithm.

2.2.  Composite Design Philosophy

   [I-D.ietf-pquip-pqt-hybrid-terminology] defines composites as:

      _Composite Cryptographic Element_: A cryptographic element that
      incorporates multiple component cryptographic elements of the same
      type in a multi-algorithm scheme.

   Composite keys, as defined here, follow this definition and should be
   regarded as a single key that performs a single cryptographic
   operation such as key generation, signing, verifying, encapsulating,
   or decapsulating -- using its internal sequence of component keys as
   if they form a single key.  This generally means that the complexity
   of combining algorithms can and should be handled by the
   cryptographic library or cryptographic module, and the single
   composite public key, private key, ciphertext and signature can be
   carried in existing fields in protocols such as PKCS#10 [RFC2986],
   CMP [RFC4210], X.509 [RFC5280], CMS [RFC5652], and the Trust Anchor
   Format [RFC5914].  In this way, composites achieve "protocol
   backwards-compatibility" in that they will drop cleanly into any
   protocol that accepts an analogous single-algorithm cryptographic
   scheme without requiring any modification of the protocol to handle
   multiple algorithms.

3.  Overview of the Composite ML-DSA Signature Scheme

   Composite schemes are defined as cryptographic primitives that
   consist of three algorithms:

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.

   *  Sign(sk, Message) -> (signature): A signing algorithm which takes
      as input a secret key sk and a Message, and outputs a signature

   *  Verify(pk, Message, signature) -> true or false: A verification
      algorithm which takes as input a public key, a Message, and a
      signature and outputs true if the signature verifies correctly.
      Thus it proves the Message was signed with the secret key
      associated with the public key and verifies the integrity of the
      Message.  If the signature and public key cannot verify the
      Message, it returns false.

   We define the following algorithms which we use to serialize and
   deserialize the public and private keys

   *  SerializeKey(key) -> bytes: Produce a fixed-length byte string
      encoding the public or private key.

   *  DeserializeKey(bytes) -> pk: Parse a fixed-length byte string to
      recover a public or private key.  This function can fail if the
      input byte string is malformed.

   We define the following algorithms which are used to serialize and
   deseralize the composite signature value

   *  SerializeSignatureValue(CompositeSignatureValue) -> bytes: Produce
      a fixed-length byte string encoding the CompositeSignatureValue.

   *  DeserializeSignatureValue(bytes) -> pk: Parse a fixed-length byte
      string to recover a CompositeSignatureValue.  This function can
      fail if the input byte string is malformed.

   A composite signature allows the security properties of the two
   underlying algorithms to be combined via standard signature
   operations Sign() and Verify().

   This specification uses the Post-Quantum signature scheme ML-DSA as
   specified in [FIPS.204] and [I-D.ietf-lamps-dilithium-certificates].
   For Traditional signature schemes, this document uses the RSASSA-
   PKCS1-v1_5 and RSASSA-PSS algorithms defined in [RFC8017], the
   Elliptic Curve Digital Signature Algorithm ECDSA scheme defined in
   section 6 of [FIPS.186-5], and Ed25519 / Ed448 which are defined in
   [RFC8410].  A simple "signature combiner"function which prepends a
   domain separator value specific to the composite algorithm is used to
   bind the two component signatures to the composite algorithm and
   achieve weak non-separability.

3.1.  Pure vs Pre-hashed modes

   In [FIPS.204] NIST defined ML-DSA to have both pure and pre-hashed
   signing modes, referred to as "ML-DSA" and "HashML-DSA" respectively.
   Following this, this document defines "Composite-ML-DSA" and
   "HashComposite-ML-DSA" which mirror the external functions defined in
   [FIPS.204].

4.  Composite ML-DSA Functions

4.1.  Key Generation

   To generate a new keypair for Composite schemes, the KeyGen() -> (pk,
   sk) function is used.  The KeyGen() function calls the two key
   generation functions of the component algorithms for the Composite
   keypair in no particular order.  Multi-process or multi-threaded
   applications might choose to execute the key generation functions in
   parallel for better key generation performance.

   The following process is used to generate composite keypair values:

   KeyGen() -> (pk, sk)

   Explicit inputs:

     None

   Implicit inputs:

     ML-DSA     A placeholder for the specific ML-DSA algorithm and
                parameter set to use, for example, could be "ML-DSA-65".

     Trad       A placeholder for the specific traditional algorithm and
                parameter set to use, for example "RSASSA-PSS"
                or "Ed25519".

   Output:

     (pk, sk)   The composite keypair.

   Key Generation Process:

     1. Generate component keys

         (mldsaPK, mldsaSK) = ML-DSA.KeyGen()
         (tradPK, tradSK)   = Trad.KeyGen()

     2. Check for component key gen failure

         if NOT (mldsaPK, mldsaSK) or NOT (tradPK, tradSK):
           output "Key generation error"

     3. Encode the component keys into composite structures

         pk = CompositeSignaturePublicKey(mldsaPK, tradPK)
         sk = CompositeSignaturePrivateKey(mldsaSK, tradSK)

     4. Output the composite keys

         return (pk, sk)

                     Figure 1: Composite KeyGen(pk, sk)

   The structures CompositeSignaturePublicKey and
   CompositeSignaturePrivateKey are described in Section 5.1 and
   Section 5.2 respectively and are used here as placeholders since
   implementations MAY use their own internal key representations in
   cases where interoperability is not required.

   In order to ensure fresh keys, the key generation functions MUST be
   executed for both component algorithms.  Compliant parties MUST NOT
   use, import or export component keys that are used in other contexts,
   combinations, or by themselves as keys for standalone algorithm use.
   For more details on the security considerations around key reuse, see
   section Section 11.3.

   Note that in step 2 above, both component key generation processes
   are invoked, and no indication is given about which one failed.  This
   SHOULD be done in a timing-invariant way to prevent side-channel
   attackers from learning which component algorithm failed.

4.2.  Pure Signature Mode

   This mode mirrors ML-DSA defined in Sections 5.2 and 5.3 of
   [FIPS.204].

   In the pure mode the Domain separator value is concatenated with the
   length of the context in bytes, the context, and the message to be
   signed.  After that, the signature process for each component
   algorithm is invoked and the values are then placed in the
   CompositeSignatureValue structure defined in Section 6.1.

   A composite signature's value MUST include two signature components
   and MUST be in the same order as the components from the
   corresponding signing key.

4.2.1.  Composite-ML-DSA.Sign

   This mode mirrors ML-DSA.Sign(sk, M, ctx) defined in Algorithm 2 in
   Section 5.2 of [FIPS.204].

Composite-ML-DSA.Sign (sk, M, ctx) -> (signature)

Explicit inputs:

  sk    Composite private key consisting of signing private keys for
        each component.

  M     The Message to be signed, an octet string.

  ctx   The Message context string, which defaults to the empty string.



Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSASSA-PSS with id-sha256"
           or "Ed25519".

  Domain   Domain separator value for binding the signature to the
           Composite OID. See section on Domain Separators below.

  Prefix   The prefix String which is the byte encoding of the String
           "CompositeAlgorithmSignatures2025" which in hex is
           436F6D706F73697465416C676F726974686D5369676E61747572657332303235

Output:

  signature   The composite signature, a CompositeSignatureValue.

Signature Generation Process:

  1. If |ctx| > 255:
      return error

  2. Compute the Message M'.

      M' = Prefix || Domain || len(ctx) || ctx || M

  3. Separate the private key into component keys.

      (mldsaSK, tradSK) = sk

  4. Generate the 2 component signatures independently, by calculating
     the signature over M' according to their algorithm specifications.

      mldsaSig = ML-DSA.Sign( mldsaSK, M', ctx=Domain )
      tradSig = Trad.Sign( tradSK, M' )

  5. If either ML-DSA.Sign() or Trad.Sign() return an error, then this
     process must return an error.

      if NOT mldsaSig or NOT tradSig:
        output "Signature generation error"

   6. Encode each component signature into a CompositeSignatureValue.

      signature = CompositeSignatureValue(mldsaSig, tradSig)

  7. Output signature

      return signature

             Figure 2: Composite-ML-DSA.Sign(sk, M, ctx)

   It is possible to use component private keys stored in separate
   software or hardware keystores.  Variations in the process to
   accommodate particular private key storage mechanisms are considered
   to be conformant to this document so long as it produces the same
   output and error handling as the process sketched above.

   Note that in step 5 above, both component signature processes are
   invoked, and no indication is given about which one failed.  This
   SHOULD be done in a timing-invariant way to prevent side-channel
   attackers from learning which component algorithm failed.

4.2.2.  Composite-ML-DSA.Verify

   This mode mirrors ML-DSA.Verify(pk, M, signature, ctx) defined in
   Algorithm 3 in Section 5.3 of [FIPS.204].

   Compliant applications MUST output "Valid signature" (true) if and
   only if all component signatures were successfully validated, and
   "Invalid signature" (false) otherwise.

Composite-ML-DSA.Verify(pk, M, signature, ctx)

Explicit inputs:

  pk          Composite public key consisting of verification public keys
              for each component.

  M           Message whose signature is to be verified,
              an octet string.

  signature   CompositeSignatureValue containing the component
              signature values (mldsaSig and tradSig) to be verified.

  ctx         The Message context string, which defaults to the empty
              string.

Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSASSA-PSS with id-sha256"
           or "Ed25519".

  Domain   Domain separator value for binding the signature to the
           Composite OID. See section on Domain Separators below.

  Prefix   The prefix String which is the byte encoding of the String
           "CompositeAlgorithmSignatures2025" which in hex is
           436F6D706F73697465416C676F726974686D5369676E61747572657332303235


Output:
    Validity (bool)    "Valid signature" (true) if the composite
                        signature is valid, "Invalid signature"
                        (false) otherwise.

Signature Verification Process:

  1. If |ctx| > 255
      return error

  2. Separate the keys and signatures

        (pk1, pk2) = pk
        (s1, s2)   = signature

    If Error during Desequencing, or if any of the component
    keys or signature values are not of the correct key type or
    length for the given component algorithm then output
    "Invalid signature" and stop.

  3. Compute the Message M'.

        M' = Prefix || Domain || len(ctx) || ctx || M

  4. Check each component signature individually, according to its
     algorithm specification.
     If any fail, then the entire signature validation fails.

        if not ML-DSA.Verify( pk1, M', s1, ctx=Domain) then
          output "Invalid signature"

        if not Trad.Verify( pk2, M', s2) then
          output "Invalid signature"

        if all succeeded, then
          output "Valid signature"

  Figure 3: Composite-ML-DSA.Verify(pk, Message, signature, Context)

   Note that in step 4 above, the function fails early if the first
   component fails to verify.  Since no private keys are involved in a
   signature verification, there are no timing attacks to consider, so
   this is ok.

4.3.  PreHash-Signature Mode

   This mode mirrors HashML-DSA defined in Section 5.4 of [FIPS.204].

   In the pre-hash mode the Domain separator Section 7.3 is concatenated
   with the length of the context in bytes, the context, an additional
   DER encoded value that represents the OID of the Hash function and
   finally the hash of the message to be signed.  After that, the
   signature process for each component algorithm is invoked and the
   values are then placed in the CompositeSignatureValue structure
   defined in Section 6.1.

   A composite signature's value MUST include two signature components
   and MUST be in the same order as the components from the
   corresponding signing key.

4.3.1.  HashComposite-ML-DSA-Sign signature mode

   This mode mirrors HashML-DSA.Sign(sk, M, ctx, PH) defined in
   Algorithm 4 Section 5.4.1 of [FIPS.204].

   In the pre-hash mode the Domain separator (see Section 7.3) is
   concatenated with the length of the context in bytes, the context, an
   additional DER encoded value that indicates which Hash function was
   used for the pre-hash and finally the pre-hashed message PH(M).

HashComposite-ML-DSA.Sign (sk, M, ctx, PH) -> (signature)

Explicit inputs:

  sk    Composite private key consisting of signing private keys for
        each component.

  M     The Message to be signed, an octet string.

  ctx   The Message context string, which defaults to the empty string

  PH    The Message Digest Algorithm for pre-hashing.  See
        section on pre-hashing the message below.

Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSASSA-PSS with id-sha256"
           or "Ed25519".

 Prefix    The prefix String which is the byte encoding of the String
           "CompositeAlgorithmSignatures2025" which in hex is
           436F6D706F73697465416C676F726974686D5369676E61747572657332303235

 Domain    Domain separator value for binding the signature to the
           Composite OID. See section on Domain Separators below.

 HashOID   The DER Encoding of the Object Identifier of the
           PreHash algorithm (PH) which is passed into the function.

Output:
  signature   The composite signature, a CompositeSignatureValue.

Signature Generation Process:

  1. If |ctx| > 255:
      return error

  2. Compute the Message format M'.

        M' :=  Prefix || Domain || len(ctx) || ctx || HashOID || PH(M)

  3. Separate the private key into component keys.

       (mldsaSK, tradSK) = sk

  4. Generate the 2 component signatures independently, by calculating
     the signature over M' according to their algorithm specifications.

       mldsaSig = ML-DSA.Sign( mldsaSK, M', ctx=Domain )
       tradSig = Trad.Sign( tradSK, M' )

  5. If either ML-DSA.Sign() or Trad.Sign() return an error, then this
     process must return an error.

      if NOT mldsaSig or NOT tradSig:
        output "Signature generation error"

  6. Encode each component signature into a CompositeSignatureValue.

      signature := CompositeSignatureValue(mldsaSig, tradSig)

  7. Output signature

      return signature

         Figure 4: HashComposite-ML-DSA.Sign(sk, M, ctx, PH)

   It is possible to use component private keys stored in separate
   software or hardware keystores.  Variations in the process to
   accommodate particular private key storage mechanisms are considered
   to be conformant to this document so long as it produces the same
   output and error handling as the process sketched above.

   Note that in step 5 above, both component signature processes are
   invoked, and no indication is given about which one failed.  This
   SHOULD be done in a timing-invariant way to prevent side-channel
   attackers from learning which component algorithm failed.

4.3.2.  HashComposite-ML-DSA-Verify

   This mode mirrors HashML-DSA.Verify(pk, M, signature, ctx, PH)
   defined in Section 5.4.1 of [FIPS.204].

   Compliant applications MUST output "Valid signature" (true) if and
   only if all component signatures were successfully validated, and
   "Invalid signature" (false) otherwise.

HashComposite-ML-DSA.Verify(pk, M, signature, ctx, PH)

Explicit inputs:

  pk          Composite public key consisting of verification public
              keys for each component.

  M           Message whose signature is to be verified, an octet
              string.

  signature   CompositeSignatureValue containing the component
              signature values (mldsaSig and tradSig) to be verified.

  ctx         The Message context string, which defaults to the empty
              string.

  PH          The Message Digest Algorithm for pre-hashing. See
              section on pre-hashing the message below.

Implicit inputs:

  ML-DSA    A placeholder for the specific ML-DSA algorithm and
            parameter set to use, for example, could be "ML-DSA-65".

  Trad      A placeholder for the specific traditional algorithm and
            parameter set to use, for example "RSASSA-PSS with id-sha256"
            or "Ed25519".

  Prefix    The prefix String which is the byte encoding of the String
            "CompositeAlgorithmSignatures2025" which in hex is
            436F6D706F73697465416C676F726974686D5369676E61747572657332303235

  Domain    Domain separator value for binding the signature to the
            Composite OID. See section on Domain Separators below.

  HashOID   The DER Encoding of the Object Identifier of the
            PreHash algorithm (PH) which is passed into the function.

Output:

  Validity (bool)   "Valid signature" (true) if the composite
                    signature is valid, "Invalid signature"
                    (false) otherwise.

Signature Verification Process:

  1. If |ctx| > 255
       return error

  2. Separate the keys and signatures

     (pk1, pk2) = pk
      (s1, s2) = signature

   If Error during Desequencing, or if any of the component
   keys or signature values are not of the correct key type or
   length for the given component algorithm then output
   "Invalid signature" and stop.

  3. Compute a Hash of the Message.

      M' = Prefix || Domain || len(ctx) || ctx || HashOID || PH(M)

  4. Check each component signature individually, according to its
     algorithm specification.
     If any fail, then the entire signature validation fails.

      if not ML-DSA.Verify( pk1, M', s1, ctx=Domain ) then
          output "Invalid signature"

      if not Trad.Verify( pk2, M', s2 ) then
          output "Invalid signature"

      if all succeeded, then
         output "Valid signature"

   Figure 5: HashComposite-ML-DSA.Verify(pk, M, signature, ctx, PH)

   Note that in step 4 above, the function fails early if the first
   component fails to verify.  Since no private keys are involved in a
   signature verification, there are no timing attacks to consider, so
   this is ok.

4.4.  SerializeKey and DeserializeKey

   The serialization routine for keys simply concatenates the public or
   private keys of the component signatures, as defined below:

 Composite-ML-DSA.SerializeKey(key) -> bytes

 Explicit Input:

   key    Composite ML-DSA public key or private key

 Implicit inputs:

   ML-DSA   A placeholder for the specific ML-DSA algorithm and
            parameter set to use, for example, could be "ML-DSA-65".

   Trad     A placeholder for the specific traditional algorithm and
            parameter set to use, for example "RSA" or "ECDSA".

   IntegerToBytes  A function that takes an Integer and converts it to
            a byte representation of size byteLength.  See definition in
            [FIPS.204]

 Output:

   bytes   The encoded public key or private key

 Serialization Process:

   1. Separate the  keys

      (mldsaKey, tradKey) = key

   2. Serialize each of the constituent public keys

      mldsaEncodedKey = MLDSA.SerializeKey(mldsaKey)
      tradEncodedKey = Trad.SerializeKey(tradKey)

   3. Calculate the length encoding of the mldsaEncodedPK

      If (mldsaEncodeKey.length) > 2^32
          then output "message too long" and stop.

      encodedLength = IntegerToBytes(mldsaEncodeKey.length, 4)

   4. Combine and output the encoded public key

      bytes = encodedLength || mldsaEncodedPK || tradEncodedPK
      output bytes

                  Figure 6: Composite SerializeKey(pk)

   Deserialization reverses this process, raising an error in the event
   that the input is malformed.

Composite-ML-DSA.DeserializeKey(bytes) -> pk

Explicit Input:

  bytes   An encoded public key or private key

Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSA" or "ECDSA".

Output:

  key     The composite ML-DSA public key or private key

Deserialization Process:

  1. Validate the length of the the input byte string

     if bytes is not the correct length:
      output "Deserialization error"

  2. Parse each constituent encoded key.
       The first 4 bytes encodes the length of mldsaEncodedKey, which MAY
       be used to separate the mldsaEncodedKey and tradEncodedKey, and then
       is to be discarded.  This length SHOULD be checked against the
       expected length value as per ML-DSA.

     (mldsaEncodedKey, tradEncodedKey) = bytes

  3. Deserialize the constituent public or private keys

     mldsaKey = MLDSA.DeserializeKey(mldsaEncodedKey)
     tradKey = Trad.DeserializeKey(tradEncodedKey)

  4. If either ML-DSA.DeserializeKey() or
     Trad.DeserializeKey() return an error,
     then this process must return an error.

      if NOT mldsaKey or NOT tradKey:
        output "Deserialization error"

  5. Output the composite ML-DSA key

     output (mldsaPK, tradPK)

              Figure 7: Composite DeserializeKey(bytes)

4.5.  SerializeSignatureValue and DeSerializeSignatureValue

   The serialization routine for the CompositeSignatureValue simply
   concatenates the ML-DSA signature value with the signature value from
   the traditional algorithm, as defined below:

Composite-ML-DSA.SerializeSignatureValue(CompositeSignatureValue) -> bytes

Explicit Input:

  CompositeSignatureValue    The Composite Signature Value obtained from Composite-ML-DSA.Sign()

Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSA" or "ECDSA".

  IntegerToBytes  A function that takes an Integer and converts it to
           a byte representation of size byteLength.  See definition in
           [FIPS.204]

Output:

  bytes   The encoded CompositeSignatureValue

Serialization Process:

  1. Separate the signatures

     (mldsaSig, tradSig) = CompositeSignatureValue

  2. Serialize each of the constituent signatures

     mldsaEncodedSignature = ML-DSA.SerializeSignature(mldsaSig)
     tradEncodedSignature = Trad.SerializeSignature(tradSig)

  3. Calculate the length encoding of the mldsaEncodedSignature

     If (mldsaEncodeKey.length) > 2^32
         then output "message too long" and stop.

     encodedLength = IntegerToBytes(mldsaEncodeKey.length, 4)
     encodedLength = IntegerToBytes(mldsaEncodedSignature.length, 4)

  4. Combine and output the encoded composite signature

     bytes = encodedLength || mldsaEncodedSignature || tradEncodedSignature
     output bytes

 Figure 8: Composite SerializeSignatureValue(CompositeSignatureValue)

   Deserialization reverses this process, raising an error in the event
   that the input is malformed.

Composite-ML-DSA.DeserializeSignatureValue(bytes) -> CompositeSignatureValue

Explicit Input:

  bytes   An encoded CompositeSignatureValue

Implicit inputs:

  ML-DSA   A placeholder for the specific ML-DSA algorithm and
           parameter set to use, for example, could be "ML-DSA-65".

  Trad     A placeholder for the specific traditional algorithm and
           parameter set to use, for example "RSA" or "ECDSA".

Output:

  CompositeSignatureValue  The CompositeSignatureValue

Deserialization Process:

  1. Validate the length of the the input byte string

     if bytes is not the correct length:
      output "Deserialization error"

  2. Parse each constituent encoded signature.
       The first 4 bytes encodes the length of mldsaEncodedSignature, which MAY
       be used to separate the mldsaEncodedSignature and tradEncodedSignature,
       and then is to be discarded.  The mldsaEncodedSignature length SHOULD
       be checked against the expected length value as per ML-DSA.

     (mldsaEncodedSignature, tradEncodedSignature) = bytes

  3. Deserialize the constituent signature values

     mldsaSig = ML-DSA.DeserializeSignature(mldsaEncodedSignature)
     tradSig = Trad.DeserializeSignature(tradEncodedSignature)

  4. If either ML-DSA.DeserializeSignature() or
     Trad.DeserializeSignature() return an error,
     then this process must return an error.

      if NOT mldsaSig or NOT tradSig:
        output "Deserialization error"

  5. Output the CompositeSignatureValue

     output (mldsaSig, tradSig)

         Figure 9: Composite DeserializeSignatureValue(bytes)

4.6.  ML-DSA public key, private key and signature sizes for
      serialization and deserialization

   As noted above, the composite public key, composite private key and
   composite signature value serialization and deserialization methods
   use a fixed 4-byte length value to indicate the size of the first
   component.  This is to allow the separation of the first component
   from the second component.  It is RECOMMENDED that the length
   specified for the first component be checked against the values from
   the table below to ensure the encoding has been done propertly.

   If future composite combinations make use of algorithms where the
   first component uses variable length keys or signatures, then this
   fixed 4-byte length value can be used to ensure the components are
   correctly deserialized.

   The following table shows the possible length values in bytes for the
   public, private and signature sizes for ML-DSA which can be used to
   deserialzie the components.

        +===========+============+====================+===========+
        | Algorithm | Public key | Private key        | Signature |
        +===========+============+====================+===========+
        | ML-DSA-44 | 1312       | 32 or 2560 or 2592 | 2420      |
        +-----------+------------+--------------------+-----------+
        | ML-DSA-65 | 1952       | 32 or 4032 or 4064 | 3309      |
        +-----------+------------+--------------------+-----------+
        | ML-DSA-87 | 2592       | 32 or 4896 or 4928 | 4627      |
        +-----------+------------+--------------------+-----------+

              Table 1: ML-DSA Key and Signature Sizes in bytes

5.  Composite Key Structures

   In order to form composite public keys and signature values, we
   define ASN.1-based composite encodings such that these structures can
   be used as a drop-in replacement for existing public key and
   signature fields such as those found in PKCS#10 [RFC2986], CMP
   [RFC4210], X.509 [RFC5280], CMS [RFC5652].

5.1.  CompositeMLDSAPublicKey

   The wire encoding of a Composite ML-DSA public key is:

   CompositeMLDSAPublicKey ::= BIT STRING

   Since RSA and ECDSA component public keys are themselves in a DER
   encoding, the following show the internal structure of the various
   public key types used in this specification:

   When a CompositeMLDSAPublicKey is used with an RSA public key, the
   BIT STRING is generated by the concatenation of a raw ML-DSA key
   according to [I-D.ietf-lamps-dilithium-certificates], and an
   RSAPublicKey (which is a DER encoded RSAPublicKey).

   When a CompositeMLDSAPublicKey is used with an EC public key, the BIT
   STRING is generated by the concatenation of a raw ML-DSA key
   according to [I-D.ietf-lamps-dilithium-certificates] and an
   ECDSAPublicKey (which is a DER encoded ECPoint).

   When a CompositeMLDSAPublicKey is used with an Edwards public key,
   the BIT STRING is generated by the concatenation of a raw ML-DSA key
   according to [I-D.ietf-lamps-dilithium-certificates] and a raw
   Edwards public key according to [RFC8410].

   Some applications may need to reconstruct the SubjectPublicKeyInfo
   objects corresponding to each component public key.  Table 2 or
   Table 3 in Section 7 provides the necessary mapping between composite
   and their component algorithms for doing this reconstruction.

   When the CompositeMLDSAPublicKey must be provided in octet string or
   bit string format, the data structure is encoded as specified in
   Section 5.3.

   Component keys of a CompositeMLDSAPublicKey MUST NOT be used in any
   other type of key or as a standalone key.  For more details on the
   security considerations around key reuse, see section Section 11.3.

   The following ASN.1 Information Object Class is defined to allow for
   compact definitions of each composite algorithm, leading to a smaller
   overall ASN.1 module.

   pk-CompositeSignature {OBJECT IDENTIFIER:id, PublicKeyType}
       PUBLIC-KEY ::= {
         IDENTIFIER id
         KEY PublicKeyType
         PARAMS ARE absent
         CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign}
       }

   As an example, the public key type id-MLDSA44-ECDSA-P256 is defined
   as:

   id-MLDSA44-ECDSA-P256 PUBLIC-KEY ::=
     pk-CompositeSignature{
       id-MLDSA44-ECDSA-P256,
       CompositeMLDSAPublicKey }

   The full set of key types defined by this specification can be found
   in the ASN.1 Module in Section 9.

5.2.  CompositeMLDSAPrivateKey

   When a Composite ML-DSA private key is to be exported from a
   cryptographic module, it uses an analogous definition to the public
   keys:

   CompositeMLDSAPrivateKey ::= OCTET STRING

   Each element of the CompositeMLDSAPrivateKey is an OCTET STRING
   according to the encoding of the underlying algorithm specification
   and will decode into the respective private key structures in an
   analogous way to the public key structures defined in Section 5.1.
   The ASN.1 module in this document does not provide helper classes for
   private keys.  The PrivateKey for each component algorithm MUST be in
   the same order as defined in Section 5.1.

   Use cases that require an interoperable encoding for composite
   private keys will often need to place a CompositeMLDSAPrivateKey
   inside a OneAsymmetricKey structure defined in [RFC5958], such as
   when private keys are carried in PKCS #12 [RFC7292], CMP [RFC4210] or
   CRMF [RFC4211].  The definition of OneAsymmetricKey is copied here
   for convenience:

    OneAsymmetricKey ::= SEQUENCE {
          version                   Version,
          privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
          privateKey                PrivateKey,
          attributes            [0] Attributes OPTIONAL,
          ...,
          [[2: publicKey        [1] PublicKey OPTIONAL ]],
          ...
        }
     ...
     PrivateKey ::= OCTET STRING
                           -- Content varies based on type of key.  The
                           -- algorithm identifier dictates the format of
                           -- the key.

   When a CompositeMLDSAPrivateKey is conveyed inside a OneAsymmetricKey
   structure (version 1 of which is also known as PrivateKeyInfo)
   [RFC5958], the privateKeyAlgorithm field SHALL be set to the
   corresponding composite algorithm identifier defined according to
   Section 7 and its parameters field MUST be absent.  The privateKey
   field SHALL contain the CompositeMLDSAPrivateKey, and the publicKey
   field remains OPTIONAL.  If the publicKey field is present, it MUST
   be a CompositeMLDSAPublicKey.

   Some applications may need to reconstruct the OneAsymmetricKey
   objects corresponding to each component private key.  Section 7
   provides the necessary mapping between composite and their component
   algorithms for doing this reconstruction.

   Component keys of a CompositeMLDSAPrivateKey MUST NOT be used in any
   other type of key or as a standalone key.  For more details on the
   security considerations around key reuse, see section Section 11.3.

5.3.  Encoding Rules

   Many protocol specifications will require that the composite public
   key and composite private key data structures be represented by an
   octet string or bit string.

   When an octet string is required, the DER encoding of the composite
   data structure SHALL be used directly.

   When a bit string is required, the octets of the DER encoded
   composite data structure SHALL be used as the bits of the bit string,
   with the most significant bit of the first octet becoming the first
   bit, and so on, ending with the least significant bit of the last
   octet becoming the last bit of the bit string.

   In the interests of simplicity and avoiding compatibility issues,
   implementations that parse these structures MAY accept both BER and
   DER.

5.4.  Key Usage Bits

   When any of the Composite ML-DSA AlgorithmIdentifier appears in the
   SubjectPublicKeyInfo field of an X.509 certificate [RFC5280], the key
   usage certificate extension MUST only contain only signing-type key
   usages.

   The normal keyUsage rules for signing-type keys from [RFC5280] apply,
   and are reproduced here for completeness.

   For Certification Authority (CA) certificates that carry a composite
   public key, any combination of the following values MAY be present
   and any other values MUST NOT be present:

   digitalSignature;
   nonRepudiation;
   keyCertSign; and
   cRLSign.

   For End Entity certificates, any combination of the following values
   MAY be present and any other values MUST NOT be present:

   digitalSignature; and
   nonRepudiation;

   Composite ML-DSA keys MUST NOT be used in a "dual usage" mode because
   even if the traditional component key supports both signing and
   encryption, the post-quantum algorithms do not and therefore the
   overall composite algorithm does not.

6.  Composite Signature Structures

6.1.  sa-CompositeSignature

   The ASN.1 algorithm object for a composite signature is:

   sa-CompositeSignature{OBJECT IDENTIFIER:id,
      PUBLIC-KEY:publicKeyType }
         SIGNATURE-ALGORITHM ::=  {
            IDENTIFIER id
            VALUE CompositeSignatureValue
            PARAMS ARE absent
            PUBLIC-KEYS {publicKeyType}
         }

6.2.  CompositeSignatureValue

   The output of a Composite ML-DSA algorithm is the DER encoding of the
   following structure:

   The CompositeSignatureValue is the DER encoding of a concatenation of
   the signature values from the underlying component algorithms.  It is
   represented in ASN.1 as follows:

   CompositeSignatureValue ::= BIT STRING

   The order of the component signature values is the same as the order
   defined in Section 5.1.

7.  Algorithm Identifiers

   This table summarizes the list of Composite ML-DSA algorithms and
   lists the OID and the two component algorithms.  Domain separator
   values are defined below in Section 7.3.

   EDNOTE: these are prototyping OIDs to be replaced by IANA.

   <CompSig>.1 is equal to 2.16.840.1.114027.80.8.1.1

7.1.  PureComposite-ML-DSA Algorithm Identifiers

   Pure Composite-ML-DSA Signature public key types:

   +======================+============+=========+=======================+
   |Composite Signature   |OID         |First    |Second Algorithm       |
   |Algorithm             |            |Algorithm|                       |
   +======================+============+=========+=======================+
   |id-MLDSA44-RSA2048-PSS|<CompSig>.60|id-ML-   |id-RSASSA-PSS with id- |
   |                      |            |DSA-44   |sha256                 |
   +----------------------+------------+---------+-----------------------+
   |id-                   |<CompSig>.61|id-ML-   |sha256WithRSAEncryption|
   |MLDSA44-RSA2048-PKCS15|            |DSA-44   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA44-Ed25519    |<CompSig>.62|id-ML-   |id-Ed25519             |
   |                      |            |DSA-44   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA44-ECDSA-P256 |<CompSig>.63|id-ML-   |ecdsa-with-SHA256 with |
   |                      |            |DSA-44   |secp256r1              |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-RSA3072-PSS|<CompSig>.64|id-ML-   |id-RSASSA-PSS with id- |
   |                      |            |DSA-65   |sha256                 |
   +----------------------+------------+---------+-----------------------+
   |id-                   |<CompSig>.65|id-ML-   |sha256WithRSAEncryption|
   |MLDSA65-RSA3072-PKCS15|            |DSA-65   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-RSA4096-PSS|<CompSig>.66|id-ML-   |id-RSASSA-PSS with id- |
   |                      |            |DSA-65   |sha384                 |
   +----------------------+------------+---------+-----------------------+
   |id-                   |<CompSig>.67|id-ML-   |sha384WithRSAEncryption|
   |MLDSA65-RSA4096-PKCS15|            |DSA-65   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-ECDSA-P256 |<CompSig>.68|id-ML-   |ecdsa-with-SHA256 with |
   |                      |            |DSA-65   |secp256r1              |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-ECDSA-P384 |<CompSig>.69|id-ML-   |ecdsa-with-SHA384 with |
   |                      |            |DSA-65   |secp384r1              |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-ECDSA-     |<CompSig>.70|id-ML-   |ecdsa-with-SHA256 with |
   |brainpoolP256r1       |            |DSA-65   |brainpoolP256r1        |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA65-Ed25519    |<CompSig>.71|id-ML-   |id-Ed25519             |
   |                      |            |DSA-65   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA87-ECDSA-P384 |<CompSig>.72|id-ML-   |ecdsa-with-SHA384 with |
   |                      |            |DSA-87   |secp384r1              |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA87-ECDSA-     |<CompSig>.73|id-ML-   |ecdsa-with-SHA384 with |
   |brainpoolP384r1       |            |DSA-87   |brainpoolP384r1        |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA87-Ed448      |<CompSig>.74|id-ML-   |id-Ed448               |
   |                      |            |DSA-87   |                       |
   +----------------------+------------+---------+-----------------------+
   |id-MLDSA87-RSA4096-PSS|<CompSig>.75|id-ML-   |id-RSASSA-PSS with id- |
   |                      |            |DSA-87   |sha384                 |
   +----------------------+------------+---------+-----------------------+

            Table 2: Pure ML-DSA Composite Signature Algorithms

   See the ASN.1 module in section Section 9 for the explicit
   definitions of the above Composite ML-DSA algorithms.

   Full specifications for the referenced algorithms can be found in
   Appendix B.

7.2.  HashComposite-ML-DSA Algorithm Identifiers

   HashComposite-ML-DSA Signature public key types:

   +=================================+============+=========+=======================+======+
   |Composite Signature Algorithm    |OID         |First    |Second Algorithm       |Pre-  |
   |                                 |            |Algorithm|                       |Hash  |
   +=================================+============+=========+=======================+======+
   |id-HashMLDSA44-RSA2048-PSS-SHA256|<CompSig>.80|id-ML-   |id-RSASSA-PSS with id- |id-   |
   |                                 |            |DSA-44   |sha256                 |sha256|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-                              |<CompSig>.81|id-ML-   |sha256WithRSAEncryption|id-   |
   |HashMLDSA44-RSA2048-PKCS15-SHA256|            |DSA-44   |                       |sha256|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA44-Ed25519-SHA512    |<CompSig>.82|id-ML-   |id-Ed25519             |id-   |
   |                                 |            |DSA-44   |                       |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA44-ECDSA-P256-SHA256 |<CompSig>.83|id-ML-   |ecdsa-with-SHA256 with |id-   |
   |                                 |            |DSA-44   |secp256r1              |sha256|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-RSA3072-PSS-SHA512|<CompSig>.84|id-ML-   |id-RSASSA-PSS with id- |id-   |
   |                                 |            |DSA-65   |sha256                 |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-                              |<CompSig>.85|id-ML-   |sha256WithRSAEncryption|id-   |
   |HashMLDSA65-RSA3072-PKCS15-SHA512|            |DSA-65   |                       |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-RSA4096-PSS-SHA512|<CompSig>.86|id-ML-   |id-RSASSA-PSS with id- |id-   |
   |                                 |            |DSA-65   |sha384                 |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-                              |<CompSig>.87|id-ML-   |sha384WithRSAEncryption|id-   |
   |HashMLDSA65-RSA4096-PKCS15-SHA512|            |DSA-65   |                       |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-ECDSA-P256-SHA512 |<CompSig>.88|id-ML-   |ecdsa-with-SHA256 with |id-   |
   |                                 |            |DSA-65   |secp256r1              |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-ECDSA-P384-SHA512 |<CompSig>.89|id-ML-   |ecdsa-with-SHA384 with |id-   |
   |                                 |            |DSA-65   |secp384r1              |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-ECDSA-            |<CompSig>.90|id-ML-   |ecdsa-with-SHA256 with |id-   |
   |brainpoolP256r1-SHA512           |            |DSA-65   |brainpoolP256r1        |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA65-Ed25519-SHA512    |<CompSig>.91|id-ML-   |id-Ed25519             |id-   |
   |                                 |            |DSA-65   |                       |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA87-ECDSA-P384-SHA512 |<CompSig>.92|id-ML-   |ecdsa-with-SHA384 with |id-   |
   |                                 |            |DSA-87   |secp384r1              |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA87-ECDSA-            |<CompSig>.93|id-ML-   |ecdsa-with-SHA384 with |id-   |
   |brainpoolP384r1-SHA512           |            |DSA-87   |brainpoolP384r1        |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA87-Ed448-SHA512      |<CompSig>.94|id-ML-   |id-Ed448               |id-   |
   |                                 |            |DSA-87   |                       |sha512|
   +---------------------------------+------------+---------+-----------------------+------+
   |id-HashMLDSA87-RSA4096-PSS-SHA512|<CompSig>.95|id-ML-   |id-RSASSA-PSS with id- |id-   |
   |                                 |            |DSA-87   |sha384                 |sha512|
   +---------------------------------+------------+---------+-----------------------+------+

            Table 3: Hash ML-DSA Composite Signature Algorithms

   See the ASN.1 module in Section 9 for the explicit definitions of the
   above Composite ML-DSA algorithms.

   The Pre-Hash algorithm is used as the PH algorithm and the DER
   Encoded OID value of this Hash is used as HashOID for the Message
   format in step 2 of HashComposite-ML-DSA.Sign in section
   Section 4.3.1 and HashComposite-ML-DSA.Verify in Section 4.3.2.

   Full specifications for the referenced algorithms can be found in
   Appendix B.

7.3.  Domain Separators

   As mentioned above, the OID input value is used as a domain separator
   for the Composite Signature Generation and verification process and
   is the DER encoding of the OID.  The following table shows the HEX
   encoding for each Signature Algorithm.

     +==================================+============================+
     | Composite Signature Algorithm    | Domain Separator (in Hex   |
     |                                  | encoding)                  |
     +==================================+============================+
     | id-MLDSA44-RSA2048-PSS           | 060B6086480186FA6B5008013C |
     +----------------------------------+----------------------------+
     | id-MLDSA44-RSA2048-PKCS15        | 060B6086480186FA6B5008013D |
     +----------------------------------+----------------------------+
     | id-MLDSA44-Ed25519               | 060B6086480186FA6B5008013E |
     +----------------------------------+----------------------------+
     | id-MLDSA44-ECDSA-P256            | 060B6086480186FA6B5008013F |
     +----------------------------------+----------------------------+
     | id-MLDSA65-RSA3072-PSS           | 060B6086480186FA6B50080140 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-RSA3072-PKCS15        | 060B6086480186FA6B50080141 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-RSA4096-PSS           | 060B6086480186FA6B50080142 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-RSA4096-PKCS15        | 060B6086480186FA6B50080143 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-ECDSA-P256            | 060B6086480186FA6B50080144 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-ECDSA-P384            | 060B6086480186FA6B50080145 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-ECDSA-brainpoolP256r1 | 060B6086480186FA6B50080146 |
     +----------------------------------+----------------------------+
     | id-MLDSA65-Ed25519               | 060B6086480186FA6B50080147 |
     +----------------------------------+----------------------------+
     | id-MLDSA87-ECDSA-P384            | 060B6086480186FA6B50080148 |
     +----------------------------------+----------------------------+
     | id-MLDSA87-ECDSA-brainpoolP384r1 | 060B6086480186FA6B50080149 |
     +----------------------------------+----------------------------+
     | id-MLDSA87-Ed448                 | 060B6086480186FA6B5008014A |
     +----------------------------------+----------------------------+
     | id-MLDSA87-RSA4096-PSS           | 060B6086480186FA6B5008014B |
     +----------------------------------+----------------------------+

                                  Table 4

    +===================================+============================+
    | Composite Signature Algorithm     | Domain Separator (in Hex   |
    |                                   | encoding)                  |
    +===================================+============================+
    | id-HashMLDSA44-RSA2048-PSS-SHA256 | 060B6086480186FA6B50080150 |
    +-----------------------------------+----------------------------+
    | id-                               | 060B6086480186FA6B50080151 |
    | HashMLDSA44-RSA2048-PKCS15-SHA256 |                            |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA44-Ed25519-SHA512     | 060B6086480186FA6B50080152 |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA44-ECDSA-P256-SHA256  | 060B6086480186FA6B50080153 |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-RSA3072-PSS-SHA512 | 060B6086480186FA6B50080154 |
    +-----------------------------------+----------------------------+
    | id-                               | 060B6086480186FA6B50080155 |
    | HashMLDSA65-RSA3072-PKCS15-SHA512 |                            |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-RSA4096-PSS-SHA512 | 060B6086480186FA6B50080156 |
    +-----------------------------------+----------------------------+
    | id-                               | 060B6086480186FA6B50080157 |
    | HashMLDSA65-RSA4096-PKCS15-SHA512 |                            |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-ECDSA-P256-SHA512  | 060B6086480186FA6B50080158 |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-ECDSA-P384-SHA512  | 060B6086480186FA6B50080159 |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-ECDSA-             | 060B6086480186FA6B5008015A |
    | brainpoolP256r1-SHA512            |                            |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA65-Ed25519-SHA512     | 060B6086480186FA6B5008015B |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA87-ECDSA-P384-SHA512  | 060B6086480186FA6B5008015C |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA87-ECDSA-             | 060B6086480186FA6B5008015D |
    | brainpoolP384r1-SHA512            |                            |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA87-Ed448-SHA512       | 060B6086480186FA6B5008015E |
    +-----------------------------------+----------------------------+
    | id-HashMLDSA87-RSA4096-PSS-SHA512 | 060B6086480186FA6B5008015F |
    +-----------------------------------+----------------------------+

        Table 5: Hash ML-DSA Composite Signature Domain Separators

7.4.  Rationale for choices

   In generating the list of Composite algorithms, the following general
   guidance was used, however during development of this specification
   several algorithms were added by direct request even though they do
   not fit this guidance.

   *  Pair equivalent levels.

   *  NIST-P-384 is CNSA approved [CNSA2.0] for all classification
      levels.

   *  521 bit curve not widely used.

   SHA2 is used throughout in order to facilitate implementations that
   do not have easy access to SHA3 outside of the ML-DSA function.

   At the higher security levels of pre-hashed Composite ML-DSA, for
   example id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512, the 384-bit
   elliptic curve component is used with SHA2-384 which is its pre-hash
   (ie the pre-hash that is considered to be internal to the ECDSA
   component), yet SHA2-512 is used as the pre-hash for the overall
   composite because in this case the pre-hash must not weaken the ML-
   DSA-87 component against a collision attack.

7.5.  RSASSA-PSS

   Use of RSASSA-PSS [RFC8017] requires extra parameters to be
   specified, which differ for each security level.

   Also note that this specification fixes the Public Key OID of RSASSA-
   PSS to id-RSASSA-PSS (1.2.840.113549.1.1.10), although most
   implementations also would accept rsaEncryption
   (1.2.840.113549.1.1.1).

7.5.1.  RSA2048-PSS

   The RSA component keys MUST be generated at the 2048-bit security
   level in order to match that of ML-DSA-44.

   As with the other composite signature algorithms, when id-
   MLDSA44-RSA2048-PSS and id-HashMLDSA44-RSA2048-PSS-SHA256 is used in
   an AlgorithmIdentifier, the parameters MUST be absent. id-
   MLDSA44-RSA2048-PSS and id-HashMLDSA44-RSA2048-PSS-SHA256 SHALL
   instantiate RSASSA-PSS with the following parameters:

                  +==========================+=========+
                  | RSASSA-PSS Parameter     | Value   |
                  +==========================+=========+
                  | Mask Generation Function | mgf1    |
                  +--------------------------+---------+
                  | Mask Generation params   | SHA-256 |
                  +--------------------------+---------+
                  | Message Digest Algorithm | SHA-256 |
                  +--------------------------+---------+
                  | Salt Length in bits      | 256     |
                  +--------------------------+---------+

                   Table 6: RSASSA-PSS 2048 Parameters

   where:

   *  Mask Generation Function (mgf1) is defined in [RFC8017]

   *  SHA-256 is defined in [RFC6234].

7.5.2.  RSA3072-PSS

   The RSA component keys MUST be generated at the 3072-bit security
   level in order to match that of ML-DSA-65.

   As with the other composite signature algorithms, when id-
   MLDSA65-RSA3072-PSS or id-HashMLDSA65-RSA3072-PSS-SHA512 is used in
   an AlgorithmIdentifier, the parameters MUST be absent. id-
   MLDSA65-RSA3072-PSS or id-HashMLDSA65-RSA3072-PSS-SHA512 SHALL
   instantiate RSASSA-PSS with the following parameters:

                  +==========================+=========+
                  | RSASSA-PSS Parameter     | Value   |
                  +==========================+=========+
                  | Mask Generation Function | mgf1    |
                  +--------------------------+---------+
                  | Mask Generation params   | SHA-256 |
                  +--------------------------+---------+
                  | Message Digest Algorithm | SHA-256 |
                  +--------------------------+---------+
                  | Salt Length in bits      | 256     |
                  +--------------------------+---------+

                   Table 7: RSASSA-PSS 3072 Parameters

   where:

   *  Mask Generation Function (mgf1) is defined in [RFC8017]

   *  SHA-256 is defined in [RFC6234].

7.5.3.  RSA4096-PSS

   The RSA component keys MUST be generated at the 4096-bit security
   level in order to match that of ML-DSA-65.

   As with the other composite signature algorithms, when id-
   MLDSA65-RSA4096-PSS or id-HashMLDSA65-RSA4096-PSS-SHA384 is used in
   an AlgorithmIdentifier, the parameters MUST be absent. id-
   MLDSA65-RSA4096-PSS or id-HashMLDSA65-RSA4096-PSS-SHA384 SHALL
   instantiate RSASSA-PSS with the following parameters:

                  +==========================+=========+
                  | RSASSA-PSS Parameter     | Value   |
                  +==========================+=========+
                  | Mask Generation Function | mgf1    |
                  +--------------------------+---------+
                  | Mask Generation params   | SHA-384 |
                  +--------------------------+---------+
                  | Message Digest Algorithm | SHA-384 |
                  +--------------------------+---------+
                  | Salt Length in bits      | 384     |
                  +--------------------------+---------+

                   Table 8: RSASSA-PSS 4096 Parameters

   where:

   *  Mask Generation Function (mgf1) is defined in [RFC8017]

   *  SHA-384 is defined in [RFC6234].

8.  Use in CMS

   [EDNOTE: The convention in LAMPS is to specify algorithms and their
   CMS conventions in separate documents.  Here we have presented them
   in the same document, but this section has been written so that it
   can easily be moved to a stand-alone document.]

   Composite Signature algorithms MAY be employed for one or more
   recipients in the CMS signed-data content type [RFC5652].

   All recommendations for using Composite ML-DSA in CMS are fully
   aligned with the use of ML-DSA in CMS [I-D.ietf-lamps-cms-ml-dsa].

8.1.  Underlying Components

   A compliant implementation MUST support SHA-512 [FIPS180] for all
   composite variants in this document.  Implementations MAY also
   support other algorithms for the SignerInfo digestAlgorithm and
   SHOULD use algorithms that produce a hash value of a size that is at
   least twice the collision strength of the internal commitment hash
   used by ML-DSA.

   Note: The Hash ML-DSA Composite identifiers are relevant here because
   this algorithm operation mode is not provided in CMS, which is
   consistent with [I-D.ietf-lamps-cms-ml-dsa].

8.2.  SignedData Conventions

   As specified in CMS [RFC5652], the digital signature is produced from
   the message digest and the signer's private key.  The signature is
   computed over different values depending on whether signed attributes
   are absent or present.

   When signed attributes are absent, the composite signature is
   computed over the content of the signed-data.  The "content" of a
   signed-data is the value of the encapContentInfo eContent OCTET
   STRING.  The tag and length octets are not included.  When signed
   attributes are present, a hash is computed over the content using the
   hash function specified in Section 8.1, and then a message-digest
   attribute is constructed to contain the resulting hash value, and
   then the result of DER encoding the set of signed attributes, which
   MUST include a content-type attribute and a message-digest attribute,
   and then the composite signature is computed over the DER-encoded
   output.  In summary:

   IF (signed attributes are absent)
      THEN Composite-ML-DSA.Sign(content)
   ELSE message-digest attribute = Hash(content);
      Composite-ML-DSA.Sign(DER(SignedAttributes))

   When using Composite Signatures, the fields in the SignerInfo are
   used as follows:

   digestAlgorithm: Per Section 5.3 of [RFC5652], the digestAlgorithm
   contains the one-way hash function used by the CMS signer.  To ensure
   collision resistance, the identified message digest algorithm SHOULD
   produce a hash value of a size that is at least twice the collision
   strength of the internal commitment hash used by ML-DSA component
   algorithm of the Composite Signature.

   signatureAlgorithm: The signatureAlgorithm MUST contain one of the
   the Composite Signature algorithm identifiers as specified in
   Section 8.1}

   signature: The signature field contains the signature value resulting
   from the composite signing operation of the specified
   signatureAlgorithm.

8.3.  Signature generation and verification

   Composite signatures have a context string input that can be used to
   ensure that different signatures are generated for different
   application contexts.  When using composite signatures for CMS, the
   context string is the empty string.

8.4.  Certificate Conventions

   The conventions specified in this section augment RFC 5280 [RFC5280].

   The willingness to accept a composite Signature Algorithm MAY be
   signaled by the use of the SMIMECapabilities Attribute as specified
   in Section 2.5.2. of [RFC8551] or the SMIMECapabilities certificate
   extension as specified in [RFC4262].

   The intended application for the public key MAY be indicated in the
   key usage certificate extension as specified in Section 4.2.1.3 of
   [RFC5280].  If the keyUsage extension is present in a certificate
   that conveys a composite Signature public key, then the key usage
   extension MUST contain only the following value:

   digitalSignature
   nonRepudiation
   keyCertSign
   cRLSign

   The keyEncipherment and dataEncipherment values MUST NOT be present.
   That is, a public key intended to be employed only with a composite
   signature algorithm MUST NOT also be employed for data encryption.
   This requirement does not carry any particular security
   consideration; only the convention that signature keys be identified
   with 'digitalSignature','nonRepudiation','keyCertSign' or 'cRLSign'
   key usages.

8.5.  SMIMECapabilities Attribute Conventions

   Section 2.5.2 of [RFC8551] defines the SMIMECapabilities attribute to
   announce a partial list of algorithms that an S/MIME implementation
   can support.  When constructing a CMS signed-data content type
   [RFC5652], a compliant implementation MAY include the
   SMIMECapabilities attribute.

   The SMIMECapability SEQUENCE representing a composite signature
   Algorithm MUST include the appropriate object identifier as per
   Section 8.1 in the capabilityID field.

9.  ASN.1 Module

   <CODE STARTS>

   Composite-MLDSA-2025
     { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-composite-mldsa-2025(TBDMOD) }


   DEFINITIONS IMPLICIT TAGS ::= BEGIN

   EXPORTS ALL;

   IMPORTS
     PUBLIC-KEY, SIGNATURE-ALGORITHM, SMIME-CAPS, AlgorithmIdentifier{}
       FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-algorithmInformation-02(58) }
   ;

   --
   -- Object Identifiers
   --

   -- Defined in ITU-T X.690
   der OBJECT IDENTIFIER ::=
     {joint-iso-itu-t asn1(1) ber-derived(2) distinguished-encoding(1)}

   --
   -- Signature Algorithm
   --

   --
   -- Composite Signature basic structures
   --

   --
   -- When a CompositeMLDSAPublicKey is used with an RSA public key, the BIT STRING is generated
   -- by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}},
   -- and an RSAPublicKey (which is a DER encoded RSAPublicKey).

   -- When a CompositeMLDSAPublicKey is used with an EC public key, the BIT STRING is generated
   -- by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}}
   -- and an ECDSAPublicKey according to [RFC5480].

   -- When a CompositeMLDSAPublicKey is used with an Edwards public key, the BIT STRING is generated
   -- by the concatenation of a raw ML-DSA key according to {{I-D.ietf-lamps-dilithium-certificates}}
   -- and a raw Edwards public key according to [RFC8410].

   CompositeMLDSAPublicKey ::= BIT STRING

   --
   -- When a CompositeMLDSAPrivateKey is used with an RSA public key, the OCTET STRING is generated
   -- by the concatenation of an ML-DSA private key according to {{I-D.ietf-lamps-dilithium-certificates}},
   -- and an RSAPrivateKey (which is a DER encoded RSAPrivateKey).

   -- When a CompositeMLDSAPrivateKey is used with an EC public key, the OCTET STRING is generated
   -- by the concatenation of an ML-DSA private key according to {{I-D.ietf-lamps-dilithium-certificates}},
   -- and an ECDSAPrivateKey according to [RFC5915].

   -- When a CompositeMLDSAPrivateKey is used with an Edwards public key, the OCTET STRING is generated
   -- by the concatenation of an ML-DSA private key according to {{I-D.ietf-lamps-dilithium-certificates}},
   -- and a raw Edwards private key according to [RFC8410].

   CompositeMLDSAPrivateKey ::= OCTET STRING

   -- Composite Signature Value is just an BIT STRING and is a concatenation of the component signature
   -- algorithms.

   CompositeSignatureValue ::= BIT STRING


   --
   -- Information Object Classes
   --

   pk-CompositeSignature {OBJECT IDENTIFIER:id, PublicKeyType}
       PUBLIC-KEY ::= {
         IDENTIFIER id
         KEY PublicKeyType
         PARAMS ARE absent
         CERT-KEY-USAGE { digitalSignature, nonRepudiation, keyCertSign, cRLSign}
       }

   sa-CompositeSignature{OBJECT IDENTIFIER:id,
      PUBLIC-KEY:publicKeyType }
         SIGNATURE-ALGORITHM ::=  {
            IDENTIFIER id
            VALUE CompositeSignatureValue
            PARAMS ARE absent
            PUBLIC-KEYS {publicKeyType}
         }

   -- PURE Version of OIDS

   -- TODO: OID to be replaced by IANA
   id-MLDSA44-RSA2048-PSS OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 60 }

   pk-MLDSA44-RSA2048-PSS PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA44-RSA2048-PSS,
     CompositeMLDSAPublicKey}

   sa-MLDSA44-RSA2048-PSS SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA44-RSA2048-PSS,
          pk-MLDSA44-RSA2048-PSS }

   -- TODO: OID to be replaced by IANA
   id-MLDSA44-RSA2048-PKCS15 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 61 }

   pk-MLDSA44-RSA2048-PKCS15 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA44-RSA2048-PKCS15,
     CompositeMLDSAPublicKey}

   sa-MLDSA44-RSA2048-PKCS15 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA44-RSA2048-PKCS15,
          pk-MLDSA44-RSA2048-PKCS15 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA44-Ed25519 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 62 }

   pk-MLDSA44-Ed25519 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA44-Ed25519,
     CompositeMLDSAPublicKey}

   sa-MLDSA44-Ed25519 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA44-Ed25519,
          pk-MLDSA44-Ed25519 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA44-ECDSA-P256 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 63 }

   pk-MLDSA44-ECDSA-P256 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA44-ECDSA-P256,
     CompositeMLDSAPublicKey}

   sa-MLDSA44-ECDSA-P256 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA44-ECDSA-P256,
          pk-MLDSA44-ECDSA-P256 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-RSA3072-PSS OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 64 }

   pk-MLDSA65-RSA3072-PSS PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-RSA3072-PSS,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-RSA3072-PSS SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-RSA3072-PSS,
          pk-MLDSA65-RSA3072-PSS }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-RSA3072-PKCS15 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 65 }

   pk-MLDSA65-RSA3072-PKCS15 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-RSA3072-PKCS15,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-RSA3072-PKCS15 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-RSA3072-PKCS15,
          pk-MLDSA65-RSA3072-PKCS15 }

   -- TODO: OID to be replaced by IANA
   id-MLDSA65-RSA4096-PSS OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 66 }

   pk-MLDSA65-RSA4096-PSS PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-RSA4096-PSS,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-RSA4096-PSS SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-RSA4096-PSS,
          pk-MLDSA65-RSA4096-PSS }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-RSA4096-PKCS15 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 67 }

   pk-MLDSA65-RSA4096-PKCS15 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-RSA4096-PKCS15,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-RSA4096-PKCS15 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-RSA4096-PKCS15,
          pk-MLDSA65-RSA4096-PKCS15 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-ECDSA-P256 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 68 }

   pk-MLDSA65-ECDSA-P256 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-ECDSA-P256,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-ECDSA-P256 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-ECDSA-P256,
          pk-MLDSA65-ECDSA-P256 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-ECDSA-P384 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 69 }

   pk-MLDSA65-ECDSA-P384 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-ECDSA-P384,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-ECDSA-P384 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-ECDSA-P384,
          pk-MLDSA65-ECDSA-P384 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-ECDSA-brainpoolP256r1 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 70 }

   pk-MLDSA65-ECDSA-brainpoolP256r1 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-ECDSA-brainpoolP256r1,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-ECDSA-brainpoolP256r1 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-ECDSA-brainpoolP256r1,
          pk-MLDSA65-ECDSA-brainpoolP256r1 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA65-Ed25519 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 71 }

   pk-MLDSA65-Ed25519 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA65-Ed25519,
     CompositeMLDSAPublicKey}

   sa-MLDSA65-Ed25519 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA65-Ed25519,
          pk-MLDSA65-Ed25519 }

   -- TODO: OID to be replaced by IANA
   id-MLDSA87-ECDSA-P384 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 72 }

   pk-MLDSA87-ECDSA-P384 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA87-ECDSA-P384,
     CompositeMLDSAPublicKey}

   sa-MLDSA87-ECDSA-P384 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA87-ECDSA-P384,
          pk-MLDSA87-ECDSA-P384 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA87-ECDSA-brainpoolP384r1 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 73 }

   pk-MLDSA87-ECDSA-brainpoolP384r1 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA87-ECDSA-brainpoolP384r1,
     CompositeMLDSAPublicKey}

   sa-MLDSA87-ECDSA-brainpoolP384r1 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA87-ECDSA-brainpoolP384r1,
          pk-MLDSA87-ECDSA-brainpoolP384r1 }


   -- TODO: OID to be replaced by IANA
   id-MLDSA87-Ed448 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 74 }

   pk-MLDSA87-Ed448 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA87-Ed448,
     CompositeMLDSAPublicKey}

   sa-MLDSA87-Ed448 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA87-Ed448,
          pk-MLDSA87-Ed448 }

   -- TODO: OID to be replaced by IANA
   id-MLDSA87- OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 75 }

   pk-MLDSA87-RSA4096-PSS PUBLIC-KEY ::=
     pk-CompositeSignature{ id-MLDSA87-RSA4096-PSS,
     CompositeMLDSAPublicKey}

   sa-MLDSA87-RSA4096-PSS SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-MLDSA87-RSA4096-PSS,
          pk-MLDSA87-RSA4096-PSS }

   -- PreHash Version of the OIDs

   -- TODO: OID to be replaced by IANA
   id-HashMLDSA44-RSA2048-PSS-SHA256 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 80 }

   pk-HashMLDSA44-RSA2048-PSS-SHA256 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA44-RSA2048-PSS-SHA256,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA44-RSA2048-PSS-SHA256 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA44-RSA2048-PSS-SHA256,
          pk-HashMLDSA44-RSA2048-PSS-SHA256 }

   -- TODO: OID to be replaced by IANA
   id-HashMLDSA44-RSA2048-PKCS15-SHA256 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 81 }

   pk-HashMLDSA44-RSA2048-PKCS15-SHA256 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA44-RSA2048-PKCS15-SHA256,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA44-RSA2048-PKCS15-SHA256 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA44-RSA2048-PKCS15-SHA256,
          pk-HashMLDSA44-RSA2048-PKCS15-SHA256 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA44-Ed25519-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 82 }

   pk-HashMLDSA44-Ed25519-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA44-Ed25519-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA44-Ed25519-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA44-Ed25519-SHA512,
          pk-HashMLDSA44-Ed25519-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA44-ECDSA-P256-SHA256 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 83 }

   pk-HashMLDSA44-ECDSA-P256-SHA256 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA44-ECDSA-P256-SHA256,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA44-ECDSA-P256-SHA256 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA44-ECDSA-P256-SHA256,
          pk-HashMLDSA44-ECDSA-P256-SHA256 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-RSA3072-PSS-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 84 }

   pk-HashMLDSA65-RSA3072-PSS-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-RSA3072-PSS-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-RSA3072-PSS-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-RSA3072-PSS-SHA512,
          pk-HashMLDSA65-RSA3072-PSS-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-RSA3072-PKCS15-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 85 }

   pk-HashMLDSA65-RSA3072-PKCS15-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-RSA3072-PKCS15-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-RSA3072-PKCS15-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-RSA3072-PKCS15-SHA512,
          pk-HashMLDSA65-RSA3072-PKCS15-SHA512 }

   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-RSA4096-PSS-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 86 }

   pk-HashMLDSA65-RSA4096-PSS-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-RSA4096-PSS-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-RSA4096-PSS-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-RSA4096-PSS-SHA512,
          pk-HashMLDSA65-RSA4096-PSS-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-RSA4096-PKCS15-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 87 }

   pk-HashMLDSA65-RSA4096-PKCS15-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-RSA4096-PKCS15-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-RSA4096-PKCS15-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-RSA4096-PKCS15-SHA512,
          pk-HashMLDSA65-RSA4096-PKCS15-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-ECDSA-P256-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 88 }

   pk-HashMLDSA65-ECDSA-P256-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-ECDSA-P256-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-ECDSA-P256-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-ECDSA-P256-SHA512,
          pk-HashMLDSA65-ECDSA-P256-SHA512 }




   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-ECDSA-P384-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 89 }

   pk-HashMLDSA65-ECDSA-P384-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-ECDSA-P384-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-ECDSA-P384-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-ECDSA-P384-SHA512,
          pk-HashMLDSA65-ECDSA-P384-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 90 }

   pk-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512,
          pk-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA65-Ed25519-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 91 }

   pk-HashMLDSA65-Ed25519-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA65-Ed25519-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA65-Ed25519-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA65-Ed25519-SHA512,
          pk-HashMLDSA65-Ed25519-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA87-ECDSA-P384-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 92 }

   pk-HashMLDSA87-ECDSA-P384-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA87-ECDSA-P384-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA87-ECDSA-P384-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA87-ECDSA-P384-SHA512,
          pk-HashMLDSA87-ECDSA-P384-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 93 }

   pk-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512,
          pk-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA87-Ed448-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 94 }

   pk-HashMLDSA87-Ed448-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA87-Ed448-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA87-Ed448-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA87-Ed448-SHA512,
          pk-HashMLDSA87-Ed448-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-HashMLDSA87-RSA4096-PSS-SHA512 OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) signature(1) 95 }

   pk-HashMLDSA87-RSA4096-PSS-SHA512 PUBLIC-KEY ::=
     pk-CompositeSignature{ id-HashMLDSA87-RSA4096-PSS-SHA512,
     CompositeMLDSAPublicKey}

   sa-HashMLDSA87-RSA4096-PSS-SHA512 SIGNATURE-ALGORITHM ::=
       sa-CompositeSignature{
          id-HashMLDSA87-RSA4096-PSS-SHA512,
          pk-HashMLDSA87-RSA4096-PSS-SHA512 }


   SignatureAlgorithmSet SIGNATURE-ALGORITHM ::= {
     sa-MLDSA44-RSA2048-PSS |
     sa-MLDSA44-RSA2048-PKCS15 |
     sa-MLDSA44-Ed25519 |
     sa-MLDSA44-ECDSA-P256 |
     sa-MLDSA65-RSA3072-PSS |
     sa-MLDSA65-RSA3072-PKCS15 |
     sa-MLDSA65-RSA4096-PSS |
     sa-MLDSA65-RSA4096-PKCS15 |
     sa-MLDSA65-ECDSA-P256 |
     sa-MLDSA65-ECDSA-P384 |
     sa-MLDSA65-ECDSA-brainpoolP256r1 |
     sa-MLDSA65-Ed25519 |
     sa-MLDSA87-ECDSA-P384 |
     sa-MLDSA87-ECDSA-brainpoolP384r1 |
     sa-MLDSA87-Ed448 |
     sa-MLDSA87-RSA4096-PSS |
     sa-HashMLDSA44-RSA2048-PSS-SHA256 |
     sa-HashMLDSA44-RSA2048-PKCS15-SHA256 |
     sa-HashMLDSA44-Ed25519-SHA512 |
     sa-HashMLDSA44-ECDSA-P256-SHA256 |
     sa-HashMLDSA65-RSA3072-PSS-SHA512 |
     sa-HashMLDSA65-RSA3072-PKCS15-SHA512 |
     sa-HashMLDSA65-RSA4096-PSS-SHA512 |
     sa-HashMLDSA65-RSA4096-PKCS15-SHA512 |
     sa-HashMLDSA65-ECDSA-P256-SHA512 |
     sa-HashMLDSA65-ECDSA-P384-SHA512 |
     sa-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512 |
     sa-HashMLDSA65-Ed25519-SHA512 |
     sa-HashMLDSA87-ECDSA-P384-SHA512 |
     sa-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512 |
     sa-HashMLDSA87-Ed448-SHA512 |
     sa-HashMLDSA87-RSA4096-PSS-SHA512,
     ... }


   --
   -- Expand the S/MIME capabilities set used by CMS [RFC5911]
   --

   -- TODO: this doesn't compile, error:
   -- "The referenced object in the 'ValueFromObject'
   -- syntax with the field '&smimeCaps' is invalid or does not exist."
   -- We need help from an SMIME expert

   SMimeCaps SMIME-CAPS ::= {
     sa-MLDSA44-RSA2048-PSS.&smimeCaps |
     sa-MLDSA44-RSA2048-PKCS15.&smimeCaps |
     sa-MLDSA44-Ed25519.&smimeCaps |
     sa-MLDSA44-ECDSA-P256.&smimeCaps |
     sa-MLDSA65-RSA3072-PSS.&smimeCaps |
     sa-MLDSA65-RSA3072-PKCS15.&smimeCaps |
     sa-MLDSA65-RSA4096-PSS.&smimeCaps |
     sa-MLDSA65-RSA4096-PKCS15.&smimeCaps |
     sa-MLDSA65-ECDSA-P256.&smimeCaps |
     sa-MLDSA65-ECDSA-P384.&smimeCaps |
     sa-MLDSA65-ECDSA-brainpoolP256r1.&smimeCaps |
     sa-MLDSA65-Ed25519.&smimeCaps |
     sa-MLDSA87-ECDSA-P384.&smimeCaps |
     sa-MLDSA87-ECDSA-brainpoolP384r1.&smimeCaps |
     sa-MLDSA87-Ed448.&smimeCaps |
     sa-MLDSA87-RSA4096-PSS.&smimeCaps |
     sa-HashMLDSA44-RSA2048-PSS-SHA256.&smimeCaps |
     sa-HashMLDSA44-RSA2048-PKCS15-SHA256.&smimeCaps |
     sa-HashMLDSA44-Ed25519-SHA512.&smimeCaps |
     sa-HashMLDSA44-ECDSA-P256-SHA256.&smimeCaps |
     sa-HashMLDSA65-RSA3072-PSS-SHA512.&smimeCaps |
     sa-HashMLDSA65-RSA3072-PKCS15-SHA512.&smimeCaps |
     sa-HashMLDSA65-RSA4096-PSS-SHA512.&smimeCaps |
     sa-HashMLDSA65-RSA4096-PKCS15-SHA512.&smimeCaps |
     sa-HashMLDSA65-ECDSA-P256-SHA512.&smimeCaps |
     sa-HashMLDSA65-ECDSA-P384-SHA512.&smimeCaps |
     sa-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512.&smimeCaps |
     sa-HashMLDSA65-Ed25519-SHA512.&smimeCaps |
     sa-HashMLDSA87-ECDSA-P384-SHA512.&smimeCaps |
     sa-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512.&smimeCaps |
     sa-HashMLDSA87-Ed448-SHA512.&smimeCaps |
     sa-HashMLDSA87-RSA4096-PSS-SHA512.&smimeCaps,
     ... }

   END

   <CODE ENDS>

10.  IANA Considerations

   IANA is requested to allocate a value from the "SMI Security for PKIX
   Module Identifier" registry [RFC7299] for the included ASN.1 module,
   and allocate values from "SMI Security for PKIX Algorithms" to
   identify the fourteen Algorithms defined within.

10.1.  Object Identifier Allocations

   EDNOTE to IANA: OIDs will need to be replaced in both the ASN.1
   module and in Table 2 and Table 3.

10.1.1.  Module Registration - SMI Security for PKIX Module Identifier

   *  Decimal: IANA Assigned - *Replace TBDMOD*

   *  Description: Composite-Signatures-2023 - id-mod-composite-
      signatures

   *  References: This Document

10.1.2.  Object Identifier Registrations - SMI Security for PKIX
         Algorithms

   *  id-MLDSA44-RSA2048-PSS

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA44-RSA2048-PSS

      -  References: This Document

   *  id-MLDSA44-RSA2048-PKCS15

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA44-RSA2048-PKCS15

      -  References: This Document

   *  id-MLDSA44-Ed25519

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA44-Ed25519

      -  References: This Document

   *  id-MLDSA44-ECDSA-P256

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA44-ECDSA-P256

      -  References: This Document

   *  id-MLDSA65-RSA3072-PSS

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-RSA3072-PSS

      -  References: This Document

   *  id-MLDSA65-RSA3072-PKCS15

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-RSA3072-PKCS15

      -  References: This Document

   *  id-MLDSA65-RSA4096-PSS

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-RSA4096-PSS

      -  References: This Document

   *  id-MLDSA65-RSA4096-PKCS15

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-RSA4096-PKCS15

      -  References: This Document

   *  id-MLDSA65-ECDSA-P256

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-ECDSA-P256

      -  References: This Document

   *  id-MLDSA65-ECDSA-P384

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-ECDSA-P384

      -  References: This Document

   *  id-MLDSA65-ECDSA-brainpoolP256r1

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-ECDSA-brainpoolP256r1

      -  References: This Document

   *  id-MLDSA65-Ed25519

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA65-Ed25519

      -  References: This Document

   *  id-MLDSA87-ECDSA-P384

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA87-ECDSA-P384

      -  References: This Document

   *  id-MLDSA87-ECDSA-brainpoolP384r1

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA87-ECDSA-brainpoolP384r1

      -  References: This Document

   *  id-MLDSA87-Ed448

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA87-Ed448

      -  References: This Document

   *  id-MLDSA87-RSA4096-PSS

      -  Decimal: IANA Assigned

      -  Description: id-MLDSA87-RSA4096-PSS

      -  References: This Document

   *  id-HashMLDSA44-RSA2048-PSS-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA44-RSA2048-PSS-SHA256

      -  References: This Document

   *  id-HashMLDSA44-RSA2048-PKCS15-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA44-RSA2048-PKCS15-SHA256

      -  References: This Document

   *  id-HashMLDSA44-Ed25519-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA44-Ed25519-SHA512

      -  References: This Document

   *  id-HashMLDSA44-ECDSA-P256-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA44-ECDSA-P256-SHA256

      -  References: This Document

   *  id-HashMLDSA65-RSA3072-PSS-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-RSA3072-PSS-SHA512

      -  References: This Document

   *  id-HashMLDSA65-RSA3072-PKCS15-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-RSA3072-PKCS15-SHA512

      -  References: This Document

   *  id-HashMLDSA65-RSA4096-PSS-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-RSA4096-PSS-SHA512

      -  References: This Document

   *  id-HashMLDSA65-RSA4096-PKCS15-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-RSA4096-PKCS15-SHA512

      -  References: This Document

   *  id-HashMLDSA65-ECDSA-P256-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-ECDSA-P256-SHA512

      -  References: This Document

   *  id-HashMLDSA65-ECDSA-P384-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-ECDSA-P384-SHA512

      -  References: This Document

   *  id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-ECDSA-brainpoolP256r1-SHA512

      -  References: This Document

   *  id-HashMLDSA65-Ed25519-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA65-Ed25519-SHA512

      -  References: This Document

   *  id-HashMLDSA87-ECDSA-P384-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA87-ECDSA-P384-SHA512

      -  References: This Document

   *  id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA87-ECDSA-brainpoolP384r1-SHA512

      -  References: This Document

   *  id-HashMLDSA87-Ed448-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA87-Ed448-SHA512

      -  References: This Document

   *  id-HashMLDSA87-RSA4096-PSS-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-HashMLDSA87-RSA4096-PSS-SHA512

      -  References: This Document

11.  Security Considerations

11.1.  Why Hybrids?

   In broad terms, a PQ/T Hybrid can be used either to provide dual-
   algorithm security or to provide migration flexibility.  Let's
   quickly explore both.

   Dual-algorithm security.  The general idea is that the data is
   proctected by two algorithms such that an attacker would need to
   break both in order to compromise the data.  As with most of
   cryptography, this property is easy to state in general terms, but
   becomes more complicated when expressed in formalisms.  Section 11.2
   goes into more detail here.  One common counter-argument against PQ/T
   hybrid signatures is that if an attacker can forge one of the
   component algorithms, then why attack the hybrid-signed message at
   all when they could simply forge a completely new message?  The
   answer to this question must be found outside the cryptographic
   primitives themselves, and instead in policy; once an algorithm is
   known to be broken it ought to be disallowed for single-algorithm use
   by cryptographic policy, while hybrids involving that algorithm may
   continue to be used and to provide value.

   Migration flexibility.  Some PQ/T hybrids exist to provide a sort of
   "OR" mode where the client can choose to use one algorithm or the
   other or both.  The intention is that the PQ/T hybrid mechanism
   builds in backwards compatibility to allow legacy and upgraded
   clients to co-exist and communicate.  The Composites presented in
   this specification do not provide this since they operate in a strict
   "AND" mode, but they do provide codebase migration flexibility.
   Consider that an organization has today a mature, validated,
   certified, hardened implementation of RSA or ECC.  Composites allow
   them to add to this an ML-DSA implementation which immediately starts
   providing benefits against long-term document integrity attacks even
   if that ML-DSA implemtation is still experimental, non-validated,
   non-certified, non-hardened implementation.  More details of
   obtaining FIPS certification of a composite algorithm can be found in
   Appendix D.1.

11.2.  Non-separability and EUF-CMA

   The signature combiner defined in this document is Weakly Non-
   Separable (WNS), as defined in
   [I-D.ietf-pquip-hybrid-signature-spectrums], since the forged message
   M will include the composite domain separator as evidence.  The
   prohibition on key reuse between composite and single-algorithm
   contexts discussed in Section 11.3 further strengthens the non-
   separability in practice, but does not achieve Strong Non-
   Separability (SNS) since policy mechanisms such as this are outside
   the definition of SNS.

   Unforgeability properties are somewhat more nuanced.  The classic
   EUF-CMA game is in reference to a pair of algorithms ( Sign(),
   Verify() ) where the attacker has access to a signing oracle using
   the Sign() and must produce a signature-message pair (s, m) that is
   accepted by the verifier using Verify() and where m was never signed
   by the oracle.  The pair ( CompositeML-DSA.Sign(), CompositeML-
   DSA.Verify() ) is EUF-CMA secure so long as at least one component
   algorithm is EUF-CMA secure.  There is a stronger notion of Strong
   Existential Unforgeability (SUF) in which an attacker is required to
   produce a new signature to an already-signed message.  CompositeML-
   DSA only achieves SUF security if both components are SUF secure,
   which is not a useful property; the argument is that if the first
   component algorithm is not SUF secure then by definition it admits at
   least one (s1*, m) pair where s1* was not produced by the honest
   signer and it then can be combined with an honestly-signed (s2, m)
   signature over the same message m to create ( (s1*, s2), m) which
   violates SUF for the composite algorithm.

   In addition to the classic EUF-CMA game, we should also consider a
   cross-protocol version of the EUF-CMA game that is relevant to
   hybrids.  Specifically, we want to consider a modified version of the
   EUF-CMA game where the attacker has access to either a signing oracle
   over the two component algorithms in isolation, Trad.Sign() and ML-
   DSA.Sign(), and attempts to fraudulently present them as a composite,
   or where the attacker has access to a composite oracle for signing
   and then attempts to split the signature back into components and
   present them to either ML-DSA.Verify() or Trad.Verify().  The latter
   version bears a resemblance to a stripping attack, which parallel
   signatures are subject to, but is slightly different in that the
   cross-protocol EUF-CMA game also considers modification message
   definition as signed differs from the message the verifier accepts.
   In contrast stripping attacks consider only removing one component
   signature and attempting verification under the remaining and the
   same original message.

   In the case of CompositeML-DSA, a specific message forgery exists for
   a cross-protocol EUF-CMA attack, namely introduced by the prefix
   construction addition to M.  This applies to use of individual
   component signing oracles with fraudulent presentation of the
   signature to a composite verification oracle, and use of a composite
   signing oracle with fraudulent splitting of the signature for
   presentation to component verification oracle(s) of either ML-
   DSA.Verify() or Trad.Verify().  In the first case, an attacker with
   access to signing oracles for the two component algorithms can sign
   M and then trivially assemble a composite.  In the second case, the
   message M (containing the composite domain separator) can be
   presented as having been signed by a standalone component algorithm.
   However, use of the context string for domain separation enables Weak
   Non-Separability and auditable checks on hybrid use, which is deemed
   a reasonable trade-off.  Moreover and very importantly, the cross-
   protocol EUF-CMA attack in either direction is foiled if implementors
   strictly follow the prohibition on key reuse presented in
   Section 11.3 since then there cannot exist simultaneously composite
   and non-composite signers and verifiers for the same keys.
   Consequently, following the specification and verification of the
   policy mechanism, such as a composite X.509 certificate which defines
   the bound keys, is essential when using keys intended for use with a
   CompositeML-DSA signing algorithm.

11.3.  Key Reuse

   When using single-algorithm cryptography, the best practice is to
   always generate fresh key material for each purpose, for example when
   renewing a certificate, or obtaining both a TLS and S/MIME
   certificate for the same device, however in practice key reuse in
   such scenarios is not always catastrophic to security and therefore
   often tolerated, despite cross-protocol attacks having been shown.
   (citation needed here)

   Within the broader context of PQ / Traditional hybrids, we need to
   consider new attack surfaces that arise due to the hybrid
   constructions that did not exist in single-algorithm contexts.  One
   of these is key reuse where the component keys within a hybrid are
   also used by themselves within a single-algorithm context.  For
   example, it might be tempting for an operator to take an already-
   deployed RSA key pair and combine it with an ML-DSA key pair to form
   a hybrid key pair for use in a hybrid algorithm.  Within a hybrid
   signature context this leads to a class of attacks referred to as
   "stripping attacks" discussed in Section 11.2 and may also open up
   risks from further cross-protocol attacks.  Despite the weak non-
   separability property offered by the composite signature combiner,
   key reuse MUST be avoided to prevent the introduction of EUF-CMA
   vulnerabilities.

   In addition, there is a further implication to key reuse regarding
   certificate revocation.  Upon receiving a new certificate enrollment
   request, many certification authorities will check if the requested
   public key has been previously revoked due to key compromise.  Often
   a CA will perform this check by using the public key hash.
   Therefore, even if both components of a composite have been
   previously revoked, the CA may only check the hash of the combined
   composite key and not find the revocations.  Therefore, because the
   possibilty of key reuse exists even though forbidden in this
   specification, CAs performing revocation checks on a composite key
   SHOULD also check both component keys independently to verify that
   the component keys have not been revoked.

11.4.  Policy for Deprecated and Acceptable Algorithms

   Traditionally, a public key, certificate, or signature contains a
   single cryptographic algorithm.  If and when an algorithm becomes
   deprecated (for example, RSA-512, or SHA1), then clients performing
   signatures or verifications should be updated to adhere to
   appropriate policies.

   In the composite model this is less obvious since implementers may
   decide that certain cryptographic algorithms have complementary
   security properties and are acceptable in combination even though one
   or both algorithms are deprecated for individual use.  As such, a
   single composite public key or certificate may contain a mixture of
   deprecated and non-deprecated algorithms.

   Since composite algorithms are registered independently of their
   component algorithms, their deprecation can be handled independently
   from that of their component algorithms.  For example a cryptographic
   policy might continue to allow id-MLDSA65-ECDSA-P256-SHA512 even
   after ECDSA-P256 is deprecated.

   When considering stripping attacks, one need consider the case where
   an attacker has fully compromised one of the component algorithms to
   the point that they can produce forged signatures that appear valid
   under one of the component public keys, and thus fool a victim
   verifier into accepting a forged signature.  The protection against
   this attack relies on the victim verifier trusting the pair of public
   keys as a single composite key, and not trusting the individual
   component keys by themselves.

   Specifically, in order to achieve this non-separability property,
   this specification makes two assumptions about how the verifier will
   establish trust in a composite public key:

   1.  This specification assumes that all of the component keys within
       a composite key are freshly generated for the composite; ie a
       given public key MUST NOT appear as a component within a
       composite key and also within single-algorithm constructions.

   2.  This specification assumes that composite public keys will be
       bound in a structure that contains a signature over the public
       key (for example, an X.509 Certificate [RFC5280]), which is
       chained back to a trust anchor, and where that signature
       algorithm is at least as strong as the composite public key that
       it is protecting.

   There are mechanisms within Internet PKI where trusted public keys do
   not appear within signed structures -- such as the Trust Anchor
   format defined in [RFC5914].  In such cases, it is the responsibility
   of implementers to ensure that trusted composite keys are distributed
   in a way that is tamper-resistant and does not allow the component
   keys to be trusted independently.

11.5.  Use of Prefix to for attack mitigation

   The Prefix value specified in the message format calculated in
   Section 4 can be used by a traditional verifier to detect if the
   composite signature has been stripped apart.  An attacker would need
   to compute M' = Prefix || Domain || len(ctx) || ctx || M or M' :=
   Prefix || Domain || len(ctx) || ctx || HashOID || PH(M).  Since the
   Prefix is the constant String "CompositeAlgorithmSignatures2025"
   (Byte encoding
   436F6D706F73697465416C676F726974686D5369676E61747572657332303235 ) a
   traditional verifier can check if the Message starts with this prefix
   and reject the message.

12.  References

12.1.  Normative References

   [FIPS.186-5]
              National Institute of Standards and Technology (NIST),
              "Digital Signature Standard (DSS)", February 2023,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.186-5.pdf>.

   [FIPS.204] National Institute of Standards and Technology (NIST),
              "Module-Lattice-Based Digital Signature Standard", August
              2024, <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.204.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS #10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              DOI 10.17487/RFC2986, November 2000,
              <https://www.rfc-editor.org/info/rfc2986>.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210,
              DOI 10.17487/RFC4210, September 2005,
              <https://www.rfc-editor.org/info/rfc4210>.

   [RFC4211]  Schaad, J., "Internet X.509 Public Key Infrastructure
              Certificate Request Message Format (CRMF)", RFC 4211,
              DOI 10.17487/RFC4211, September 2005,
              <https://www.rfc-editor.org/info/rfc4211>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, DOI 10.17487/RFC5480, March 2009,
              <https://www.rfc-editor.org/info/rfc5480>.

   [RFC5639]  Lochter, M. and J. Merkle, "Elliptic Curve Cryptography
              (ECC) Brainpool Standard Curves and Curve Generation",
              RFC 5639, DOI 10.17487/RFC5639, March 2010,
              <https://www.rfc-editor.org/info/rfc5639>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <https://www.rfc-editor.org/info/rfc5652>.

   [RFC5758]  Dang, Q., Santesson, S., Moriarty, K., Brown, D., and T.
              Polk, "Internet X.509 Public Key Infrastructure:
              Additional Algorithms and Identifiers for DSA and ECDSA",
              RFC 5758, DOI 10.17487/RFC5758, January 2010,
              <https://www.rfc-editor.org/info/rfc5758>.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958,
              DOI 10.17487/RFC5958, August 2010,
              <https://www.rfc-editor.org/info/rfc5958>.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090,
              DOI 10.17487/RFC6090, February 2011,
              <https://www.rfc-editor.org/info/rfc6090>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8410]  Josefsson, S. and J. Schaad, "Algorithm Identifiers for
              Ed25519, Ed448, X25519, and X448 for Use in the Internet
              X.509 Public Key Infrastructure", RFC 8410,
              DOI 10.17487/RFC8410, August 2018,
              <https://www.rfc-editor.org/info/rfc8410>.

   [RFC8411]  Schaad, J. and R. Andrews, "IANA Registration for the
              Cryptographic Algorithm Object Identifier Range",
              RFC 8411, DOI 10.17487/RFC8411, August 2018,
              <https://www.rfc-editor.org/info/rfc8411>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.

12.2.  Informative References

   [ANSSI2024]
              French Cybersecurity Agency (ANSSI), Federal Office for
              Information Security (BSI), Netherlands National
              Communications Security Agency (NLNCSA), and Swedish
              National Communications Security Authority, Swedish Armed
              Forces, "Position Paper on Quantum Key Distribution",
              n.d., <https://cyber.gouv.fr/sites/default/files/document/
              Quantum_Key_Distribution_Position_Paper.pdf>.

   [Bindel2017]
              Bindel, N., Herath, U., McKague, M., and D. Stebila,
              "Transitioning to a quantum-resistant public key
              infrastructure", 2017, <https://link.springer.com/
              chapter/10.1007/978-3-319-59879-6_22>.

   [BSI2021]  Federal Office for Information Security (BSI), "Quantum-
              safe cryptography - fundamentals, current developments and
              recommendations", October 2021,
              <https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/
              Publications/Brochure/quantum-safe-cryptography.pdf>.

   [I-D.ietf-lamps-cms-ml-dsa]
              S, B., R, A., and D. Van Geest, "Use of the ML-DSA
              Signature Algorithm in the Cryptographic Message Syntax
              (CMS)", Work in Progress, Internet-Draft, draft-ietf-
              lamps-cms-ml-dsa-02, 17 January 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-lamps-
              cms-ml-dsa-02>.

   [I-D.ietf-lamps-dilithium-certificates]
              Massimo, J., Kampanakis, P., Turner, S., and B.
              Westerbaan, "Internet X.509 Public Key Infrastructure:
              Algorithm Identifiers for ML-DSA", Work in Progress,
              Internet-Draft, draft-ietf-lamps-dilithium-certificates-
              04, 22 July 2024, <https://datatracker.ietf.org/doc/html/
              draft-ietf-lamps-dilithium-certificates-04>.

   [I-D.ietf-pquip-hybrid-signature-spectrums]
              Bindel, N., Hale, B., Connolly, D., and F. D, "Hybrid
              signature spectrums", Work in Progress, Internet-Draft,
              draft-ietf-pquip-hybrid-signature-spectrums-00, 24 May
              2024, <https://datatracker.ietf.org/doc/html/draft-ietf-
              pquip-hybrid-signature-spectrums-00>.

   [I-D.ietf-pquip-pqt-hybrid-terminology]
              D, F., P, M., and B. Hale, "Terminology for Post-Quantum
              Traditional Hybrid Schemes", Work in Progress, Internet-
              Draft, draft-ietf-pquip-pqt-hybrid-terminology-04, 10
              September 2024, <https://datatracker.ietf.org/doc/html/
              draft-ietf-pquip-pqt-hybrid-terminology-04>.

   [I-D.pala-klaussner-composite-kofn]
              Pala, M. and J. Klauner, "K-threshold Composite
              Signatures for the Internet PKI", Work in Progress,
              Internet-Draft, draft-pala-klaussner-composite-kofn-00, 15
              November 2022, <https://datatracker.ietf.org/doc/html/
              draft-pala-klaussner-composite-kofn-00>.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, DOI 10.17487/RFC3279, April
              2002, <https://www.rfc-editor.org/info/rfc3279>.

   [RFC5914]  Housley, R., Ashmore, S., and C. Wallace, "Trust Anchor
              Format", RFC 5914, DOI 10.17487/RFC5914, June 2010,
              <https://www.rfc-editor.org/info/rfc5914>.

   [RFC7292]  Moriarty, K., Ed., Nystrom, M., Parkinson, S., Rusch, A.,
              and M. Scott, "PKCS #12: Personal Information Exchange
              Syntax v1.1", RFC 7292, DOI 10.17487/RFC7292, July 2014,
              <https://www.rfc-editor.org/info/rfc7292>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/info/rfc7296>.

   [RFC7299]  Housley, R., "Object Identifier Registry for the PKIX
              Working Group", RFC 7299, DOI 10.17487/RFC7299, July 2014,
              <https://www.rfc-editor.org/info/rfc7299>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8551]  Schaad, J., Ramsdell, B., and S. Turner, "Secure/
              Multipurpose Internet Mail Extensions (S/MIME) Version 4.0
              Message Specification", RFC 8551, DOI 10.17487/RFC8551,
              April 2019, <https://www.rfc-editor.org/info/rfc8551>.

Appendix A.  Samples

A.1.  Explicit Composite Signature Examples

   TODO - Need Samples

Appendix B.  Component Algorithm Reference

   This section provides references to the full specification of the
   algorithms used in the composite constructions.

    +=========================+=========================+=============+
    | Component Signature     | OID                     |Specification|
    | Algorithm ID            |                         |             |
    +=========================+=========================+=============+
    | id-ML-DSA-44            | 2.16.840.1.101.3.4.3.17 |[FIPS.204]   |
    +-------------------------+-------------------------+-------------+
    | id-ML-DSA-65            | 2.16.840.1.101.3.4.3.18 |[FIPS.204]   |
    +-------------------------+-------------------------+-------------+
    | id-ML-DSA-87            | 2.16.840.1.101.3.4.3.19 |[FIPS.204]   |
    +-------------------------+-------------------------+-------------+
    | id-Ed25519              | 1.3.101.112             |[RFC8410]    |
    +-------------------------+-------------------------+-------------+
    | id-Ed448                | 1.3.101.113             |[RFC8410]    |
    +-------------------------+-------------------------+-------------+
    | ecdsa-with-SHA256       | 1.2.840.10045.4.3.2     |[RFC5758]    |
    +-------------------------+-------------------------+-------------+
    | ecdsa-with-SHA512       | 1.2.840.10045.4.3.4     |[RFC5758]    |
    +-------------------------+-------------------------+-------------+
    | sha256WithRSAEncryption | 1.2.840.113549.1.1.11   |[RFC8017]    |
    +-------------------------+-------------------------+-------------+
    | sha512WithRSAEncryption | 1.2.840.113549.1.1.13   |[RFC8017]    |
    +-------------------------+-------------------------+-------------+
    | id-RSASSA-PSS           | 1.2.840.113549.1.1.10   |[RFC8017]    |
    +-------------------------+-------------------------+-------------+

         Table 9: Component Signature Algorithms used in Composite
                               Constructions

       +==================+=======================+===============+
       | Elliptic CurveID | OID                   | Specification |
       +==================+=======================+===============+
       | secp256r1        | 1.2.840.10045.3.1.7   | [RFC6090]     |
       +------------------+-----------------------+---------------+
       | secp384r1        | 1.3.132.0.34          | [RFC6090]     |
       +------------------+-----------------------+---------------+
       | brainpoolP256r1  | 1.3.36.3.3.2.8.1.1.7  | [RFC5639]     |
       +------------------+-----------------------+---------------+
       | brainpoolP384r1  | 1.3.36.3.3.2.8.1.1.11 | [RFC5639]     |
       +------------------+-----------------------+---------------+

        Table 10: Elliptic Curves used in Composite Constructions

          +===========+=========================+===============+
          | HashID    | OID                     | Specification |
          +===========+=========================+===============+
          | id-sha256 | 2.16.840.1.101.3.4.2.1  | [RFC6234]     |
          +-----------+-------------------------+---------------+
          | id-sha512 | 2.16.840.1..101.3.4.2.3 | [RFC6234]     |
          +-----------+-------------------------+---------------+

                Table 11: Hash algorithms used in Composite
                               Constructions

Appendix C.  Component AlgorithmIdentifiers for Public Keys and
             Signatures

   To ease implementing Composite Signatures this section specifies the
   Algorithms Identifiers for each component algorithm.  They are
   provided as ASN.1 value notation and copy and paste DER encoding to
   avoid any ambiguity.  Developers may use this information to
   reconstruct non hybrid public keys and signatures from each component
   that can be fed to crypto APIs to create or verify a single component
   signature.

   For newer Algorithms like Ed25519 or ML-DSA the AlgorithmIdentifiers
   are the same for Public Key and Signature.  Older Algorithms have
   different AlgorithmIdentifiers for keys and signatures and are
   specified separately here for each component.

   *ML-DSA-44 -- AlgorithmIdentifier of Public Key and Signature*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ML-DSA-44   -- (2 16 840 1 101 3 4 3 17)
      }

   DER:
     30 0B 06 09 60 86 48 01 65 03 04 03 11

   *ML-DSA-65 -- AlgorithmIdentifier of Public Key and Signature*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ML-DSA-65   -- (2 16 840 1 101 3 4 3 18)
      }

   DER:
     30 0B 06 09 60 86 48 01 65 03 04 03 12

   *ML-DSA-87 -- AlgorithmIdentifier of Public Key and Signature*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ML-DSA-87   -- (2 16 840 1 101 3 4 3 19)
      }

   DER:
     30 0B 06 09 60 86 48 01 65 03 04 03 13

   *RSASSA-PSS 2048 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-RSASSA-PSS   -- (1.2.840.113549.1.1.10)
       }

   DER:
     30 0B 06 09 2A 86 48 86 F7 0D 01 01 0A

   *RSASSA-PSS 2048 -- AlgorithmIdentifier of Signature*

  ASN.1:
    signatureAlgorithm AlgorithmIdentifier ::= {
      algorithm id-RSASSA-PSS,   -- (1.2.840.113549.1.1.10)
      parameters ANY ::= {
        AlgorithmIdentifier ::= {
          algorithm id-sha256,   -- (2.16.840.1.101.3.4.2.1)
          parameters NULL
          },
        AlgorithmIdentifier ::= {
          algorithm id-mgf1,       -- (1.2.840.113549.1.1.8)
          parameters AlgorithmIdentifier ::= {
            algorithm id-sha256,   -- (2.16.840.1.101.3.4.2.1)
            parameters NULL
            }
          },
        saltLength 32
        }
      }

  DER:
    30 41 06 09 2A 86 48 86 F7 0D 01 01 0A 30 34 A0 0F 30 0D 06 09 60 86
    48 01 65 03 04 02 01 05 00 A1 1C 30 1A 06 09 2A 86 48 86 F7 0D 01 01
    08 30 0D 06 09 60 86 48 01 65 03 04 02 01 05 00 A2 03 02 01 20

   *RSASSA-PSS 3072 & 4096 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-RSASSA-PSS   -- (1.2.840.113549.1.1.10)
       }

   DER:
     30 0B 06 09 2A 86 48 86 F7 0D 01 01 0A

   *RSASSA-PSS 3072 & 4096 -- AlgorithmIdentifier of Signature*

  ASN.1:
    signatureAlgorithm AlgorithmIdentifier ::= {
      algorithm id-RSASSA-PSS,   -- (1.2.840.113549.1.1.10)
      parameters ANY ::= {
        AlgorithmIdentifier ::= {
          algorithm id-sha512,   -- (2.16.840.1.101.3.4.2.3)
          parameters NULL
          },
        AlgorithmIdentifier ::= {
          algorithm id-mgf1,       -- (1.2.840.113549.1.1.8)
          parameters AlgorithmIdentifier ::= {
            algorithm id-sha512,   -- (2.16.840.1.101.3.4.2.3)
            parameters NULL
            }
          },
        saltLength 64
        }
      }

  DER:
    30 41 06 09 2A 86 48 86 F7 0D 01 01 0A 30 34 A0 0F 30 0D 06 09 60 86
    48 01 65 03 04 02 03 05 00 A1 1C 30 1A 06 09 2A 86 48 86 F7 0D 01 01
    08 30 0D 06 09 60 86 48 01 65 03 04 02 03 05 00 A2 03 02 01 40

   *RSASSA-PKCS1-v1_5 2048 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm rsaEncryption,   -- (1.2.840.113549.1.1.1)
       parameters NULL
       }

   DER:
     30 0D 06 09 2A 86 48 86 F7 0D 01 01 01 05 00

   *RSASSA-PKCS1-v1_5 2048 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signatureAlgorithm AlgorithmIdentifier ::= {
       algorithm sha256WithRSAEncryption,   -- (1.2.840.113549.1.1.11)
       parameters NULL
       }

   DER:
     30 0D 06 09 2A 86 48 86 F7 0D 01 01 0D 05 00

   *RSASSA-PKCS1-v1_5 3072 & 4096 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm rsaEncryption,   -- (1.2.840.113549.1.1.1)
       parameters NULL
       }

   DER:
     30 0D 06 09 2A 86 48 86 F7 0D 01 01 01 05 00

   *RSASSA-PKCS1-v1_5 3072 & 4096 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signatureAlgorithm AlgorithmIdentifier ::= {
       algorithm sha512WithRSAEncryption,   -- (1.2.840.113549.1.1.13)
       parameters NULL
       }

   DER:
     30 0D 06 09 2A 86 48 86 F7 0D 01 01 0D 05 00

   *ECDSA NIST 256 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm secp256r1   -- (1.2.840.10045.3.1.7)
           }
         }
       }

   DER:
     30 13 06 07 2A 86 48 CE 3D 02 01 06 08 2A 86 48 CE 3D 03 01 07

   *ECDSA NIST 256 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signature AlgorithmIdentifier ::= {
       algorithm ecdsa-with-SHA256   -- (1.2.840.10045.4.3.2)
       }

   DER:
     30 0A 06 08 2A 86 48 CE 3D 04 03 02

   *ECDSA NIST-384 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm secp384r1   -- (1.3.132.0.34)
           }
         }
       }

   DER:
     30 10 06 07 2A 86 48 CE 3D 02 01 06 05 2B 81 04 00 22

   *ECDSA NIST-384 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signature AlgorithmIdentifier ::= {
       algorithm ecdsa-with-SHA384   -- (1.2.840.10045.4.3.3)
       }

   DER:
     30 0A 06 08 2A 86 48 CE 3D 04 03 03

   *ECDSA Brainpool-256 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm brainpoolP256r1   -- (1.3.36.3.3.2.8.1.1.7)
           }
         }
       }

   DER:
     30 14 06 07 2A 86 48 CE 3D 02 01 06 09 2B 24 03 03 02 08 01 01 07

   *ECDSA Brainpool-256 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signature AlgorithmIdentifier ::= {
       algorithm ecdsa-with-SHA256   -- (1.2.840.10045.4.3.2)
       }

   DER:
     30 0A 06 08 2A 86 48 CE 3D 04 03 02

   *ECDSA Brainpool-384 -- AlgorithmIdentifier of Public Key*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm brainpoolP384r1   -- (1.3.36.3.3.2.8.1.1.11)
           }
         }
       }

   DER:
     30 14 06 07 2A 86 48 CE 3D 02 01 06 09 2B 24 03 03 02 08 01 01 0B

   *ECDSA Brainpool-384 -- AlgorithmIdentifier of Signature*

   ASN.1:
     signature AlgorithmIdentifier ::= {
       algorithm ecdsa-with-SHA384   -- (1.2.840.10045.4.3.3)
       }

   DER:
     30 0A 06 08 2A 86 48 CE 3D 04 03 03

   *Ed25519 -- AlgorithmIdentifier of Public Key and Signature*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-Ed25519   -- (1.3.101.112)
       }

   DER:
     30 05 06 03 2B 65 70

   *Ed448 -- AlgorithmIdentifier of Public Key and Signature*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-Ed448   -- (1.3.101.113)
       }

   DER:
     30 05 06 03 2B 65 71

Appendix D.  Implementation Considerations

D.1.  FIPS certification

   One of the primary design goals of this specification is for the
   overall composite algorithm to be able to be considered FIPS-approved
   even when one of the component algorithms is not.

   Implementors seeking FIPS certification of a composite Signature
   algorithm where only one of the component algorithms has been FIPS-
   validated or FIPS-approved should credit the FIPS-validated component
   algorithm with full security strength, the non-FIPS-validated
   component algorithm with zero security, and the overall composite
   should be considered at least as strong and thus FIPS-approved.

   The authors wish to note that this gives composite algorithms great
   future utility both for future cryptographic migrations as well as
   bridging across jurisdictions, for example defining composite
   algorithms which combine FIPS cryptography with cryptography from a
   different national standards body.

D.2.  Backwards Compatibility

   The term "backwards compatibility" is used here to mean something
   more specific; that existing systems as they are deployed today can
   interoperate with the upgraded systems of the future.  This draft
   explicitly does not provide backwards compatibility, only upgraded
   systems will understand the OIDs defined in this document.

   If backwards compatibility is required, then additional mechanisms
   will be needed.  Migration and interoperability concerns need to be
   thought about in the context of various types of protocols that make
   use of X.509 and PKIX with relation to digital signature objects,
   from online negotiated protocols such as TLS 1.3 [RFC8446] and IKEv2
   [RFC7296], to non-negotiated asynchronous protocols such as S/MIME
   signed email [RFC8551], document signing such as in the context of
   the European eIDAS regulations [eIDAS2014], and publicly trusted code
   signing [codeSigningBRsv2.8], as well as myriad other standardized
   and proprietary protocols and applications that leverage CMS
   [RFC5652] signed structures.  Composite simplifies the protocol
   design work because it can be implemented as a signature algorithm
   that fits into existing systems.

D.2.1.  Hybrid Extensions (Keys and Signatures)

   The use of Composite Crypto provides the possibility to process
   multiple algorithms without changing the logic of applications but
   updating the cryptographic libraries: one-time change across the
   whole system.  However, when it is not possible to upgrade the crypto
   engines/libraries, it is possible to leverage X.509 extensions to
   encode the additional keys and signatures.  When the custom
   extensions are not marked critical, although this approach provides
   the most backward-compatible approach where clients can simply ignore
   the post-quantum (or extra) keys and signatures, it also requires all
   applications to be updated for correctly processing multiple
   algorithms together.

Appendix E.  Intellectual Property Considerations

   The following IPR Disclosure relates to this draft:

   https://datatracker.ietf.org/ipr/3588/

Appendix F.  Contributors and Acknowledgements

   This document incorporates contributions and comments from a large
   group of experts.  The Editors would especially like to acknowledge
   the expertise and tireless dedication of the following people, who
   attended many long meetings and generated millions of bytes of
   electronic mail and VOIP traffic over the past few years in pursuit
   of this document:

   Daniel Van Geest (CryptoNext), Dr. Britta Hale (Naval Postgraduade
   School), Tim Hollebeek (Digicert), Panos Kampanakis (Cisco Systems),
   Richard Kisley (IBM), Serge Mister (Entrust), Piotr Popis, Franois
   Rousseau, Falko Strenzke, Felipe Ventura (Entrust), Alexander Ralien
   (Siemens), Jos Ignacio Escribano, Jan Oupick,  (Abel C.  H.
   Chen, Chunghwa Telecom),  (Austin Lin, Chunghwa Telecom) and
   Mojtaba Bisheh-Niasar

   We especially want to recognize the contributions of Dr. Britta Hale
   who has helped immensely with strengthening the signature combiner
   construction, and with analyzing the scheme with respect to EUF-CMA
   and Non-Separability properties.

   We are grateful to all who have given feedback over the years,
   formally or informally, on mailing lists or in person, including any
   contributors who may have been inadvertently omitted from this list.

   This document borrows text from similar documents, including those
   referenced below.  Thanks go to the authors of those documents.
   "Copying always makes things easier and less error prone" -
   [RFC8411].

F.1.  Making contributions

   Additional contributions to this draft are welcome.  Please see the
   working copy of this draft at, as well as open issues at:

   https://github.com/lamps-wg/draft-composite-sigs

Authors' Addresses

   Mike Ounsworth
   Entrust Limited
   2500 Solandt Road  Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: mike.ounsworth@entrust.com


   John Gray
   Entrust Limited
   2500 Solandt Road  Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: john.gray@entrust.com


   Massimiliano Pala
   OpenCA Labs
   New York City, New York,
   United States of America
   Email: director@openca.org


   Jan Klaussner
   Bundesdruckerei GmbH
   Kommandantenstr. 18
   10969 Berlin
   Germany
   Email: jan.klaussner@bdr.de


   Scott Fluhrer
   Cisco Systems
   Email: sfluhrer@cisco.com
